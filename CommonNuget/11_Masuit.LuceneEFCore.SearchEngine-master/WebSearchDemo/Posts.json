[
  {
    "title": "思维导图 XMind 官方澄清与苏州思杰马克丁代理合作",
    "author": "懒得勤快",
    "content": "所谓墙倒众人推，破鼓万人捶越来越多的公司开始认清了该公司的无耻与下流终止中国区代理商苏州思杰马克丁公司代理合作，XMind思维导图简单易用，美观且功能强大，用头脑风暴激发创意，提高效率，让你的思维可视化，2018年7月3日16:01消息知乎上面 XMind&nbsp;思维导图软件官方知乎认证账号发布了一则惊人激动人心的消息，宣布与中国区代理商苏州思杰马克丁公司终止代理合作。https://www.zhihu.com/question/283543781原文如下：官方澄清一下目前我们已经和之前XMind中国区代理商苏州思杰马克丁公司终止代理合作。之后的售卖和升级服务请认准官方网站www.xmind.cn，我们将会为大家提供优质的产品&amp;客服服务。XMind 这12年来受到了全球众多用户的喜爱，感谢所有用户一如既往的支持。在思维导图领域我们已经踏踏实实做了12年，我们会将这份热诚继续下去，继续为大家提供免费&amp;付费的优秀思维导图服务。感谢支持！虽然终止与该公司的代理合作，中文假官网并没有关闭而且点击进去把购买链接引到了另外一款代理软件MindManager破解版xmind下载地址",
    "postDate": "2019-01-30T23:40:45.3310946+08:00",
    "email": "admin@masuit.com",
    "label": "思杰马克丁,xmind",
    "keyword": "思维导图,XMind,苏州思杰马克丁,思杰马克丁,业界毒瘤,思杰马克狗,流氓公司,盗版商马克丁死全家",
    "id": 1231,
    "indexId": "Post:1231"
  },
  {
    "title": "苏州思杰马克丁软件有限公司存在诈骗行为，恶意诱导链接修",
    "author": "懒得勤快",
    "content": "本文转自：http://www.55178.cc/jiaodian/1209.html本人用的软件为CorelDRAW X7明明为高版本的，然后弹出来警告盗版软件，因本人在软件里面做好了一本画册，就剩下输出打印了，时间到盗版提示的最后一天时间了，迫不得已，本人就打开软件链接进去，发生了购买行为，本人按网络连接购买了正版2399元，（立马会有一个邮箱出来个购买成功的邮件），这里的购买成功并不是真的购买成功可以使用，而是一次恶意误导连接行为，结果出乎意料的是，周五下午时间（只有我的订单信息，没有序列号回复的邮箱里面也没有周六、周日不上班的提示），很是着急，苦苦等到到周一打电话几次主动催办的时候，客服才给我邮箱里面发了注册码，注意这个注册码来之不易（周五下午至周一共计70多个小时）并不是掏钱后立马就能拿到手里，而且拿到手里的注册码，压根就没有实际用途，掏了钱之后就成这家软件公司的肉鸡了，接下来你会一步步任凭他们摆布玩弄，然后邮箱里面给你的这个注册码，一点用没有然叫你后去一个公众账号注册，输入邮箱里面的信息，本以为输入完后就可以用软件了，输入信息后客服回复还要等1——3天，实在按耐不住本人打电话要退款，退货，因为真正的序列号并没有给本人，本人亲自打了几十遍电话去客服，客服一直说买了不能退我说我的高版本的你们的软件压根不能用，时间和版本上都不是我需要的，客服压根不鸟你，就是你购买后无法退回即使没有出真的序列号也不能退，本人坚决不要恶狠狠的跟客服说实在不想要但是一点用的没有，等了几天后他们按照低版本的软件发给我序列号，并非给了你真的序列号就能安装成功，他们在终端会植入很多应用程序导致你安装不了cdr，必须重新做系统，本人系统有几十种软件，实在是不能在重新折腾时间，只好把次软件放那里不用，花钱买了个教训，希望各位不要在上当受骗！至今中国没有维权机构！确实是个垃圾公司，让中国的网名受害，最好不要买他的软件，代理商可以有权修改软件本身和数字签名了？这些软件公司就真的这么无法无天吗？喊天喊地都没有用，什么公司投诉压根不能解决问题，真是流氓公司，难道没有机构来处理一直任他们胡作非为，满中国圈钱吗？都是百姓的血汗钱啊！MKD的操作流程▼MKD的获益途径▼MKD的部分评价▼!!免责声明:本网部分文章和信息来源于国际互联网,本网转载出于传递更多信息和学习之目的,并不意味着赞同其观点或证实其内容的真实性。",
    "postDate": "2019-01-30T23:40:45.3326619+08:00",
    "email": "admin@masuit.com",
    "label": "思杰马克丁,思杰马克狗",
    "keyword": "苏州思杰马克丁,思杰马克丁软件,思杰马克丁,思杰马克狗,流氓公司,盗版商马克丁死全家",
    "id": 1246,
    "indexId": "Post:1246"
  },
  {
    "title": "揭开软件行业毒瘤思杰马克丁的虚伪面纱——墨雨",
    "author": "懒得勤快",
    "content": "警告苏州思杰马克丁公司法务部：本文属事实，已标明我引用的部分，并附上链接。引用部分属于知乎“匿名用户”的文章，作者理应享有文章的著作权。而我写的，是本人的看法，你们无权干涉。并且，文章所说都为事实，并无虚假捏造成分！不用我说，都知道思杰马克丁是什么了吧。他们的所作所为，只有新接触他们公司的用户还不清楚。例如，篡改版权方数字签名，植入插件，修改程序内指向原公司网站的链接……等等等。马克丁的名声在熟悉网络、软件的用户心中早已名声扫地！！！FL吧对马克丁这个公司深恶痛绝。FL吧吧主声明FL Studio在中国仅一家代理商即吧主开设的代理商（雪帝数字音频有限公司），并无其余代理商。马克丁属于用正版的价格公然卖盗版。其次，经我查询多款他们代理的软件，均未在版权公司官网上看到在中华人民共和国的代理商！不知道他们是否真正有代理权。他们是怎么打击盗版的呢？代理过来的软件（不知什么途径），立刻在中国申请计算机软件著作权，我不知道他们的著作权怎么来的，他们并不是软件开发商。而且著作权都是类似“思杰马克丁Corel VideoStudio 视频编辑软件”，“思杰马克丁&nbsp;MindManager思维导图工具软件”等空头软件名。软件著作权属于空头软件，其符合名称的软件并不存在，因为思杰马克丁没有开发软件的能力。会声会影的全称：”Corel Videostudio” 著作权属于加拿大Corel公司。展开轰轰烈烈的“打击盗版”运动。发律师函，淘宝恶意投诉同行（为了让网上的链接都换成他们的试用版，引流到他们公司购买，坑害不了解情况的用户）分享原版安装程序的网站及链接，都会被他们举报，原因你懂的，上一行刚说过。抬价，让消费者买他们修改过的劣质产品，不仅会出现各种兼容问题（由于篡改了数字签名），而且还得多付钱。售后不是一般的差，软件有问题一问三不知。其次，不知道他们的软件在理论上是否属于正版。因为你买到的是他们已经修改过的软件，并不属于原版权公司所开发的软件。软件厂商授权你们修改二进制了？？？？？软件厂商把著作权转让给你们了？？？？你们哪来的权利修改版权公司的软件？？？？？？思杰马克丁——中国最无耻的代理商，没有之一！！！！引用部分：作者：匿名用户链接：https://www.zhihu.com/question/46746200/answer/173678562来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。此贴有素材引用自其他地方，侵删久等了各位，今天我们来扒一扒马克丁的故事。马克丁这家狗公司的人估计看了会举报我，没事你们尽管举报，你删了劳资再发就行了，有存稿的，劳资有的是时间陪你们这群流氓玩，大家顶上去，删了我还会继续发好了废话不多说，今天我们来说一下FL吧一直以来深恶痛绝的“苏州思杰马克丁”。“苏州思杰马克丁”，是一家坐落于苏州科技园的软件公司。（以下简称”马克丁“）马克丁的背景不知道有多大，不过据说和诸多大型企业保持着良好的PYJY关系。为什么马克丁会被视为业界毒瘤呢？接下来，我们将逐一揭开其中的奥秘第一章：盗版巨头？马克丁，全称“苏州思杰马克丁软件有限公司”，相信作为网龄超过10年老网虫们基本都不会对这个名字陌生，虽然苏州思杰马克丁软件有限公司成立于2009年，但是早在2009年之前，很多人就已经熟知“马克丁”这个名字了。在21世纪初，家家户户还在使用windows XP系统的时候，各种软件的下载成了难题，破解软件应需求而出，网络上泛滥着各种盗版软件，这些软件破解一部分来源于国外，另一部分则来源于中国本土的红客联盟及破解组织，马克丁，老红客联盟论坛（现已下线）一名默默无闻的用户，破解着各种软件，也在享受着各种软件，虽然现在离XP年代已经过去了好几年，相信不少那时候就有电脑玩的同学，在那时经常会见到某绿色版软件中破解署名为“马克丁”，这件事知道的人不多，不过应该还有人能记得。随着时间的推移，XP系统几次更新，老一代的灰色框框的软件也逐渐退出了历史舞台，如今基本在网络上找不到下载了，那些大小只有10几MB的软件，也被人们所遗忘，作为网龄已达17年的老网虫，我也是在偶然一次下载一个关于FTP数据库的软件的时候，随手翻了一下软件的数字签名，偶然想到十多年前也曾经见过“马克丁”三个字，然而当年的“马克丁”现在已经变成了“苏州思杰马克丁”，直到这时候，那段基本被尘封的记忆才被打开。虽然是猜测，我也没办法找到当年下载过的软件，家里还能找到的同年代产物只有一台神州台式机电脑，但是由于年久失修，经过lz不屑的努力最终还是没能点亮，但是种种迹象表明当年这位破解大神“马克丁”和现在的“思杰马克丁”有着千丝万缕的联系。2009年，正版软件开始风行，越来越多的人开始原以为正版软件买单，马克丁作为第一批投身正版的人，永久的消失在了破解行业的视野里。同期，苏州思杰马克丁软件公司成立，大批量代理各种专业软件，一夜间，百度搜索软件能下载到的破解版软件全部变成了试用版软件，当然，电子签名上依然少不了几个大字”苏州思杰马克丁“。曾几何时，那段没有软件可以使用的日子成为了当时人民心头的一块大病，人们纷纷猜测“苏州思杰马克丁”到底是何方神圣？一夜间消失的盗版到底去哪里？难道中国就这样进入了正版时代吗？第二章：正版大佬？随着版权意识的觉醒，越来越多的人开始使用正版软件，马克丁又以新的身份，“苏州思杰马克丁”重新进入到公众的视野。期初，只是网上诸如FTP工具软件，数据恢复软件等小的工具软件被下架换成了“马克丁试用版”，人们除了倍感使用不便还并没有什么其他的问题发生。不知不觉，马克丁开始代理各种各样的软件，小到一个压缩软件，大到专业宿主软件，无不成为苏州思杰马克丁的代理对象，当人们有所察觉时，很多随手下载的软件，都已经被替换成为“马克丁试用版”，马克丁俨然一副软件行业正版大佬的派头，就连自己软广告的宣传语都是“我们这里全都是正版！正版！正版！”若说使用正版软件，无可厚非，也是作为一个软件使用者应该做的，马克丁代理正版软件其实也没什么，不管是谁代理，我们用的是软件，其实都是一个样子的。但是随着马克丁的网逐渐扩大，隐约可以感觉到，马克丁的野心似乎并不止如此。当时，马克丁成功拿下了“会声会影”软件的代理，“会声会影”一款视频处理软件，上手简单，功能多种多样，操作并不复杂，曾经一度广受大家欢迎，也一度是盗版的重灾区。不过会声会影一向在售后服务方面相当有诚意，所以一直以来正版用户与盗版用户并驾齐驱，很多人在长时间使用盗版学习之后，最终还是转向正版，毕竟正版的更新、模板以及售后服务都很诱人。但是在马克丁拿下会声会影的代理之后，事情却变了味道。在微软更新过一次系统补丁之后，由于一名在马克丁购买了会声会影的客户因为系统卡顿而卸载了会声会影，准备重新装的时候，却发现死活无法安装，同期很多新购买的用户也无法在补丁更新之后安装软件，于是各位用户在多次网上查询问题无果之后找到了马克丁官方售后服务，当时群情激奋，有的要求解决，有的则要求退款。马克丁售后服务人员进行安装调试失败之后，要求各位用户重装系统，但是由于很多用户电脑文件重要，不愿意重装系统，于是要求退款成为了主流要求。这时候马克丁的客服开始撕破脸皮了，叫嚣着要起诉各位用户，并且拒绝退款。一口一个法盲叫喊着，并且以强硬的态度说微软更新的问题，你们去找微软，不要找我们。一时间网上骂声四起，我在外网查询了一下，“会声会影”是加拿大一家公司编写的软件，然而这个问题却在外网并没有发生。这就奇怪了，为什么只有中国地区发生了这个问题呢？为什么国外也是正常更新，却没有一台电脑发生无法安装或者安装失败这种错误呢？经过我不懈的翻查，终于找到了当时微软在XP系统上更新的那次补丁的具体内容，“数字签名认证补丁”，何为数字签名认证？原来，软件开发分为两个版本beta版和正式版，一些小的公司在研发软件的时候会产生各种各样的试用版，试用版可以无条件安装使用，但是如果你想正式发售，需要向微软缴纳一定数额的数字签名费以购买数字签名，才能确保正式版在windows系统上的安装。这个其实不怪微软心黑，数字签名是用于保护系统免受一些其他恶意程序侵犯的必要程序，就像你家的钥匙，如果没有数字签名，任何一款病毒或者木马都可以伪装成一款你需要的软件，在你点击运行exe的同时悄无声息的潜入你的电脑。为什么微软更新了数字签名补丁，中国地区的会声会影就无法使用了，而其他地区的会声会影却能不受影响？答案显而易见，原来，马克丁公司对会声会影的数字签名进行了修改，嵌入了自己公司的数字签名，把软件安装完成后指向的官方地址修改成了自己做的“官方网站”，同时还对里面诸多版权信息等签名信息完完全全修改成了自己的信息。至于是否还加入了其他后门程序，我们就不得而知了，但是可以确定的是，这次补丁，完善了数字签名认证系统，马克丁对数字签名进行了修改，直接导致了微软认证数字签名发生了错误，所以软件无法安装。而这个问题，直到下一个版本更新后，才得到了解决。但是这种行为真的合法吗？数字签名，顾名思义，网络计算机世界中的签名程序，代表的是著作权、版权等一系列信息，马克丁代理了软件这一点无可厚非，马克丁是其代理的软件的中国地区的受益人，但是，归根结底，软件的版权、著作权依然是归属编写方所有，编写程序，很多地方都需要数字签名的认证，而破解程序的原理无非也是欺骗数字签名内部的认证系统确保授权已被读取。除软件最底层的数字签名无法修改外，软件构成框架中诸多数字签名都可以通过逆编写的手段进行改写，那么一来，马克丁公司代理的软件，到底是正版还是盗版呢？这就引人深思了。换言之，马克丁现在的行为相当于对软件进行了破解，利用之前的加密框架对软件进行了重新加密，换句话说就是自己换了密码，但是锁还是之前的。如此一来不由得引人猜测，用户购买的“正版软件”真的是正版吗？马克丁完全有能力获得正版授权之后对软件进行破解，然后注入自己的数字签名和加密锁，把软件纳为己有，售出软件却不用给软件制作方一毛钱。用户要求退款，他们自然是做不到的。让他们解决问题，他们还是如此，毕竟他们并不具备直接编译软件底层的能力，软件也确实不是他们写的，这样一切也都说得通了。随之而来的，是更多的数字签名事件，在马克丁旗下代理的所有软件中，均发现了数字签名被篡改的情况，这也不由得引人深思，你丫是谁你就把这软件签上你自己的名字？还要不要点碧莲？一个正版软件组成的帝国，由于一次签名事故，形象在公众面前轰然倒塌。第三章：维权斗士？马克丁在信誉危机产生的同时，倍感压力，一时间群情激奋，马克丁成为千夫所指，一代正版大佬名声扫地人们不再相信马克丁，马克丁对待客户粗暴无礼的形象也逐渐被大家所发现。同时关于马克丁各种黑历史也逐渐被挖掘出来。一位视频行业爱好者曝光，因为此公司不经本人同意擅自把他制作的视频教程拿去售卖，然后反过来告原作者。马克丁网站更新的各种教程一时间也成为了大家的怀疑对象，这些教程到底是哪来的？真实的作者又是谁？同时又有知情人士表示，网上有很多隶属于马克丁的软件学习群，里面公开散布各种行业爱好者制作的教程视频，而最后，群内发布的软件却是马克丁版本的软件，以诱导用户在马克丁平台上购买这些软件，一个正版软件大佬，背地里却散布着他人视频你教程的盗版，这不禁令人哗然。不得不佩服马克丁公关部门的思考速度，马克丁面对公司公众形象倒塌所带来的各种危机，迅速想出了一套对策，公司形象转型—维权斗士。马克丁迅速向有自己代理软件的绿色版网站发出律师函，要求这些软件下载网站下架自己代理软件，并且向淘宝对近百家售卖破解软件的网店发起投诉，甚至包括周边行业如一些内置了这些破解软件的“免装硬盘”店家、专业软件技能从业店家，一时间近百家店铺关门整顿，软件下载网站人人自危，所有绿色版软件均被替换成了指向思杰马克定官方网站的“马克丁试用版”。以此转型成“维权斗士”，来混淆公众视听，掩盖“数字签名事件”对马克丁带来的影响。不得不说，这个做法确实奏效，软件使用者人人自危，不敢发声，没人再关注之前上当受骗的用户，网上所有的软件均被替换成马克丁版本，加大了马克丁伪官网的流量，可谓是两全其美策略。然而，窟窿是堵住了，马克丁的名声，已经遗臭万年。马克丁再次以维权斗士的形象站了起来，马克丁的律师团队如明朝时候的锦衣卫，哪里有软件哪里就有他们，马克丁到处招蜂引蝶，拳打南山敬老院，脚踢北海幼儿园，抓shi如泥，大街有人谁怕他，大街无人他怕谁？总之，虽然引得骂声一片，但是充分体现了自己维权斗士的形象，还雇佣大批水军，企图淹没对其讨伐的声音。然而，他对数字签名更改的同时除了侵犯到软件制作方的著作权以外，还同时已经侵犯到了软件使用者的各种权益，由于中国只对版权法律有明确的规定，在关于数字签名的法律问题上并没有完善的法律条款，而马克丁的这种做法，实质上在国外已属违法行为。一个侵犯着制作方与使用方双方权利的人站起来维权？这种做法难道不是贼喊捉贼？总之，市场还是顺了他的心，“数字签名事件”被成功的掩盖，知晓这件事的人也大多事不关己高高挂起，毕竟，跟疯狗讲道理，万一被咬了呢？第四章：行业流氓！马克丁就这样，继续在软件行业混的风生水起，然而所谓的民众正版意识，真的觉醒了么？其实并没有，大家依然使用着各种软件，很少问津这背后的故事。直到马克丁把魔抓伸向音乐制作软件。FL吧作为编曲吧多年来的战友贴吧，一直秉承着相互帮助的原则，时常也互通有无，交流一下行业内的新闻，FL吧的吧主也是多年来一直代理着FL中国地区软件的代理商，这时候有阴谋论者也许会说了，你说了这么多马克丁的不好，就是为了说FL吧吧主好吧？在这里恐怕要让各位失望了，FL吧吧主在任期间并没有强制销售过任何FL软件，甚至很多老吧友都不知道其真实身份，FL吧主一直默默管理FL吧，为大家排异解惑。相比马克丁，可谓是良心代理商了。FL吧在前段时间，资源导航帖被百度强制性删除，经吧主查证，原来这件事的始作俑者正是马克丁，同时马克丁还在贴吧大量发布“马克丁试用版”的软件资源，企图强制性引流大众去下载马克丁的软件，同时，马克丁还几度造谣生事，宣称自己才是FL的官方代理，否认FL吧主在中国地区FL软件的代理权。于是FL的小吧就委托我去查一下这个“思杰马克丁”，功夫不负有心人，马克丁诸多黑历史还是暴露在大众眼前，同时，FL吧吧主也查出了关于马克丁在软件上私自篡改数字签名的黑历史，并且发帖告诫吧友谨慎下载，谨防个人信息泄露等问题。结果，这篇帖子发了不到一天，又被百度删除了，结果还是马克丁从中作梗，企图掩盖事情的真相。于是无奈，我们把所有结构马克丁恶行的文章，放在了百度站外，希望各位能点击进去看一眼。当然，这还不是猛料，要说马克丁的所作所为，除了私自篡改数字签名、对软件进行修改以外，似乎并没有啥罪大恶极的事情，但是这里，将为大家爆出一段猛料，注意，以下的内容才是真正的猛料！我在搜索马克丁恶行的时候，偶然间发现这样一个网站，这家网站是一个破解小组自发组成的破解网站，里面会更新一些软件的破解版，也是一群破解爱好者自发的组织，不隶属于任何一个团队。然而，在这个网站下面留言区，我却惊奇的发现了马克丁的踪迹。有人说，这里有马克丁有什么稀奇？马克丁不是维权斗士嘛？肯定是来找站长撕逼的没跑，然而这里却要让你们失望了，马克丁居然是来找破解小组谈合作的！究竟是什么样的合作呢？这不禁引起了我挖掘的欲望。通过一些技术手段，我成功的联系上了本站的站长，本站的站长也为我揭秘了马克丁最终的阴谋。以下对话应对方要求不便截图，马克丁也许会站出来否认，信不信大家看看就好，一切的真相就在这里。原来，马克丁希望这个团队可以被收编，希望这个网站可以为他们所用，那么具体如何使用呢？站长是这样解释的：他们希望我们把他们旗下代理的软件的试用版标注成为破解版上传至我们的网站，诱导大众下载马克丁的试用版，最终引流大众到他们的网站上去购买软件，另外他们还希望我们帮他们破解软件的数字签名，把数字签名乃至底层签名更改成他们的数字签名，最后，他们还希望我们去破解他们指定的一些软件，这些软件大多是他们希望代理却被拒绝的软件，以此去威胁这些软件制作人，把软件的代理权给他们。多么险恶的用心，还好这位站长是混迹破解行业多年的老手，心里依然有足够的信念去坚持，他这样说：破解数字签名，无疑是对版权方版权莫大的侵害，我们做破解软件，一是因为爱好，二是共学习所用，我们不收费，不赚钱，不做这种昧良心的勾当。“你知道思杰马克丁是怎么赚钱的么？他们代理软件销售权，篡改软件数字签名的目的为的是不让用户接触到软件真正的官方网站，他们代理的软件官网售价是199美元，和约1400人民币，他们的售价却高达1900元乃至2000元，远超汇率的同时，还拿着高额的代理反水。不让用户接触到真正的官网原因就是这个。通过用破解软件手段的威胁，很多给他代理的软件无法撕破脸皮，但是不少软件厂商已经停止了对思杰马克丁代理的软件的售后服务，换句话说，你从他那里买来的软件，在官网很可能是享受不到售后保障的。不过马克丁并不担心，万一哪家软件不给他代理了，他依然会继续销售，只不过数字签名，秘钥全都换成他自己的，国外起诉也起诉不到这里来，他在国内依然活的逍遥自在。”这位站长向我揭示了马克丁的真实面目，马克丁到底是何许人也，也逐渐完整的浮出水面，盗版巨头？正版大佬？维权斗士？不，这都不是马克丁，马克丁真实的身份只有一个，那就是：行业流氓！为了防止今后被狗咬没了这个帖子，我已经进行加精品处理了，同时，还保存了文档。将来也会一直放置在某个大家能找得到的地方。抵制行业流氓人人有责，希望这场故事会，大家看的开心。推荐阅读：如何评价苏州思杰马克丁软件公司？ —— 知乎8号站被“苏州思杰马克丁 ”在百度搜索付费删收录 删关键词 —— 8号站揭露苏州小叶网络科技有限公司不齿行径&nbsp;—— 知乎专栏思杰马克丁旗下软件真正官网列表、HOSTS ——&nbsp;8号站用事实说话，看清苏州思杰马克丁公司的真实面目 —— Youtube看看大家的评价吧——百度口碑【如何看待思杰马克丁对于盗版疯狂封杀的态度？：https://www.zhihu.com/question/60166627】【思杰马克丁代理软件真正的官网：http://www.carrotchou.blog/3663.html】【苏州思杰马克丁软件有限公司 是个什么鬼？：https://www.v2ex.com/t/334645】【揭露苏州小叶网络科技有限公司不齿行径：https://bbs.kafan.cn/thread-2095728-1-1.html】【[注意！]今天看雪收到苏州思杰马克丁公司的微信投诉？！：https://bbs.pediy.com/thread-221205.htm】【阿刚认怂，今天和大家说说我和小苏那些不得不说的事儿：https://mp.weixin.qq.com/s/8aGEr-cREuyMwS7Ytp-sEw】以下为本文文章的站外链接：（一篇被狗咬可以换另外一篇）揭开行业毒瘤思杰马克丁的虚伪面纱 ——&nbsp;墨雨（知乎原创）揭开行业毒瘤思杰马克丁的虚伪面纱 ——&nbsp;墨雨（绚丽博客转载）揭开行业毒瘤思杰马克丁的虚伪面纱 ——&nbsp;墨雨（心海e站转载）揭开行业毒瘤思杰马克丁的虚伪面纱 ——&nbsp;墨雨（ZAERA转载）揭开行业毒瘤思杰马克丁的虚伪面纱 ——&nbsp;墨雨（ZOL论坛转载）博主感言：国内建站不存在隐私安全。在国内注册商买域名、主机和VPS的，三思。2018年5月：恭喜马克丁喜提Adobe全家桶。业界新企业，左手盗版，右手维权。买下Adobe，就为了让穷学生无学习软件可用。本站所有所谓的“思杰马克丁”的软件都整理到了https://masuit.com/c/6，欢迎下载。",
    "postDate": "2019-01-30T23:40:45.3327577+08:00",
    "email": "admin@masuit.com",
    "label": "思杰马克狗",
    "keyword": "思杰马克狗,思杰马克丁,业界毒瘤,苏州思杰马克丁,流氓公司,盗版商马克丁死全家",
    "id": 1223,
    "indexId": "Post:1223"
  },
  {
    "title": "业界毒瘤思杰马克丁",
    "author": "懒得勤快",
    "content": "转自：http://wemedia.ifeng.com/69244264/wemedia.shtml如果给拖慢电脑运行速度的软件们排个序的话， 非饱受诟病的 Adobe Flash Player 莫属。腾讯视频、哔哩哔哩这些视频网站也已经支持了 HTML5，用我的 MacBook Air 看视频再也不担心电脑发烫了。Adobe 官方也宣布了将在 2020 年停止开发饱受诟病的 Flash Player。你以为有 Flash Player 就够烦的了？1.中国特供版 Adobe并不是，如果中国用户留心一下，你会发现你下载的 Flash Player 跟国外用户不一样。 为了在线看一个视频，本来是要安装 Flash，一不小心就安装了两个捆绑软件，这可是从官网下载的 Flash，Adobe 什么时候学会了某些流氓软件“下载一个送全家”的套路？之所以存在这种捆绑安装的中国特供版 Flash Player，是因为 Adobe 把这个快要消亡的产品的分发权给了一家游戏公司—2144。据好奇心日报报道，中国特供版 Flash 被安装后会强行运行一个 FlashHelperService 的服务，《Helper Service 服务协议》中直接说明了该软件会搜集用户的上网信息。你以为有 FlashHelperService 就够烦的了？并不是。Flash 你可以不用，但是 Adobe 家的生产力软件不能不用啊，比如 Photoshop。不幸的是，Adobe “又作了一回恶”，把 Photoshop 授权给我们今天的主角—思杰马克丁来销售。2.思杰马克丁是谁？通过天眼查，思杰马克丁（CJ Marketing）的全称为“苏州思杰马克丁软件有限公司”，注册时间为 2009 年 12 月，注册资本为 500 万元。其中金勇持股比例为 45.34%，是第一大股东，也是思杰马克丁的创始人。在 2009 年之前，马克丁曾是活跃于破解软件中的名字。在公司成立后，思杰马克丁转型成为正版软件授权经销商，代理的第一款软件是会声会影。天眼查显示，思杰马克丁第二大股东陈俊峰是会声会影创始人兼 CEO。思杰马克丁的软件销售文案代理正版软件，让中国用户养成使用正版软件的习惯这本该是一件好事，而且 Photoshop 每年数千元的高昂定价让很多想支持正版的中国用户望而却步。“哪位大神有 Photoshop 的破解版？”成了百度和各大论坛上关于 Adobe 搜索最多的文字之一。一提起 Adobe 就想到生产力，一想到生产力，最常出现的搜索词就是“破解”。思杰马克丁拿下 Photoshop 在中国的代理权本该是让用户高兴的事，终于有“靠谱”的正版了，结果微博评论的风向很快就变成了“求你们不要再来祸害 Adobe 了”。3.左手盗版，右手正版：思杰马克丁的商业闭环这就不得不说到思杰马克丁代理的第一款软件—会声会影了。从会声会影开始，思杰马克丁就已经形成了自己的一套商业闭环。你想象中的正版软件授权经销商是这样的：收费之后，通过分发渠道把官方授权的软件提供给你下载，赚取一定的服务费和软件开发商提供的分成。而思杰马克丁从一开始就没有走这条“平凡之路”，而是在代理会声会影后改了数字签名。在“如何评价苏州思杰马克丁软件公司？”的知乎话题中，第一个回答详细列举了思杰马克丁篡改会声会影数字签名的证据。在微软 Windows XP 的一次数字签名布丁更新后，由于思杰马克丁对会声会影的数字签名进行了修改，导致了微软认证数字签名发生了错误，软件无法安装。而在思杰马克丁鞭长莫及的其他国家，会声会影并没有出现这样的问题。这样的事情不只发生在会声会影这一款软件身上。比如思杰马克丁曾经代理过的思维导图工具 Xmind 也被篡改过数字签名。改了签名之后，思杰马克丁还名正言顺的加上自己网站的导流链接。这两个链接均是思杰马克丁的引流网站，引导你购买中国特供版 Xmind，并未出现 Xmind 真正的官网www.xmind.net天眼查显示，思杰马克丁还为自己代理的这几款软件都申请了著作权，名字分别是会声会影 X10 视频剪辑软件，思杰马克丁 MindManager 思维导图工具软件，Pargon NTFS for Mac 格式读写软件，CleanMyMac 系统清理软件等，一共有 30 件软件著作权，乍一看还以为这是一家全能的软件开发商。你可能会有疑问了，既然思杰马克丁篡改软件数字签名，软件真正的开发商能同意吗？为什么还要跟思杰马克丁合作？这就体现出思杰马克丁商业闭环的强大之处了，同时握有盗版和正版资源，思杰马克丁可以“黑白通吃”，游刃有余。4.“马仔”和“水军”：思杰马克丁的秘密武器一些合作并不是软件开发商看中了思杰马克丁的软件分发能力，实属无奈之举。如果不合作的话，手握大量盗版网站资源的思杰马克丁分分钟就能放出大量盗版软件。被这种手段“坑”过的一家软件开发商告诉 PingWest品玩，很多软件的代理权都是通过这种“勒索”手段拿到的。作为思杰马克丁的“小弟”，破解网站们除了帮“大佬”勒索开发商，平时也要负责给思杰马克丁网站导流。比如如果有人发帖问：“哪位大神有 Photoshop 的破解版？”回答必定是思杰马克丁的购买跳转链接。当然，这些“小弟”们一开始也不是心甘情愿服从的，思杰马克丁会给他们发来律师函，打着反盗版的名义威胁这些不通话的“小弟”，然后给这些盗版网站返利链接。一套“胡萝卜加大棒”的组合拳打下来，盗版网站们几乎没有不服的。更有意思的是，在思杰马克丁的商业帝国里，类似“水军”的广告推销员也占据了不小的比重。比如你在百度知道搜索会声会影破解版，得到的跳转链接很可能就是“水军”刷出来的。据知乎用户文竹夜泉爆料，思杰马克丁官网专门有个名为网盟的后台，你可以创建广告推广链接，刷到各大网站和论坛后可以拿到一定的提成。5.合作之后依然麻烦不断在思杰马克丁的威逼利诱下，软件开发商屈服了。然而合作并不是麻烦的结束，是麻烦的开始。会声会影、Xmind、MathType、 CleanMyMac 的开发商们需要忍受的不只是修改数字签名，为思杰马克丁网站引流，还需要面对软件体验下降、自家网站在搜索引擎中的排名被思杰马克丁提供的导流网站顶下去。比如同样是 CleanMyMac，我同事早期在思杰马克丁下载的版本就比他后来在开发商官网购买的“流氓”很多。下载这款软件的本意是为了拯救低配 MacBook Air 少的可怜的存储空间，结果下载之后后台常驻，无法完全杀死后台，导致我同事的 MacBook Air 运行速度明显变慢。“买了真正的正版之后，CleanMyMac 的后台进程终于可以完全杀掉了。”而思维导图工具 Xmind 曾将大陆的代理权独家授权给了思杰马克丁，麻烦事就接踵而至。思杰马克丁经常把站点的 Title 和关键词改成“XMind 官网“”或者“XMind中文官网”，授权思杰马克丁代理之后，减少盗版的成效还没看到，在百度搜索 Xmind 排名最靠前的就成了思杰马克丁的导流网站。同样，思杰马克丁的好兄弟—2144旗下的公司手法也如出一辙，在百度搜索关键词“flash”，第三个结果就是：Flash Player 官方下载—Flash 中国官网。而第一个结果，Adobe 产品官网也会根据 IP 地址提示你跳转到中国特供版 Flash 下载页。6 月，“身心俱疲”的 Xmind 终止了与思杰马克丁的合作，思杰马克丁终于露出了他“狰狞的面孔”：暂停合作以后，思杰马克丁先是把 “Xmind官网”改成“Xmind中文官网”，在网站上声称“XMind 暂停销售”，紧接着就用下面一行大字推广另一款竞品“mindmanager”促销优惠，并附上跳转链接。思杰马克丁发给用户的邮件当然，这个时候少不了“小弟”们的出场，思杰马克丁故技重施，很快就在盗版网站发布一些修改过的 XMind 安装包。思杰马克丁真是软件代理商中不折不扣的毒瘤！在百度搜索思杰马克丁网站的时候，我甚至还看到了这样的新闻（通稿）：“2017年9月15日上午，2017江苏版权贸易博览会在南京国际展览中心隆重开幕。其中，国内知名正版软件发行商思杰马克丁参展版博会，该公司旗下独立垂直B2C平台麦软商城在参展过程中受到众多企业的好评与赞赏。”思杰马克丁产品事业部负责人金伟，创始人兼CEO金勇，联合创始人陈俊峰，副总裁李全好像也没什么不对。",
    "postDate": "2019-01-30T23:40:45.332824+08:00",
    "email": "admin@masuit.com",
    "label": "思杰马克丁,思杰马克狗",
    "keyword": "思杰马克丁,思杰马克狗,盗版商,流氓公司,业界毒瘤,Adobe Flash Player马克丁死全家",
    "id": 1248,
    "indexId": "Post:1248"
  },
  {
    "title": "关于：苏州马克丁公司破解、出售 Corel VideoStudio 2018涉嫌违法证据",
    "author": "懒得勤快",
    "content": "转自：http://www.hshyqm.com/thread-15172-1-1.html苏州思杰马克丁软件公司（下简称马克丁）于2018年4月10日开始出售会声会影2018，本人下载、试用后发现此版本为破解的Corel（科尔）公司发布的VideoStudio2018，该行为已涉嫌违法，以下是证据分析，欢迎各大网站转载、转发：Corel VideoStudio 2018官方程序只允许使用下载器和序列号下载安装，马克丁是如何破解绕过下载器的呢？听我详细分析。1.如何实现跳过下载器安装：会声会影2018不允许跳过下载器安装程序，马克丁的试用版是如何做到跳过下载器安装的呢？揭秘：解压马克丁的安装包，会发现有这样两个文件Script -Y.dll和Script.dll，其中Script -Y.dll是官方原始文件，Script.dll是马克丁破解后的文件，破解后就可以跳过下载器直接运行Setup.exe，安装会声会影2018。值得一提的是，该方法抄袭了“喔喔影视制作论坛”版主胡萝卜周（zlzlzlzl）的破解方法，该方法于2018-2-4发布。2.绕过下载器安装，如何正常启动会声会影：会声会影2018不允许绕过下载器安装程序，如果使用其它方法破解安装，则启动时会出现下图所示的乱码提示，马克丁是如何做到启动无提示的呢？揭秘：马克丁首先破解了主程序MWizard.exe和vstudio.ex，并在程序主目录添加了文件aensApi.dll，破解后的主程序vstudio.exe，每次启动时都会同时运行AensApi.dll，AensApi.dll执行将userData.json文件写入到C:\\ProgramData\\Corel\\StubFramework\\VSP\\21文件夹，这样会影就能正常启动了。值得一提的是，通过安装userData.json文件正常启动会影的方法，仍然抄袭了“喔喔影视制作论坛”版主胡萝卜周（zlzlzlzl）的破解方法，只是安装更隐蔽，一般用户很难发现，该方法于2018-2-4发布。主程序vstudio.exe被修改的内容如下：研究发现AensApi.dll文件作者系“苏州小叶网络科技有限公司”，该文件用VC编写。3. 三个破解文件MWizard.exe、vstudio.exe、AensApi.dll是如何安装到会声会影目录的？揭秘：咋看马克丁的安装文件，与原版没有什么区别，仔细研究就会发现，他们修改了官方的安装文件，将以上3个文件分别注入三个.msi文件，做到了悄无声息的破解、安装。4. 马克丁还修改了会声会影2018的启动logo启动过程只要点击就会弹出马克丁公司网页，以达到推广其破解软件的目的（如下图）。揭秘：此推广是修改、替换了安装目录的APLoading.exe文件达到目的的，此文件仍然由“苏州小叶网络科技有限公司”所写。5. 马克丁的破解版会声会影2018存在的问题。马克丁的破解版会声会影2018的版本号是21.0.0.68，而会声会影官方在此版之后又有两次升级，目前升级最新SP2补丁后的版本号为21.2.0.113。经测试，马克丁的破解版会声会影2018升级SP2后，程序启动仍然乱码，无法使用，马克丁如何解决此问题，我们拭目以待！综上所述，苏州马杰思克丁公司伙同“苏州小叶网络科技有限公司”（该公司也许是马杰思克丁公司的下属公司，目前不得而知）破解、出售科尔（Corel）公司VideoStudio2018软件证据确凿，其真实面目昭然若揭，其四处举报、打压民间爱好者的行为可耻之极。欢迎有识之士下载马克丁的会声会影2018破解版软件分析、验证，网站：http://www.huishenghuiying.com.cn/xiazai_all.html32位下载链接：http://xiazai.huishenghuiying.com.cn/trails/huishenghuiying2018_32bit_YY.exe64位下载链接：http://xiazai.huishenghuiying.com.cn/trails/huishenghuiying2018_64bit_YY.exe本说明发布时间2018年4月11日，不排除马克丁公司后期修改安装文件的可能。会声会影正版验证中心：http://www.hshyqm.com/hshy/6.关于马克丁是否有Corel VideoStudio 2018代理权的分析：每每看到有网站发布Corel VideoStudio程序，马克丁法务部都会发律师函，并附一张《著作权证书》，这里说明几点：1.此证书是真是假？欢迎大家人肉、验证。2.证书内容分析：开发完成时间为2013年5月，版本号为V1.0，软件名称为会声会影，权利范围为全部权利，问题就来了：（1）Corel（科尔）公司每年发布的软件名称为VideoStudio，马克丁的是会声会影，分明不是一个软件，马克丁每年发布的都是破解的VideoStudio，并命名为会声会影，说明其代理权不合法，该证书如果真实存在，肯定为骗取。（2）2013年5月，Corel（科尔）公司发布的VideoStudio版号为V16.0，该证书声明的会声会影V1.0，并不是Corel（科尔）公司的VideoStudio。（3）Corel公司已声明：会声会影中国参考价格：899 人民币，会声会影作为业界最优秀的视频编辑软件，深受中国用户喜爱。如今：被马克丁二次修改销售盗版软件！以高昂的价格欺骗国人！（4）权利范围为全部权利，没有Corel（科尔）公司的授权证书，马克丁怎么可能获得全部权利？再次说明，该证书声明的会声会影V1.0，并不是Corel（科尔）公司的VideoStudio。Corel作为世界知名的软件公司，怎么可能让一个出售盗版软件的公司拥有版权？可想而知！（5）软件开发完成时间为2013年5月，马克丁在此时间根本没有开发，更不可能完成会声会影V1.0，再次说明该证书一定骗取的。据了解：该公司一直以修改出售盗版软件！该公司并没有开发软件！所以不具备软件版权！（6）目前还不清楚该类证书的时效是多少年？是否已过期？欢迎大家继续人肉、验证。综上所述，马克丁公司不具有Corel VideoStudio 2018的代理权，其通过不正当手段骗取的《著作权证书》不合法，其破解出售CorelVideoStudio 2018的行为已涉嫌违法。",
    "postDate": "2019-01-30T23:40:45.3328881+08:00",
    "email": "admin@masuit.com",
    "label": "思杰马克丁,思杰马克狗",
    "keyword": "思杰马克丁,盗版商,流氓公司,诈骗,盗版证据马克丁死全家",
    "id": 1247,
    "indexId": "Post:1247"
  },
  {
    "title": "Adobe Flash 中国特供版幕后黑手曝光原来是思杰马克丁",
    "author": "懒得勤快",
    "content": "相信已经有不少人发现，不知从什么时候起，国内的Adobe Flash Player的官方下载网站和安装包都变成了“中国特供”。一般来说，“特供”都意味着更好，但这次却相反。据悉，特供版Adobe Flash Player在安装后会强制FlashHelperService服务，而该服务的作用是搜集用户隐私，更糟的是你无法结束这个进程服务。在Adobe的用户协议中也写到，Flash Player使用过程中重橙网络可能会搜集用户的上网信息，并可以在合理范围内将信息披露给第三方，如果用户隐私数据安全受到威胁也不用承担责任。消息一经曝光就遭到了网上的一致口诛笔伐，如此恶劣的霸王条款竟然出现在了一家全球知名公司的用户协议中，实在让人愤慨。1、在协议中反复提到的“重橙网络”正是Adobe Flash Player国内特供版的提供商，原来这一切并非是“洋人亡我之心不死”，而是“中国人坑起中国人比谁都狠”。在事情败露之后，重橙网络紧急修改了用户协议，改为“在不涉及侵犯用户个人隐私的前提下， 程序可能会记录用户如何使用本程序的信息和用户使用本程序的相关数据”，但这时已经很难再取得用户的信任了。事件发展到这里，我们想聊一聊这个在中国软件服务市场一直存在的问题了，那就是为什么一个好的产品到了国内以后经常会变得“邪恶”起来。2、这可能牵扯到代理公司的问题。Adobe公司在一个多月前与中国软件代理商思杰马克丁签署合作协议，而这家代理商在国内可以说是臭名昭著。为什么这样一家名声奇臭的公司却能和Adobe合作？只能够说中国的正版软件发行市场非常不完善，这就不是一个正常的市场。事实上，在进入网络时代之后，很多软件都放弃传统的分销体系转而去做互联网分发了，因为这在中国根本做不起来，而仍然有这部分需求的厂商也只能在这个市场中去找仅存的代理商，那这中间就不免接触到像思杰马克丁这样的代理商。现在我们面临的真正问题在于，海外的软件公司因为政策的原因，要想在国内推行服务只能通过与国内的公司合作，比如之前苹果的iCloud也必须由国内的公司代理运作。自己进不来，原本自己的那一套体验保障就无法复制，最终结果如何只能看代理公司的“良心”。3、但在国内这块市场还没有完全发展起来，代理公司良莠不齐且缺乏监管，甚至无法无天的随意篡改，这服务还怎么可能不变味呢？所以我们的政策做出来了，请也同时加强相应的监管来保障消费者的基本权益。最后那些海外原公司有没有责任呢？当然也有。这些公司在找到代理公司之后就几乎只做甩手掌柜，全然不管自己的服务在中国变成了什么样，对中国的消费者极其不负责任，甚至“助纣为虐”。在这次的事件中，我们从用户协议中发现Adobe是完全知道窃取用户隐私这件事的，但却没有阻止，只是在协议中将自己的责任摘得一干二净。4、在原公司冷漠、代理公司作恶、政策监管不到位的三重作用下，中国的消费者显得是那么的无助，完全就是任人宰割，这样的市场注定不会长久。今后还会有越来越多的海外公司在中国推出软件服务，如果都像这样来运作，那还是请赶紧圆润地离开吧，中国的消费者不需要这种不负责任厂商。最后请有关部门能够肃清些作恶多端的代理商，还消费者一个正常的市场，不用再担心自己的隐私被恶人践踏。5、中国特供版Adobe Flash&nbsp;幕后黑手思杰马克丁！并不是。如果中国用户留心一下，你会发现你下载的Flash Player跟国外用户不一样。为了在线看一个视频，本来是要安装Flash，一不小心就安装了两个捆绑软件，这可是从官网下载的Flash——Adobe什么时候学会了某些流氓软件“下载一个送全家”的套路？之所以存在这种捆绑安装的中国特供版Flash Player，是因为Adobe把这个快要消亡的产品的分发权给了一家游戏公司—2144。中国特供版Flash被安装后会强行运行一个FlashHelperService的服务，《HelperService服务协议》中直接说明了该软件会搜集用户的上网信息。6、思杰马克丁是谁？通过天眼查，思杰马克丁（CJ Marketing）的全称为“苏州思杰马克丁软件有限公司”，注册时间为2009年12月，注册资本为500万元。其中金勇持股比例为45.34%，是第一大股东，也是思杰马克丁的创始人。在2009年之前，马克丁曾是活跃于破解软件中的名字。在公司成立后，思杰马克丁转型成为正版软件授权经销商，代理的第一款软件是会声会影。天眼查显示，思杰马克丁第二大股东陈俊峰是会声会影创始人兼CEO。7、左手盗版，右手正版：思杰马克丁的商业闭环这就不得不说到思杰马克丁代理的第款软件—会声会影了。从会声会影开始，思杰马克丁就已经形成了自己的一套商业闭环。你想象中的正版软件授权经销商是这样的：收费之后，通过分发渠道把官方授权的软件提供给你下载，赚取一定的服务费和软件开发商提供的分成。而思杰马克丁从一开始就没有走这条“平凡之路”，而是在代理会声会影后改了数字签名。在“如何评价苏州思杰马克丁软件公司？”的知乎话题中，第一个回答详细列举了思杰马克丁篡改会声会影数字签名的证据。在微软Windows XP的一次数字签名布丁更新后，由于思杰马克丁对会声会影的数字签名进行了修改，导致了微软认证数字签名发生了错误，软件无法安装。而在思杰马克丁鞭长莫及的其他国家，会声会影并没有出现这样的问题。这样的事情不只发生在会声会影这一款软件身上，比如思杰马克丁曾经代理过的思维导图工具Xmind也被篡改过数字签名。改了签名之后，思杰马克丁还名正言顺地加上自己网站的导流链接。天眼查显示，思杰马克丁还为自己代理的这几款软件都申请了著作权，名字分别是会声会影X10视频剪辑软件，思杰马克丁MindManager思维导图工具软件，PargonNTFSforMac格式读写软件，CleanMyMac系统清理软件等，一共有30件软件著作权，乍一看还以为这是一家全能的软件开发商。你可能会有疑问了，既然思杰马克丁篡改软件数字签名，软件真正的开发商能同意吗？为什么还要跟思杰马克丁合作？这就体现出思杰马克丁商业闭环的强大之处了，同时握有盗版和正版资源，思杰马克丁可以“黑白通吃”，游刃有余。8、“马仔”和“水军”：思杰马克丁的秘密武器一些合作并不是软件开发商看中了思杰马克丁的软件分发能力，实属无奈之举。如果不合作的话，手握大量盗版网站资源的思杰马克丁分分钟就能放出大量盗版软件。被这种手段“坑”过的一家软件开发商透露，很多软件的代理权都是通过这种“勒索”手段拿到的。作为思杰马克丁的“小弟”，破解网站们除了帮“大佬”勒索开发商，平时也要负责给思杰马克丁网站导流。比如如果有人发帖问：“哪位大神有Photoshop的破解版？”回答必定是思杰马克丁的购买跳转链接。当然，这些“小弟”们一开始也不是心甘情愿服从的，思杰马克丁会给他们发来律师函，打着反盗版的名义威胁这些不通话的“小弟”，然后给这些盗版网站返利链接。一套“胡萝卜加大棒”的组合拳打下来，盗版网站们几乎没有不服的。更有意思的是，在思杰马克丁的商业帝国里，类似“水军”的广告推销员也占据了不小的比重，比如你在百度知道搜索会声会影破解版，得到的跳转链接很可能就是“水军”刷出来的。9、合作之后依然麻烦不断在思杰马克丁的威逼利诱下，软件开发商屈服了，然而合作并不是麻烦的结束，是麻烦的开始。会声会影、Xmind、MathType、CleanMyMac的开发商们需要忍受的不只是修改数字签名，为思杰马克丁网站引流，还需要面对软件体验下降、自家网站在搜索引擎中的排名被思杰马克丁提供的导流网站顶下去。比如同样是CleanMyMac，我同事早期在思杰马克丁下载的版本就比他后来在开发商官网购买的“流氓”很多。下载这款软件的本意是为了拯救低配MacBookAir少的可怜的存储空间，结果下载之后后台常驻，无法完全杀死后台，导致我同事的MacBookAir运行速度明显变慢。“买了真正的正版之后，CleanMyMac的后台进程终于可以完全杀掉了。”而思维导图工具Xmind曾将大陆的代理权独家授权给了思杰马克丁，麻烦事就接踵而至。思杰马克丁经常把站点的Title和关键词改成“XMind官网“”或者“XMind中文官网”，授权思杰马克丁代理之后，减少盗版的成效还没看到，在百度搜索Xmind排名最靠前的就成了思杰马克丁的导流网站。同样，思杰马克丁的好兄弟—2144旗下的公司手法也如出一辙，在百度搜索关键词“Flash”，第三个结果就是：Flash Player官方下载—Flash中国官网，而第一个结果，Adobe产品官网也会根据IP地址提示你跳转到中国特供版Flash下载页。6月，“身心俱疲”的Xmind终止了与思杰马克丁的合作，思杰马克丁终于露出了他“狰狞的面孔”暂停合作以后，思杰马克丁先是把“Xmind官网”改成“Xmind中文官网”，在网站上声称“XMind暂停销售”，紧接着就用下面一行大字推广另一款竞品“mindmanager”促销优惠，并附上跳转链接。免责声明：本站部分文章和信息来源于国际互联网，本站转载出于传递更多信息和学习目的，并不意味着赞同其观点或证实其内容的真实性，并且无损害任何公司的行为更不涉及侵权。",
    "postDate": "2019-01-30T23:40:45.3329525+08:00",
    "email": "admin@masuit.com",
    "label": "思杰马克丁,思杰马克狗",
    "keyword": "Adobe,flash,flash player,Adobe Flash 中国特供版,思杰马克丁,思杰马克狗,业界毒瘤,流氓公司,盗版商马克丁死全家",
    "id": 1241,
    "indexId": "Post:1241"
  },
  {
    "title": "思杰马克丁软件微博运营博主，独自舌战群雄不落下风！",
    "author": "懒得勤快",
    "content": "思杰马克丁软件官方新浪微博一个从2017年08月17日才开通的微博广泛受到关注，看了一下该微博粉丝关注程度&nbsp;237这个在国内有名的大公司，以和谐能力一流，维权能力一流，钓鱼执法一流，投诉举报一流，的大公司为什么落魄到微博只有237个人，这些我们就不得而知了，总有他们自己的理由。为什么这个一个公司粉丝这么少的情况下确引起了公众广大的关注，让一个只有237个粉丝的微博在5月18日截止到发帖时间的一个帖子评论度高达309条，是什么、是爱吗！是责任吗！不不不，这些都不是，因为思杰马克丁软件官方新浪微博在2018年5月18日发布了一个博文“思杰马克丁签约代理 Adobe 软件成（江苏省）授权经销商”引起了社会广大反响，很多人（基本大多数都是吐槽）都来该公司微博表达自己的观点。下面给大家发几个关于大家表达了什么观点的截图，观摩 观摩微博@壹心逸士：祝贺思杰马克丁获得ADOBE的代理权，希望思杰马克丁能代理到更多的软件，尤其是Windows和office，然后把安装包的签名和版本号都改成思杰马克丁的，购买的软件序列号都只能用于激活思杰马克丁专门定制的国内版，把国内所有网站上的破解版链接全部换成思杰马克丁的试用版下载链接。微博@燈龍琉璃：哦对了，还有吐槽价格的实锤,会声会影 Pro 2018 官网标价是$54.99大概是RMB350多，而这家代理则是¥548 大家心理有数了吧。 www.videostudiopro.com 这是真正的官网，另外官网旗舰版VideoStudio Ultimate 2018 现价$89.99折合RMB约574，用别人的旗舰版价格卖专业版，你很棒棒哦。微博@思杰马克丁软件：回复微博@燈龍琉璃：去查查会声会影的官方，中国指导售价是899啊微博@ljsQAQ：祝早日倒闭微博@思杰马克丁软件：回复微博@ljsQAQ：公司自从十年前成立以来，始终坚持正版软件的国内发行工作，规模达到了上百倍的增幅，目前是政府认证的高新技术企业和知识产权保护先进企业，您的这个愿望我们可能不会满足，谢谢。微博@知七zZZ：这里有马克丁有什么稀奇？马克丁不是维权斗士嘛？肯定是来找站长撕逼的没跑，然而这里却要让你们失望了，马克丁居然是来找破解小组谈合作微博@思杰马克丁软件：回复微博@知七zZZ：这不很正常么，找破解小组合作是因为他们发布破解资源，我们希望他们能把破解资源换成正版资源，有什么问题吗？你是不是对商业有什么误解，你的意思是我们应该去堵这些破解小组的门，把他们活活打死才是我们应该做的是吗？微博@华庭仔仔：将法律知识运用到炉火纯青的地步，然而卖的终究不是法律。用户不买账可能是用户的问题，大多数用户不买账，就算是”用户的问题”那也是你们的问题了。所以即使能回复每一条评论并“反喷”，也就是让旁人合不拢嘴。增加生活的一点小乐趣。微博@思杰马克丁软件：回复微博@华庭仔仔：第一，大多数用户是买账的，不买账的只是一小部分的人，要不然业务稳步增长是做不到的。不要觉得你就是这个世界，你也不能代表大多数人。第二，反喷这些无脑言论，是我这两天的最大乐趣。微博@隔壁王老五哒：那麼牛X的法務部門沒本事刪除知乎的黑帖？那麼牛X的開發團隊沒本事篡改徹底？你們也就在中國蹦跶蹦跶，所謂的美國分部只是個笑話。微博@思杰马克丁软件：回复微博@隔壁王老五哒：您这话说的，好像删知乎就很牛了一样。黑帖估计说的这个：如何评价苏州思杰马克丁软件公司？微博@领会LVENT：很是佩服马克丁公司的微博运营博主，能够舌战群雄。作为设计小白，只能深感设计的成本越来越高了。广大甲方，你们知不知道设计师的每一次点击都是有成本哒。微博@华庭仔仔：回复@高建的微博:哈哈，这叫营销策略。他们最拿手的。微博@思杰马克丁软件：回复@高建的微博:首先这个我并没有觉得多自豪[允悲]公司还不足以称之为一家大公司，那个官网的字样不是百度给的，是corel授权的，还有我说明下，原来会声会影厂商给中国的国内定价是899，现在的价格是我们去谈下来的，已经尽力了，奈何还有人黑。微博@高建的微博：不如听听我们这些所谓的”喷子”的建议，改进一下服务体验，让我们知道花钱到底是花到哪去了，百度标志中国区代理官网，内置说明尊重下原作者就别跳到你们那了，资费只要不比原版贵，，从代理这买还能让中国企业赚钱，大家也买的开心啊。微博@高建的微博：回复 @思杰马克丁软件:第三点，你们的官网下的程序真的跟原版有不一样，你真的不是大自然的搬运工，不知道你媒体运营的具体对公司负责程序的有过沟通嘛。微博@高建的微博：回复 @思杰马克丁软件:只有第二点表示理解，但也是标注官网跳到马克丁的购买网站，第一点，虽然贵司很大我知道，不用非要强调自豪感的，不如说下贵司很大我很有责任感之类的等。况且百度也不傻啊，你自己搜搜看，你们为代理软件专门做的”购买”网站是不是醒目标注官网。微博@思杰马克丁软件：回复@高建的微博:我们是努力在为客户提供一个更好的服务，但是对于送上门来的喷子我觉得也没必要客气。微博@思杰马克丁软件：回复@高建的微博:我真是好奇，你们为什么老是嚷嚷要一个解释，有些是商业机密，有些是营销方式，都不是能公开对外的公司内部信息，而且我们曾经做过解释，但是总有人捂着耳朵大叫我不听我不听你们就是坏，那我们还解释什么呢？这样，如果真要解释，去考公务员版权局，然后来要解释，保证应有尽有，好吗。微博@高建的微博：回复 @思杰马克丁软件:花钱让你做新媒体运营不是来发泄戾气，作为一个二道贩子，你不想想办法怎么样让服务更好嘛，客户买的安心嘛。微博@高建的微博：回复 @思杰马克丁软件:别转移话题，那去解释一下其他的吧，老是删有什么用。思杰马克丁软件：回复@高建的微博:哦，可能您家里平时最喜欢把垃圾搜集起来堆在家里发酵变味儿来证明自己堂堂正正吧，抱歉我是正常人，看到垃圾一般都会请扫一下，反正也不费事儿不是么。微博@高建的微博：他删了好多评论，故意留下来上来就骂他好让人觉得都是些喷子。不说了，一个官方认证的微博素质极高可以想象这个公司是什么样子的，网络上的传言都不是空穴来风啊哈哈，如果大家又兴趣自行去微博观摩哦。免责及版权声明：本站部分文章和信息来源于国际互联网，本站转载出于传递更多信息和学习目的，以上为博主在微博进行抄录所得，并且无损害任何公司的行为更不涉及侵权（截图中是该公司带V的微博认证吧）。最后欢迎转载此文章，截图都未打水印方便转载，大家怎么看、也欢迎讨论交流！！",
    "postDate": "2019-01-30T23:40:45.3330155+08:00",
    "email": "admin@masuit.com",
    "label": "思杰马克丁,思杰马克狗",
    "keyword": "思杰马克丁,思杰马克狗,业界毒瘤,流氓公司,盗版商马克丁死全家",
    "id": 1215,
    "indexId": "Post:1215"
  },
  {
    "title": "Parallels Desktop Mac 公司取消思杰马克丁国内代理权",
    "author": "懒得勤快",
    "content": "Parallels Desktop Mac 是是一款专业的Mac虚拟机，可在Windows 与Mac OS 应用程序之间随意拖放文件并直接从Mac dock 启动Windows 程序，能够在Mac上以最便捷、快速、高效的方式运行 Windows 10/ Windows 8/ Windows 7 等等微软的系统，Parallels Desktop 在Mac运行流畅在国外是一款很畅销的Mac虚拟机软件。Parallels Desktop for Mac 是功能最强大灵活度最高的虚拟化方案，无需重启即可在同一台电脑上随时访问Windows和Mac两个系统上的众多应用程序。从仅限于PC的游戏到生产力软件，Parallels Desktop都能帮您实现便捷使用。最新的 Parallels Desktop 12 针对 OS XEl Capitan和 Windows 8.1/10 进行了特别优化，而且也新增了大量新特性，譬如完美支持了 Retina Macbook Pro 的视网膜屏幕，直接调用IE浏览器打开网页、蓝牙共享、支持USB 3.0、改进了3D游戏/图形性能等等。今天突然发现了Parallels Desktop Mac 虚拟机官方Parallels Desktop Mac 已经取消了苏州思杰马克丁代理权，之前在百度搜索“Parallels Desktop Mac”百度第一位就是“国内代理商”所代理而开发的一个假中文官网“www.parallelsdesktop.cn”已经打不开了，其实这个只是该“国内代理商”为了垄断用户跟百度做了PY交易的官网，真正的官网是这个“www.parallels.com/cn/”我们看一看国内代理商Parallels官方授权店介绍：Parallels官方授权店隶属于苏州思杰马克丁软件有限公司(简称思杰马克丁软件)，思杰马克丁是一家专业的软件发行商。目前获得多家公司授权，代理发行了几十种市场热门软件，如会声会影、CorelDRAW、UltraISO（软碟通）、ABBYY、MindManager、XMind、Parallels Desktop、CleanMyMac3和NTFS For Mac等。Parallels创立于2000年，是连续9年销量第一的Mac桌面虚拟化软件。点评：Parallels Desktop Mac 取消该公司在国内的代理权也是必然的，而且连做的国内中文官网www.parallelsdesktop.cn 都已经无法打开，不知道是不是国外Parallels公司发现了代理商把软件进行修改屏蔽真正的官网而被取消代理权，并且连国内中文官网也被关闭，这些不得而知。既然取消了代理权那当然是给大家分享最新版本的Mac虚拟机：Parallels Desktop 中文直装破解版免责声明：本站部分文章和信息来源于国际互联网，本站转载出于传递更多信息和学习目的，并不意味着赞同其观点或证实其内容的真实性，并且无损害任何公司的行为更不涉及侵权。",
    "postDate": "2019-01-30T23:40:45.3330872+08:00",
    "email": "admin@masuit.com",
    "label": "思杰马克丁,思杰马克狗",
    "keyword": "Parallels,思杰马克丁,思杰马克狗,业界毒瘤,流氓公司,盗版商马克丁死全家",
    "id": 1233,
    "indexId": "Post:1233"
  },
  {
    "title": "流氓的版权，版权的流氓",
    "author": "懒得勤快",
    "content": "版权，或者说知识产权，是一个很常见的zbzy概念。其支持者最常用的说辞是：“没有版权，那么原作者就得不到足够的收入以维持创作动力！”听起来，似乎是有几分道理。但是，现行版权法律是保护原作者的吗？版权真的是为了原作者的利益服务的吗？事实上，绝大多数版权都并不被原作者所掌握，而是被雇佣（奴役）原作者的公司老板们所掌握，例如游戏迷们非常熟悉的合金装备系列，其版权就被KONAMI公司的老板们而不是被系列原核心作者小岛秀夫所掌握，而小岛秀夫被KONAMI踢走，然后KONAMI找了其他一些人做了个垃圾作品：合金装备生存，至于死在EA手下的被收购工作室都不知有多少了，而这些工作室虽然死了，但其作品版权却被EA霸占，也就是说EA的老板们可以出大批顶着作品名号的垃圾骗钱了。更不要说在原作者死后，版权还持续，公司们还拿着死人的作品卖钱，请问，按照版权吹鼓手们的逻辑，这时候不该用冥币付钱吗？否则你怎么能保证原作者收到钱呢？严格来说，没有完全原创的知识，因为所有知识都是在别人的免费知识的基础上创造出来的，当然有人说即使如此原创者也花费了时间精力应当收费，但收费有理可不等于垄断有理，没有人有权垄断知识，把知识隔绝在金钱柏林墙外，理由很简单：一个人垄断了知识，其他人要么不得不重新发明轮子，浪费资源降低效率（那些最喜欢鼓吹效率的，这时候通常会闭嘴），要么其他人也学着垄断知识，结果就是整个人类社会分裂为一个个知识孤岛，最终除了少数垄断者之外，其他绝大部分人都深受其害！受害？是的，这世界上的版权流氓们可不少，我举两个例子说明一下：1，超级版权流氓苏州思杰马克丁公司：“为什么微软更新了数字签名补丁，中国地区的会声会影就无法使用了，而其他地区的会声会影却能不受影响？答案显而易见，原来，马克丁公司对会声会影的数字签名进行了修改，嵌入了自己公司的数字签名，把软件安装完成后指向的官方地址修改成了自己做的“官方网站”，同时还对里面诸多版权信息等签名信息完完全全修改成了自己的信息。至于是否还加入了其他后门程序，我们就不得而知了，但是可以确定的是，这次补丁，完善了数字签名认证系统，马克丁对数字签名进行了修改，直接导致了微软认证数字签名发生了错误，所以软件无法安装。而这个问题，直到下一个版本更新后，才得到了解决。随之而来的，是更多的数字签名事件，在马克丁旗下代理的所有软件中，均发现了数字签名被篡改的情况，这也不由得引人深思，你丫是谁你就把这软件签上你自己的名字？还要不要点碧莲？马克丁再次以维权斗士的形象站了起来，马克丁的律师团队如明朝时候的锦衣卫，哪里有软件哪里就有他们，马克丁到处招蜂引蝶，拳打南山敬老院，脚踢北海幼儿园，抓shi如泥，大街有人谁怕他，大街无人他怕谁？总之，虽然引得骂声一片，但是充分体现了自己维权斗士的形象，还雇佣大批水军，企图淹没对其讨伐的声音。然而，他对数字签名更改的同时除了侵犯到软件制作方的著作权以外，还同时已经侵犯到了软件使用者的各种权益，由于中国只对版权法律有明确的规定，在关于数字签名的法律问题上并没有完善的法律条款，而马克丁的这种做法，实质上在国外已属违法行为。一个侵犯着制作方与使用方双方权利的人站起来维权？这种做法难道不是贼喊捉贼？““你知道思杰马克丁是怎么赚钱的么？他们代理软件销售权，篡改软件数字签名的目的为的是不让用户接触到软件真正的官方网站，他们代理的软件官网售价是199美元，和约1400人民币，他们的售价却高达1900元乃至2000元，远超汇率的同时，还拿着高额的代理反水。不让用户接触到真正的官网原因就是这个。通过用破解软件手段的威胁，很多给他代理的软件无法撕破脸皮，但是不少软件厂商已经停止了对思杰马克丁代理的软件的售后服务，换句话说，你从他那里买来的软件，在官网很可能是享受不到售后保障的。不过马克丁并不担心，万一哪家软件不给他代理了，他依然会继续销售，只不过数字签名，秘钥全都换成他自己的，国外起诉也起诉不到这里来，他在国内依然活的逍遥自在。”来源：www.carrotchou.blog/3572.html”因为我在贴吧、博客、Q群上发布Deep Freeze相关资源，思杰马克丁在无任何代理权、版权的情况下，他的法务部给我发来维权通知，而且邮件内容还发错了，竟然说成Zbrush软件。上mathtype的英文官网&nbsp;MathType – Equation Editor下载mathtype，是可以输入序列号的(用google或bing找序列号)。英文官网的售价是：商版$97(97×6.6=￥640.2)，教育版$57(57×6.6=￥376.2)，而思杰马克丁卖的价格是：商业版￥788(原价￥1088)，另一个不确定是不是教育版卖￥498(原价￥688)。由于我已经安装了不便截图了，大家可以打开链接自己体验一下，英文官网安装包安装可以选择30天试用或是输入激活码，而“正版授权”的中文版则是强制只能试用，而且强制勾选同意软件收集信息，这不是流氓软件的标志吗！真正的正版会这么做？所以这家公司的实质其实是盗版软件的垄断者，采用流氓的方式（律师函、举报、假盗版链接）迫使或欺骗用户使用收费的盗版软件。无奈国内的很多热门软件被他血洗了，若想用正版请务必使用开发商的购买渠道，千万别上当受骗。“来源：https://www.zhihu.com/question/46746200”发布一款mounty这款软件被疯狂举报，这款软件本身是免费的，用于ntfs格式的硬盘写入的，难道就因为这款软件免费，影响他们的销量了吗？“来源：https://www.zhihu.com/question/60166627这里还有个视频链接：用事实说话，看清苏州思杰马克丁公司的真实面目(需翻墙)总结一下，这家流氓公司通过欺骗和破解威胁骗取代理权（事实上还有大批所谓被其代理的软件根本没有授权），然后篡改软件本身，不让用户看到软件的真正作者和官网，目的就是为了高价欺诈用户购买其”正版“（篡改数字签名属于破解行为，所以这所谓的正版实际上和破解版无异，当然这是从技术角度说的，从法律角度，这垃圾的所谓正版还真是正版），对于敢发布其他软件获取渠道者一律进行恶意举报和威胁，而且这些流氓行径还是合法的！对，合狗屁版权法！2，为防盗版不择手段的starforce防copy软件（默认状态下的软件是能自由copy的，这也是使用者的基本权利，但是老板们为了利益最大化，就搞出防copy软件这种用来搭建柏林墙的垃圾）：“1998年，俄罗斯的程序员开发了这一软件加密程序，针对当时市面上多数游戏采用光盘作为载体，starforce通过测量CD中第一个和最后一个写入扇区之间的物理角度来工作。遗憾的是，starforce采用的加密方式，会使用Ring0级别权限（系统层），此后除非将硬盘格式化，否则即便是卸载了starforce软件，但是对系统设置的改变却不会撤销。这就让starforce取得了硬件的最高权限，只要玩家的电脑开着，就被随时、永远、监控着。一旦starforce发现你的计算机有可疑行为，不管你是不是在玩游戏，它会强制计算机重启，打断可疑的程序进程。此外，由于要频繁读取光盘，对于光盘和光驱的伤害是所有玩家最直接感受到的。最可怕的是，当starforce程序的运作发生错误时，会将电脑完整诊断信息传送给starforce公司，资料多达3千7百多行，这其中包括了私人信息。有鉴于此，starforce在国外被当成了一个流氓工具，长期出于舆论的风口浪尖，在美国还被法院判决禁止使用。”Starforce 要求安装后重新启动，它要对你的计算机进行最高级别的控制，当然需要这样做。为了取得最高权限，大部分杀毒软件都会要求重启，但目的与SF有所不同如果做了系统的 Ghost光盘，事后格掉重做系统就行了，就当一切都没有发生过。不过，如果它窃取了你的个人信息，并传出去，就不是能轻易挽回的了。好像一个人在大街上被人扒光了衣服，春光外泄之后穿好衣物就能当没事一样么（SF并不会将这些信息与你本人相关联）？Starforce 在验证失败后点击“信息”会收集系统信息送至SF公司进行分析，在获取信息的过程中过程中硬盘狂转，看来读取了不少信息，来看看它都干了些什么。在报错后生成了信息文件，我把这个文件保存下来，这是个将要发送给Protection Technology的文件。真是不看不知道，一看吓一跳。这个文本文件竟有 288,214 字节，3467 行之多，详细记录了系统的全部信息。文件首先记录了系统的详细信息，包括 Windows序列号、安装位置、用户名称、常规设置信息等等。然后是硬件信息，包括所有的硬件设备的资源信息、运行状况、驱动的全部详细信息等等，网络信息，包括 IP 地址、MAC 地址、全部使用协议资料等等，随后是硬盘的信息，包括所有分区的设置和使用状况、分区起始字节等等，接着是光驱和外设的全部信息，全部的驱动信息、动态链接库、所有进程的详细信息、所安装全部软件的信息…….总之，这些个人隐私，只有你想不到的，没有它不窃取的。不知道这个流氓软件有没有把我的资料外泄，还好，使用该光盘的时候我在断网状态，随后 Ghost 恢复了系统。估计 Starforce 可以打着验证正版的幌子为自己辩护，但我很想知道，窃取用户的全部个人资料，就是为了验证光盘是否正版？我安装了哪些应用软件你也需要全部知道么？我安装了些什么游戏你也这么感兴趣？我的IP地址对验证光盘正版也有用？流氓就是流氓，无论批什么外衣，本质都是流氓。来源：&nbsp;为了正义不则手段的防盗版软件这两个臭流氓不过是流氓世界的冰山一角，关于商业软件的流氓事迹，可以看一下自由软件协会提供的信息：Proprietary Software Is Often Malware（商业软件经常是恶意软件）关于自由软件运动，我要介绍一下：自由软件运动的创始人是Richard Stallman，自由软件运动致力于通过自由软件使计算机用户获得自由权利。自由软件的用户可以自主控制自己的计算。非自由软件使用户受制于软件开发者。自由软件意味着使用者有运行、复制、发布、研究、修改和改进该软件的自由。自由软件是权利问题，不是价格问题。要理解这个概念，你应该考虑“自由”是“言论自由”中的“自由”；而不是“免费啤酒”中的“免费”。更精确地说，自由软件赋予软件使用者四项基本自由：不论目的为何，有运行该软件的自由（自由之零）。有研究该软件如何运行，以及按需改写该软件的自由（自由之一）。取得该软件源代码为达成此目的之前提。有重新发布拷贝的自由，这样你可以借此来敦亲睦邻（自由之二）。有改进该软件，以及向公众发布改进的自由，这样整个社群都可受惠（自由之三）。取得该软件源码为达成此目的之前提。来源：GNU是什么？为了对抗版权（copyright），Stallman发明了Copyleft（拒绝版权）：一个人所做的每个决定都源自这个人的价值观和目标。人们有很多不同的价值观和目标；名誉、利益、爱情、生存、快乐和自由，这些只是常人会有的部分目标。当目标是原则性问题的时候，我们称之为理想主义。一个理想主义的目标激励着我从事自由软件的工作：弘扬自由和合作。我要鼓励自由软件的转播，让它替代禁止合作的专属软件，从而使我们的社会变得更好。这就是为什么GNU通用公共许可证按照—copyleft那样写的基本原因。所有为遵循GPL的程序而添加的代码都必须是自由软件，即使这些代码是单独的文件。我把我的代码给自由软件使用，而不给专属软件使用。我认为专属软件开发者使用版权来禁止我们分享，那么我们就使用版权来给予互相合作的程序员自己的优势：他们可以使用我们的代码。如果嘲笑者挖苦自由、讽刺社区…如果“顽固的现实主义者”说利益是唯一的理想…只需忽略他们，并一如既往地使用copyleft。来源：Copyleft：实用的理想主义可以看到，自由软件运动实际上就是软件界的****运动（digital communism），软件的代码，运行软件的权利，分发的权利，二次修改的权利，这些都公平的为所有人所共有，而利润至上捞钱第一不管其他任何后果的商业软件是无法做到赋予软件使用者这些基本人权的，事实上，商业软件还经常盗窃用户隐私，强行塞给用户洗脑广告，拿着用户的隐私去掠取巨额利润（例如FB的精准推广）但用户却毫不知情更分不到一分钱，活生生的把用户们变成了数字奴工（digital labor）！而这无法通过更换其他商业软件解决，因为商业软件为了逐利必然会伤害用户以实现利润最大化！为了贪欲去伤害别人的人，很多很多，但幸运的是，这世界不是所有人都像思杰马克丁和starforce一样去当”精致的利己主义者“的，像Stallman（顺便说一句，Stallman是个非信神者）这样的为了一个把人当成人而不是商品的社会而战斗的人们，都是英雄！PS：最近我无意中看到了一篇无耻的文章，为什么说无耻，因为这无耻的作者把自由软件当成”市场提供的福利“（原文翻不到了，诸位可自行用google查找，文章主题是引号中内容），请允许我说一声：呸！（转载哔哩哔哩：https://www.bilibili.com/read/cv390271）",
    "postDate": "2019-01-30T23:40:45.3331511+08:00",
    "email": "admin@masuit.com",
    "label": "思杰马克丁,思杰马克狗",
    "keyword": "思杰马克丁,业界毒瘤,苏州思杰马克丁,流氓公司,盗版商马克丁死全家,思杰马克狗",
    "id": 1252,
    "indexId": "Post:1252"
  },
  {
    "title": "思杰马克丁CJmakeding，盗版一哥与毒瘤一生",
    "author": "懒得勤快",
    "content": "知乎有一条著名的提问：如何评价苏州思杰马克丁软件公司？感谢以下新闻媒体提供内容：凤凰网科技、搜狐网、知乎、PingWest、品玩、豆瓣、百度、搜狗、Bing、360搜索、威锋网、52pojie、v2ex、cnprint、天眼查、新浪科技、IT之家、卡饭、职友集、PCbeta、微博、百度口碑、看准网、今日头条、微信公众号、360doc国内用户在使用正版软件的道路上困难重重，其中最大的阻碍就来自于思杰马克丁。通过天眼查，思杰马克丁（CJ Marketing）的全称为“苏州思杰马克丁软件有限公司”，注册时间为 2009 年 12 月，注册资本为 500 万元。其中金勇持股比例为 45.34%，是第一大股东，也是思杰马克丁的创始人。在 2009 年之前，马克丁曾是活跃于破解盗版软件中的名字。在公司成立后，思杰马克丁转型成为正版软件授权经销商，代理的第一款软件是会声会影。天眼查显示，思杰马克丁第二大股东陈俊峰是会声会影创始人兼 CEO。这个在国内名声扫地的软件商，就连谷歌评论都是一颗星，可谓是盗版软件界的先驱。如果给拖慢电脑运行速度的软件们排个序的话， 非饱受诟病的 Adobe Flash Player 莫属。作为性能孱弱，散热捉急的 MacBook Air 用户，我肯定是第一个举双手赞成 Flash Player 寿终正寝的。腾讯视频、哔哩哔哩这些视频网站也已经支持了 HTML5，用我的 MacBook Air 看视频再也不担心电脑发烫了。Adobe 官方也宣布了将在 2020 年停止开发饱受诟病的 Flash Player。中国特供版 有后门收集用户隐私的Adobe并不是，如果中国用户留心一下，你会发现你下载的 Flash Player 跟国外用户不一样。 为了在线看一个视频，本来是要安装 Flash，一不小心就安装了两个捆绑软件，这可是从官网下载的 Flash，Adobe 什么时候学会了某些流氓软件“下载一个送全家”的套路？之所以存在这种捆绑安装的中国特供版 Flash Player，是因为 Adobe 把这个快要消亡的产品的分发权给了一家游戏公司—2144。中国特供版 Flash 被安装后会强行运行一个 FlashHelperService 的服务，《Helper Service 服务协议》中直接说明了该软件会搜集用户的上网信息。左手盗版，右手正版：思杰马克丁的商业闭环打着保护正版软件合法权利的旗号，实际上马克丁所做的事与之完全相反。你想象中的正版软件授权经销商是这样的：收费之后，通过分发渠道把官方授权的软件提供给你下载，赚取一定的服务费和软件开发商提供的分成。而思杰马克丁从一开始就没有走这条“平凡之路”，而是在代理会声会影后改了数字签名。在“如何评价苏州思杰马克丁软件公司？”的知乎话题中，第一个回答详细列举了思杰马克丁篡改会声会影数字签名的证据。马克丁的经营模式可以称之为“极不要脸”：把大量软件（正版/破解版）的网络链接替换成他们的试用版，甚至伪造中文网站，将不知情的用户引流到马克丁购买，诱导用户使用它们提供的“正版软件”。数字签名，意味着软件的著作权。如果对其进行修改，极易造成软件与系统的不兼容，从而导致一系列问题产生，甚至使软件再也无法使用。会声会影X10的数字签名：在微软 Windows XP 的一次数字签名布丁更新后，由于思杰马克丁对会声会影的数字签名进行了修改，导致了微软认证数字签名发生了错误，软件无法安装。而在思杰马克丁鞭长莫及的其他国家，会声会影并没有出现这样的问题。这样的事情不只发生在会声会影这一款软件身上。比如思杰马克丁曾经代理过的思维导图工具 Xmind 也被篡改过数字签名。改了签名之后，思杰马克丁还名正言顺的加上自己网站的导流链接。Xmind 曾将大陆的代理权独家授权给了思杰马克丁，麻烦事就接踵而至。思杰马克丁经常把站点的 Title 和关键词改成“XMind 官网“”或者“XMind中文官网”，授权思杰马克丁代理之后，减少盗版的成效还没看到，在百度搜索 Xmind 排名最靠前的就成了思杰马克丁的导流网站。“身心俱疲”的 Xmind 终止了与思杰马克丁的合作，思杰马克丁终于露出了他“狰狞的面孔”：暂停合作以后，思杰马克丁先是把 “Xmind官网”改成“Xmind中文官网”，在网站上声称“XMind 暂停销售”。紧接着就用下面一行大字推广另一款竞品“mindmanager”促销优惠，并附上跳转链接。FL Studio在中国仅一家代理商，便是由FL吧主开设的雪帝数字音频有限公司，除此之外并无其它代理。而FL Studio吧在某一段时间，资源导航帖全被百度强制性删除。经代理商查证，发现这件事的始作俑者正是马克丁。与此同时，马克丁还在论坛发布大量“马克丁试用版”的资源帖，同时广泛散布谣言，宣称自己才是FL Studio的官方代理，将FL吧主反咬成盗版商。马克丁这一举动使大量热心网友开始了对它的扒皮搜证。天眼查显示，思杰马克丁还为自己代理的这几款软件都申请了著作权，名字分别是会声会影 X10 视频剪辑软件，思杰马克丁 MindManager 思维导图工具软件，Pargon NTFS for Mac 格式读写软件，CleanMyMac 系统清理软件等，一共有 30 件软件著作权，乍一看还以为这是一家全能的软件开发商。你可能会有疑问了，既然思杰马克丁篡改软件数字签名，软件真正的开发商能同意吗？为什么还要跟思杰马克丁合作？这就体现出思杰马克丁商业闭环的强大之处了，同时握有盗版和正版资源，思杰马克丁可以“黑白通吃”，游刃有余。但经查询马克丁代理的多款软件后，网友们发现这些软件的版权公司官网上都并没有看到中国代理商的信息。可见马克丁以正版代理自居的说法，完全是站不住脚的。就算有代理权，马克丁也将不知道什么途径代理而来的软件，在中国申请了软件著作权。而且著作权都是带有思杰马克丁前缀的空头软件名，因为思杰马克丁根本没有开发软件的能力。即使马克丁与国外不知情的开发商签署合作协议获得了授权，但它们也并没有权力在自己提供的软件里篡改版权方数字签名，甚至修改程序内指向原公司网站的链接。然而马克丁秉承着“舍不得孩子套不着狼”的宗旨，宁愿引起用户怀疑，也不愿意放弃榨干正版软件的油水。它们就这么明目张胆地干了。同时，为了达到推广自己网站的目的，马克丁还屏蔽了软件的激活通道，使用户购买的序列号只能在他们的软件上激活。这就是为什么许多用户发现，从马克丁购买的软件序列号只能在中国区使用，而无法在国外版本上激活的原因——因为这根本就不是正版软件，而是马克丁修改过后的劣质产品！马克丁理论上获得了国外正版软件的授权，实际上谁知道呢？这样一来，就算某家软件商不再与它进行代理合作，它们也可以继续把盗版软件卖下去，反正数字签名已经换成了自己的，国外软件商想要起诉它需要花费大量的精力，只能不了了之。马克丁的盗版软件以正版软件价格出售几乎是常态，甚至比正版价格更高。会声会影正版价格：马克丁版会声会影：不仅如此，用户在购买过他们修改过的版本后，几乎没有得到任何售后服务，一旦软件出现问题，售后便只会甩锅，一问三不知，因为它们根本无法解决。曾经使马克丁被群起攻之的“会声会影”事件，便是因此产生的。如今在网络上放眼望去，马克丁几乎是罕见的“零好评”，只能说一句天道好轮回。“马仔”和“水军”：思杰马克丁的秘密武器一些合作并不是软件开发商看中了思杰马克丁的软件分发能力，实属无奈之举。如果不合作的话，手握大量盗版网站资源的思杰马克丁分分钟就能放出大量盗版软件。被这种手段“坑”过的一家软件开发商告诉 PingWest品玩，很多软件的代理权都是通过这种“勒索”手段拿到的。作为思杰马克丁的“小弟”，破解网站们除了帮“大佬”勒索开发商，平时也要负责给思杰马克丁网站导流。比如如果有人发帖问：“哪位大神有 Photoshop 的破解版？”回答必定是思杰马克丁的购买跳转链接。当然，这些“小弟”们一开始也不是心甘情愿服从的，思杰马克丁会给他们发来律师函，打着反盗版的名义威胁这些不通话的“小弟”，然后给这些盗版网站返利链接，盗版网站们几乎没有不服的。更有意思的是，我们原以为，马克丁纂改正版软件数字签名等行为已经跌破了道德底线，然而没想到会无耻到这个地步：它们成立了一个专业的公关团队。在思杰马克丁的商业帝国里，类似“水军”的广告推销员也占据了不小的比重。比如你在百度知道搜索会声会影破解版，得到的跳转链接很可能就是“水军”刷出来的。比如在网络上专门负责宣传马克丁软件的水军。另外，一旦有人在网络上分享原版软件的网站及链接，都会被马克丁举报；官方渠道的可以激活的试用正版软件，通通举报；同行的破解软件淘宝店，看都不看，投诉！马克丁还打着“正版软件维权运动”的旗号，天天到论坛上以发律师函威胁网友，它们的官方微博也已经破罐子破摔，常常可以看到马克丁运营跟网友互掐。马克丁还特别擅长钓鱼执法。它们会伪装成买家、百度提问者、网络小白，在淘宝店、社群、论坛等地方咨询破解信息，一旦对方给出了答案，它们就会以截图为证据，轻则恐吓，重则投诉，最后搞垮竞争对手。据知乎用户文竹夜泉爆料，思杰马克丁官网专门有个名为网盟的后台，你可以创建广告推广链接，刷到各大网站和论坛后可以拿到一定的提成。然而不管马克丁如何发展扩大，有心人只需要上网一搜就能看到它的真正面目。国家近年来也在逐步加大对互联网版权的保护，马克丁这一类流氓软件商早晚会自取灭亡，随着国人版权意识的提高，这类行业毒瘤注定无法在一片绿色安全的土地上生根发芽。思杰马克丁产品事业部负责人金伟，创始人兼CEO金勇，联合创始人陈俊峰，副总裁李全",
    "postDate": "2019-01-30T23:40:45.3332377+08:00",
    "email": "admin@masuit.com",
    "label": "思杰马克丁",
    "keyword": null,
    "id": 1383,
    "indexId": "Post:1383"
  },
  {
    "title": "盗版软件界传奇一哥，思杰马克丁大起底",
    "author": "懒得勤快",
    "content": "国内用户在使用正版软件的道路上困难重重，其中最大的阻碍就来自于思杰马克丁。提到这五个字，想必很多老网民都不会感到陌生。这个在国内名声扫地的软件商，就连谷歌评论都是一颗星，可谓是盗版软件界的先驱。但即使遭受的骂评如潮，它为什么却能在铺天盖地的讨伐声中依然保持巍然不动的地位？随着时代变迁，马克丁这位十多年前专做正版软件破解的论坛用户也一朝转型成功，于2009年正式成立“苏州思杰马克丁软件公司”。接下来，就让我们看看他是如何开启轰轰烈烈的“代理”生涯的。正版盗版，傻傻分不清楚进入苏州马克丁公司官网，可以看到它提供许多软件购买。打着保护正版软件合法权利的旗号，实际上马克丁所做的事与之完全相反。比如著名的FL Studio事件。FL软件在中国仅一家代理商，便是由FL吧主开设的雪帝数字音频有限公司，除此之外并无其它代理。而FL吧在某一段时间，资源导航帖全被百度强制性删除。经代理商查证，发现这件事的始作俑者正是马克丁。与此同时，马克丁还在论坛发布大量“马克丁试用版”的资源帖，同时广泛散布谣言，宣称自己才是FL的官方代理，将FL吧主反咬成盗版商。马克丁这一举动使大量热心网友开始了对它的扒皮搜证。经查询马克丁代理的多款软件后，网友们发现这些软件的版权公司官网上都并没有看到中国代理商的信息。可见马克丁以正版代理自居的说法，完全是站不住脚的。就算有代理权，马克丁也将不知道什么途径代理而来的软件，在中国申请了软件著作权。而且著作权都是带有思杰马克丁前缀的空头软件名，因为思杰马克丁根本没有开发软件的能力。替换链接，伪造中文官网马克丁的经营模式可以称之为“极不要脸”：把大量软件（正版/破解版）的网络链接替换成他们的试用版，甚至伪造中文网站，将不知情的用户引流到马克丁购买，诱导用户使用它们提供的“正版软件”。在那段时间，小到解压程序，大到专业软件，用户下载的东西几乎无处不见马克丁试用版的影子。就在给用户成功洗脑“我们是正版”的概念，用户也开始接受它提供的所谓正版产品后，马克丁也逐渐暴露了它无耻的本质。纂改数字签名，修改软件程序数字签名，意味着软件的著作权。如果对其进行修改，极易造成软件与系统的不兼容，从而导致一系列问题产生，甚至使软件再也无法使用。即使马克丁与国外不知情的开发商签署合作协议获得了授权，但它们也并没有权力在自己提供的软件里篡改版权方数字签名，甚至修改程序内指向原公司网站的链接。然而马克丁秉承着“舍不得孩子套不着狼”的宗旨，宁愿引起用户怀疑，也不愿意放弃榨干正版软件的油水。它们就这么明目张胆地干了。会声会影X10的数字签名：同时，为了达到推广自己网站的目的，马克丁还屏蔽了软件的激活通道，使用户购买的序列号只能在他们的软件上激活。这就是为什么许多用户发现，从马克丁购买的软件序列号只能在中国区使用，而无法在国外版本上激活的原因——因为这根本就不是正版软件，而是马克丁修改过后的劣质产品！其次，马克丁理论上获得了国外正版软件的授权，实际上谁知道呢？这样一来，就算某家软件商不再与它进行代理合作，它们也可以继续把盗版软件卖下去，反正数字签名已经换成了自己的，国外软件商想要起诉它需要花费大量的精力，只能不了了之。没有售后，盗版卖价更比正版高马克丁的盗版软件以正版软件价格出售几乎是常态，甚至比正版价格更高。会声会影正版价格：马克丁版会声会影：不仅如此，用户在购买过他们修改过的版本后，几乎没有得到任何售后服务，一旦软件出现问题，售后便只会甩锅，一问三不知，因为它们根本无法解决。曾经使马克丁被群起攻之的“会声会影”事件，便是因此产生的。如今在网络上放眼望去，马克丁几乎是罕见的“零好评”，只能说一句天道好轮回。网络斗士，举报达人我们原以为，马克丁纂改正版软件数字签名等行为已经跌破了道德底线，然而没想到会无耻到这个地步：它们成立了一个专业的公关团队。比如在网络上专门负责宣传马克丁软件的水军。另外，一旦有人在网络上分享原版软件的网站及链接，都会被马克丁举报；官方渠道的可以激活的试用正版软件，通通举报；同行的破解软件淘宝店，看都不看，投诉！马克丁还打着“正版软件维权运动”的旗号，天天到论坛上以发律师函威胁网友，它们的官方微博也已经破罐子破摔，常常可以看到马克丁运营跟网友互掐。马克丁还特别擅长钓鱼执法。它们会伪装成买家、百度提问者、网络小白，在淘宝店、社群、论坛等地方咨询破解信息，一旦对方给出了答案，它们就会以截图为证据，轻则恐吓，重则投诉，最后搞垮竞争对手。然而不管马克丁如何发展扩大，有心人只需要上网一搜就能看到它的真正面目。国家近年来也在逐步加大对互联网版权的保护，马克丁这一类流氓软件商早晚会自取灭亡，随着国人版权意识的提高，这类行业毒瘤注定无法在一片绿色安全的土地上生根发芽。不说了，马克丁律师函还有三分钟就要到达战场了。",
    "postDate": "2019-01-30T23:40:45.3333344+08:00",
    "email": "admin@masuit.com",
    "label": "思杰马克丁,思杰马克狗",
    "keyword": null,
    "id": 1296,
    "indexId": "Post:1296"
  },
  {
    "title": "会声会影2018全套插件汉化版本",
    "author": "懒得勤快",
    "content": "会声会影旗舰版插件非常多，例如：NewBule FX、G滤镜、防抖滤镜、魔术转场、Boris Title Studio、ProDAD RotoPen、proDAD Handscript、proDAD VitaScene，通常会声会影高级用户必装的插件是NewBule FX、G滤镜、防抖滤镜、魔术转场，这几个是经典插件，其他的插件倒不常用，大家可以选择安装。会声会影2018全套插件汉化版此为会声会影2018“特别收录”中的7个全套插件，需先安装会声会影才能使用。本汉化均无需安装英文原程序，安装后即为简体中文版，可静默（安装路径不可更改）或手动（安装路径可更改）安装。本程序是在黄贻伟老师指导下完成的全新汉化版本，严禁传播和用于赢利目的！插件(均可安装到会声会影X5-2018)：mercalli_2.0.127_&quot;/&gt;HeroglyphRoute_4.0.257.1_32&quot;/&gt;HeroglyphScript_4.0.257.1_32&quot;/&gt;Vitascene_2.0.244_&quot;/&gt;├—–此版本为未完全汉化版，部分繁体中文的部分简体化后无法显示，非技术原因。├—–安装时若需要输入序列号，可以从以下序列号中选用：├—–VC3K-UAM6-83VN-3VWU-ISFX-V2J8-BIP0├—–A62V-DTFM-YP3F-N7GY-93ET-RB9P-3NP0├—–4RYP-PM3G-PCGN-7SYC-PIWV-P4H4-9IP0├—–7HB7-II72-AZKN-EBK6-QPQ5-FRI3-DIP0├—–QJ85-HPR3-BPJZ-HZGT-XX5S-9WJG-SAP0├—–SK9H-2RWP-6DX9-UH8M-PV7P-4MTT-PNP0Adorage_3.0.115.1_32&quot;/&gt;AdorageV9_3.0.115.1_32&quot;/&gt;Graffiti 7.0.1004.0_32-64bit简体中文&nbsp;【proDAD Mercalli】会声会影2018插件汉化_mercalli_2.0.127_32-64bitproDAD Mercalli（俗称：防抖滤镜），使用 proDAD Mercalli 以提供视频画面的稳定性。不论动作再快，这项应用程序都可确保稳定的视频画面。滚动快门修补功能让您在平移镜头时可以移除画面晃动和倾斜。【ProDAD RotoPen】会声会影2018插件汉化_HeroglyphRoute_4.0.257.1_32-64bitProDAD RotoPen，可以将动画式画笔特效应用至地图、照片和更多素材，利用线条和图形说明从 A 点到 B 点的移动，或者将动画式画笔特效套用至任何路径。本版本是会声会影2018配套插件之一，但是不仅能在2018版本上使用，理论上在之前任意版本的会声会影上都可以使用。主界面是繁体中文。【proDAD Handscript】会声会影2018插件汉化_HeroglyphScript_4.0.257.1_32-64bitproDAD Handscript ，以动画方式处理您的标题，或利用 proDAD 的动画手绘效果，将标题变成真实画面上的手稿，协助您述说自己的故事。本版本是会声会影2018配套插件之一，但是不仅能在2018版本上使用，理论上在之前任意版本的会声会影上都可以使用。主界面是繁体中文。&nbsp;【proDAD VitaScene】会声会影2018插件汉化_Vitascene_2.0.244_32-64bitproDAD VitaScene，利用旧底片特效、射线、闪光以及令人惊艳的电视品质转场、滤镜和特效，让您的视频展現个人分风格。本版本是会声会影2018配套插件之一，但是不仅能在2018版本上使用，理论上在之前任意版本的会声会影上都可以使用。主界面是繁体中文。【proDAD Adorage】会声会影2018插件汉化_Adorage_3.0.115.1_32-64bitproDAD Adorage，俗称：魔术转场，使用超过 150 种特效和转场，发挥您的创意，协助您制作高质量片头、转场和谢幕等等。&nbsp;【proDAD Adorage-CoreFilter】会声会影2018插件汉化_AdorageV9_3.0.115.1_32-64bit【Boris Graffiti】会声会影2018插件汉化_Graffiti 7.0.1004.0_32-64bitBoris Graffiti 俗称G滤镜，是会声会影2018的14个插件中的一个。现在这套全新的标题模板让您可使用精美的电视质量标题和图形，轻松制作复杂标题动画，如在文字上输入、路径上放置文字、抖动和随机数化。&nbsp;下载地址&nbsp;(提示：压缩包解压密码为masuit.com)https://pan.baidu.com/s/15EQ17lnA39F5iSGDMbyWzQ链接被和谐请在下方留言反馈。",
    "postDate": "2019-01-30T23:40:45.3333987+08:00",
    "email": "admin@masuit.com",
    "label": "思杰马克丁,思杰马克狗,会声会影",
    "keyword": "思杰马克丁,思杰马克狗,流氓公司,盗版商,会声会影,苏州思杰马克丁马克丁死全家",
    "id": 182,
    "indexId": "Post:182"
  },
  {
    "title": "拿下Adobe中国代理的思杰马克丁其实是一家“流氓”公司",
    "author": "懒得勤快",
    "content": "前段时间思杰马克丁公司官方微博发出一条消息，称代理了Adobe公司的产品。这一消息传出，网上是一片骂声，单单这条微博下方就充斥着各种负面评价。这家公司的恶名也是由来已久。思杰马克丁，全称是“苏州思杰马克丁软件有限公司”，这家公司成立于2009年，但在这之前，相信老网民们也早有耳闻。这个组织的最开始是靠破解软件起家，那时候和老红客联盟论坛是齐名的。各种破解版、绿色版软件很多出于国外，但国内基本上都是来自这两家。思杰马克丁公司的官网首页到了2009年，人们开始意识到版权问题，逐渐愿意接受正版软件，并为之付费。在这个时候，马克丁做出了一个重大决定，退出破解界，进军正版软件的代理行业。几乎是一夜间，本来百度一下就能很容易找到的破解软件，都变成了试用版软件。当然，电子签名上印上了赫赫七个大字“苏州思杰马克丁”。从版权保护来看，这似乎是好事，遏制了盗版软件的流通。但中国真的进入正版时代了吗？显然不是，这家公司的恶心之处才刚刚露出头角。最开始，只是一些数据恢复软件，FTP工具软件等小工具被换成了“马克丁试用版”，这些可有可无的软件也没给大家的使用带来太大的麻烦。但随着时间的推移，这家公司代理的产品越来越多，不知不觉间，很多随手下载的软件，都已经被替换成为“马克丁试用版”。马克丁俨然一副软件行业正版大佬的派头，就连自己软广告的宣传语都是“我们这里全都是正版！正版！正版！”马克丁代理软件的一部分6发展到这里，马克丁还是一副好人的样子，维护着正版软件的利益。但接下来，马克丁就露出了他难看的吃相。导火线是马克丁成功拿下了“会声会影”软件的代理。会声会影作为一款视频剪辑的入门软件，在我国的安装量是很大的。因为正版的有着丰富的模版和完善的售后，会声会影在我国也是盗版与正版并驾齐驱。期间微软更新了一次系统的补丁，也正是这次更新，马克丁的獠牙才被发现。一名客户在马克丁购买了会声会影，因为更新后系统变得卡顿，就卸载了会声会影。然而在准备重新装的时候，却发现软件无法安装。出现这种问题的不单单是则他一个，其他客户也都出现了这种情况。马克丁售后服务人员进行了多次安装调试，但都失败了。之后要求用户重装系统，但是很多用户电脑里存了重要文件，不愿意重装系统。于是要求退款成为了主流要求。这时候马克丁的客服开始撕破脸皮了，不仅拒绝退款，还要起诉用户。一口一个法盲叫喊着，并且以极其强硬的态度说这是微软更新的问题，进行推卸责任。但同一时期，国外的会声会影的用户却没有出现这种问题。这个问题单单出在国内，原因在哪？经过调查，原因是马克丁擅自修改了软件数字签名，自己公司的数字签名嵌入进了软件内，把软件安装完成后指向的官方地址修改成了自己做的“官方网站”。最过分的是马克丁还对里面的版权信息等签名信息进行了修改，变成了自己的信息。微软发布的补丁，是为了完善了数字签名认证系统。而马克丁对数字签名进行了修改，直接导致了微软认证数字签名发生了错误，所以软件无法安装。接下来是更多的数字签名事件被曝光，在马克丁旗下代理的所有软件中，均发现了数字签名被篡改的情况。马克丁的此等举动无异于操起了他的老本行，干起来盗版的买卖，只不过这次披上了代理的外衣。在说回马克丁代理Adobe。PS、PR、AE等图形、图像、视频编辑软件均是出自Adobe公司。Adobe公司的产品价格巨贵，也没有学生版、社区版，同时又破解起来十分容易，所以很多人选择使用破解版。Adobe公司软件的密匙统统藏在一个叫amtilb.dll文件中。而这个文件，用下面两款软件又极其容易破解。用过破解版的网友对这两款软件一定不陌生。这两款软件俗名叫做Adobe注册机，就是专门用来破解他家的软件的。这也就导致了我国Adobe软件的装机量巨大，但公司却捞不到一份。这就和当年windows在我国的情况类似。马克丁公司的代理，肯定会去治理当下盗版横行的现状，然后又极有可能修改Adobe的数字签名，再换上自己的链接，以高于官方的售价出售，还不包售后。毕竟这种事情他不是第一次干了。Adobe公司能和这家公司合作肯定是不了解这家公司的黑历史，作为行业标准制定者，一旦后期认清了这家公司的丑恶嘴脸，一定会解约或者不续约。支持正版是每个人的义务，但是对于这种无良的代理商，我们一定要去抵制！",
    "postDate": "2019-01-30T23:40:45.3335576+08:00",
    "email": "admin@masuit.com",
    "label": "思杰马克丁",
    "keyword": null,
    "id": 1384,
    "indexId": "Post:1384"
  },
  {
    "title": "著名的Adobe Flash是怎么变成流氓软件的？",
    "author": "懒得勤快",
    "content": "相信用过PC机的读者们，肯定都用过Flash插件，无论是玩页游还是看视频，一般都离不开Flash。而这款大家习以为常的插件，不知从何时起，我们在国内Adobe Flash Player的官网下载的安装包却变成了“中国特供”。这个特供，不是为我们做了优化，而是附带了一个窃取用户隐私的“监视器”。据用户反映，特供版Flash Player在安装后会强制运行FlashHelperService服务，看着像是个帮助文件，但实际用是搜集用户隐私，更麻烦的是，这个进程服务你是无法终止的，它会一直在后台持续工作。在你安装时那密密麻麻的Adobe用户协议中也写到，Flash Player使用过程中“重橙网络”可能会搜集用户的上网信息，并可以在合理范围内将信息披露给第三方，如果用户隐私数据安全受到威胁也不用承担责任。没见过这么流氓的协议而且，特供版你必须用，大陆用户无法通过下载海外版来规避条款。海外版 Flash 插件加入了用户地区检测，安装过程中，检测到用户的 IP 在大陆地区，它将自动跳转到中国官网下载“特供版”。如果用户已经安装了海外版，软件会直接拒绝工作。除此之外，Flash Player 的 Windows 版官方安装程序，会默认捆绑安装名叫“2144 游戏中心”的软件，点击下载之后，网页还会跳转到带有2144后缀名的网址。而取消勾选“游戏中心”的按钮像一些山寨的捆绑软件一样，以一个特别不显眼的方式安放在页面的角落。左下角角落默认勾选“游戏中心”在这一系列消息被曝光之后，重橙网络紧急修改了用户协议，改为“在不涉及侵犯用户个人隐私的前提下， 程序可能会记录用户如何使用本程序的信息和用户使用本程序的相关数据”。但是这已经是无力回天了。那问题来了，为什么这个官方下载的Adobe软件会变成这样呢？一款大众都认可的软件如今为什么在中国却被贴上“山寨”“捆绑”的标签？这个就牵扯到代理公司的问题了，因为目前海外的软件公司因为政策的原因，要想在国内推行服务只能通过与国内的公司合作，找到国内的软件代理商，就好比之前苹果的iCloud需要国内的云上贵州公司代理运作。Adobe公司在国内合作的代理商是思杰马克丁（CJ Marketing），而这家你也许从没了解过的企业，可谓是臭名昭著。根据天眼通查询到，思杰马克丁的全称为“苏州思杰马克丁软件有限公司”，在2009年之前，马克丁一度是活跃于破解软件中的名字。在公司成立后，思杰马克丁转型成为正版软件授权经销商，代理的第一款软件是会声会影。自从成为软件代理商之后，曾经热衷于破解的思杰马克丁不会像普通软件经销商那样：老老实实赚取服务费和软件开发商提供的分成。它非常“特供”地通过一手盗版加一手正版，形成自己的商业闭环。在代理会声会影时，当微软Windows XP的一次数字签名布丁更新后，由于思杰马克丁对会声会影的数字签名进行了修改，导致了微软认证数字签名发生了错误，软件无法安装。除此之外，思杰马克丁曾代理过的思维导图工具X mind同样被篡改数字签名，改了数字签名之后，在软件详情页给自己的网站导流也就名正言顺了。详情访问链接均思杰马克丁的引流网站，引导你购买中国特供版 Xmind，真正的官网是www.xmind.cn除了这些代理的软件，思杰马克丁还给自己代理几款软件申请著作权，数量可达30件，乍一看还以为是个全能的软件开发商呢！那么问题来了，既然思杰马克丁篡改软件的数字签名，还给自己的网站导流，为什么软件开发商还要和他合作呢？因为思杰马克丁手上握着大量盗版的网站资源，如果对应软件的开发商不授权合作的话，大量的盗版软件就会被放出。同时这些破解网站作为“勒索”软件开发商的一个手段之外，还能为思杰马克丁的网站导流，以至于在搜索引擎中，正版的软件官网会被思杰马克丁提供的导流网站顶下去。当一些软件开发商终止与思杰马克丁的合作之后，思杰马克丁则会修改其在中国的官网信息，推出同类的竞品进行推销，同时在各大的盗版网站也会放出修改过的软件安装包。面对国内的软件代理公司良莠不齐而且缺乏管理，软件服务变味不是没有道理的，这些国外的软件开发商想要进入国内市场，原来自己的那套体验服务是无法复制的，最终还是要靠代理公司的“良心”。所以我们热衷于使用的盗版软件服务商，摇身一变，成了“黑白两道通吃”的思杰马克丁。",
    "postDate": "2019-01-30T23:40:45.3336442+08:00",
    "email": "admin@masuit.com",
    "label": "思杰马克丁,Adobe,flash",
    "keyword": "思杰马克丁,思杰马克狗,业界毒瘤,流氓公司,盗版商马克丁死全家,Adobe flash",
    "id": 1251,
    "indexId": "Post:1251"
  },
  {
    "title": "思杰马克丁表情包",
    "author": "懒得勤快",
    "content": "思杰马克丁系列表情包，右键另存为，即可保存。版权没有，盗图不究！在此，我想告诉各位，收到律师函的朋友:他告由他告，明月照大江！图片来自网络！图片来自网络！",
    "postDate": "2019-01-30T23:40:45.3337126+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "思杰马克丁",
    "id": 1345,
    "indexId": "Post:1345"
  },
  {
    "title": "思维导图 iMindMap Ultimate 10.1.1/9.0.1/8.1.1多语言破解版",
    "author": "匿名",
    "content": "iMindMap是一款商业思维导图软件，可以绘制思维导图、鱼骨图、二维图、树形图、逻辑图、组织结构图等。方便地导入导出多种格式。iMindMap是手绘思维导图软件的先驱，由思维导图创始人托尼·巴赞(Tony Buzan)开发，是捕捉创意、整理拓展思维并变为执行力的智能思维空间，结合独特的自由形态头脑风暴视图和系统的思维导图视图，特别适用于头脑风暴、策划和管理项目、创建演示文稿等。iMindMap10新增了时间导图视图，更新了分支绘图工具，思维导图库集成，优化的头脑风暴视图，增强快速捕获视图，新增了中心思想图像，最新Email集成，让iMindMap的功能更为强大。绘制步骤思维导图是一种可视化思维工具，可以应用于所有的认知功能，尤其是记忆、学习、创造力和分析。当创建一个思维地图时，有几个元素需要着重考虑，包括导图的中央图像，分支，颜色，关键字和图像。下面将为大家介绍创建思维导图5个步骤。官网地址：http://www.imindmap.com/下载地址附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!官方安装包：链接: https://pan.baidu.com/s/19Q0K1HIOVY7iqZqKzRr98Q&nbsp;提取码: qu42推荐下载地址：https://yun.naodai.org/Software/iMindMap/破解补丁：稀缺资源统一下载地址页",
    "postDate": "2019-01-30T23:40:45.3337758+08:00",
    "email": "2167933109@qq.com",
    "label": null,
    "keyword": "脑图,思维导图,思杰马克丁,imindmap",
    "id": 1358,
    "indexId": "Post:1358"
  },
  {
    "title": "最强几何画板Geomaster Sketchpad 5.0.6简体中文直装破解版",
    "author": "懒得勤快",
    "content": "大家心心念念的几何画板博主也给大家扒来了。几何画板是一个通用的数学、物理教学环境，提供丰富而方便的创造功能使用户可以随心所欲地编写出自己需要的教学课件，是最出色的教学软件之一。它主要以点、线、圆为基本元素，通过对这些基本元素的变换、构造、测算、计算、动画、跟踪轨迹等，构造出其它较为复杂的图形，是数学、物理教学中强有力的工具。本站从网上收集、整理并制作了此最强版，含上千个课件实例和5份详细的图文教程，整合3D几何画板工具，弥补了几何画板遇到立体几何问题就无能为力的缺陷，整合最新几何画板控件，以便在ppt、word等环境里无缝插入几何画板文件。这是一个前所未有的版本，它将是目前网络上可以下载到的最强的版本。本版特色01 - 主程序完美汉化；02 - 免注册，无限制；03 - 无需手动设置，自动防乱码；04 - 无需手动设置，自动加载工具集（346个常用工具），并作了分类，用起来很方便；05 - 整合5份几何画板详细图文教程，助您从入门到精通；06 - 整合精心收集整理的上千个几何画板课件实例，让您直接与画板高手接触；07 - 可选安装新版几何画板5控件，安装后可无缝插入ppt、word、wps等（含教程）；08 - 整合3D工具集（需手动选择工具目录），用于解决立体几何问题，含详细使用教程；09 - 整合几何画板5.06打包机，GSP画板文件打包后无需安装几何画板即可运行；10 - 画板教程、实例目录、打包机的链接可从帮助菜单或开始菜单打开。新版打包机特色：1.打包gsp文件为exe格式，防修改，高压缩率，无需安装几何画板直接运行；2.高度可自定义模式，满足板友各类需求；3.全屏模式效果同幻灯片，鼠标移至顶部下滑控制菜单，效果前所未有；4.显示菜单模式，点左上角标题边的程序图标可“隐藏或显示”画板菜单；5.去除自动写注册表关联文件功能，运行后不影响原几何画板的关联；6.可同时运行多个打包后的课件；7.打包时支持以拖曳方式把gsp文件拖到打包对象框；8.支持热键显示和隐藏菜单栏（Ctrl+Alt+F4）及工具条（Ctrl+Alt+F5），页面切换（PgUp，PgDn）；9.支持自定义打包后的exe文件图标，前所未有；10.在打包课件中使用工具集的简便方法：打包后的exe文件、工具文件夹Tool Folder放在同一目录；在PowerPoint中无缝插入几何画板文件的方法（开始菜单里含pdf格式详细图文教程）1．点击PowerPoint2003“插入”菜单下的“几何画板文件(*.gsp)”命令，选择gsp文件然后在ppt编辑区点击即可，通过拖动四周的句柄可以调节画板演示区域大小；2．（1）在PowerPoint2003里单击“视图”→“工具栏”→“控件工具箱”→“其他控件”；（2）点“其他控件”，找到“GspForPPT Control”（金氏版）或“GspControl.gsp”（叶氏版）命令，点击后在ppt编辑区绘制该控件，通过拖动四周的句柄可以调节画板演示区域大小；（3）单击“控件工具箱”上的“属性”按钮，或控件框右键里的“属性”，打开属性对话框，双击GspFile选择文件，或在其右侧填写gsp相对路径（推荐）或绝对路径。（当gsp文件与PPT在同一文件夹时，程序会自动转入相对引用）金氏版本热键：ShowMenu：显示菜单（热键：Ctrl+Alt+F4）ShowTool：显示工具栏（热键：Ctrl+Alt+F5）ShowScroll：显示滚动条叶氏版本热键：① Ctrl+Alt+PageDown/PageUp=幻灯片上一页/下一页② PageDown/PageUp=画板上一页/下一页（Ctrl+Alt+数字）③ Ctrl+Alt+T:显示或隐藏画板工具栏；Ctrl+Alt+M:显示或隐藏画板菜单栏④ Ctrl+Alt+←/→:画板页面左右移动；Ctrl+Alt+↑/↓:画板页面上下移动(滚轮)⑤ Ctrl+Alt+SPACE(空格键):在不透明时全屏或退出全屏（4）修改属性值后，建议PPT另存覆盖原来的文件，以保证属性值能保存。&nbsp;3.在控件中使用工具集的简便方法：GSP文件、PPT文件、工具文件夹Tool Folder放在同一目录；注意事项1．第一次运行程序，然后最大化，关闭后重新运行，会记忆自动最大化。2．为了加快画板程序启动速度，简体中文版自动加载的工具集里不含[3d]基本工具、[3d]着色工具、[3d]旋转、算法框图等26个工具组，如需使用请手动选择安装目录里的工具目录（默认C:\\Program Files\\Sketchpad5\\Tool Folder）；3．如果您的系统是Windows7或Vista，请启用最高管理员账户Administrator后再安装几何画板，并且Office要使用完整版或无损精简版，不然运行控件会出现：“运行时错误&#39;52&#39;：错误的文件名或数”。（本站制作的各版本金狐Win7和Vista默认已启用，无需再设置，建议下载使用。）非Administrator用户则必须以管理员身份或用XP兼容模式运行ppt。下载地址稀缺资源统一下载地址页同时，给大家推荐一款类似于几何画板的免费软件：geobebra，大家直接百度搜就行了。附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!",
    "postDate": "2019-01-30T23:40:45.3338375+08:00",
    "email": "admin@masuit.com",
    "label": "思杰马克狗,思杰马克丁",
    "keyword": "几何画板,Geomaster,Sketchpad",
    "id": 1285,
    "indexId": "Post:1285"
  },
  {
    "title": "鬼畜视频创作神器——EDIUS Pro 非线性视频编辑软件（8.53.3262）汉化特别版",
    "author": "懒得勤快",
    "content": "EDIUS Pro 9是一款支持更多的格式、更高分辨率的实时编辑软件，一切皆可编辑及快速编辑的特点让EDIUS Pro 9成为各类视频完美的专业后期制作工具，包括纪录片、4K及HDR戏剧作品。EDIUS Pro 9为编辑提供了更多创意选项，并且支持通用的SD、HD甚至4K和HDR格式的实时编辑，无需渲染。这也使之成为当前最实用、最快速的非线性编辑软件。功能特点更多格式，更好的工作流EDIUS Pro 9支持所有通用的文件格式，包括SonyXDCAM、Panasonic P2、Canon XF以及EOS视频和RED格式。在后期制作中，你可以采用Grass Valley高性能的10 bit HQX编码，或选择Avid DNxHD编码（Workgroup版本中标配）。无可匹敌的多格式编辑EDIUS Pro 9拥有无与伦比的实时视频转码技术，可实现HD/SD和HDR/SDR不同分辨率、不同宽高比和帧速率的任意实时变换。多文件格式输出输出多种格式文件对于EDIUS Pro 9来说并不是问题。用户可根据需要选择不同的分辨率，根据不同的播放器（QuickTime、Widous Media等）选择不同的媒体格式，以配合不同终端系统的发布需要。GV资源浏览器Mync是EDIUS Pro 9的一项新增功能，它可让你轻松管理所有视频、音频、图片素材，是为在EDIUS中进行编辑做足准备的便利工具。Mync具有智能化识别功能-当你的系统连接上移动硬盘或读卡器的时候，它会自动识别可用的文件格式，并显示在素材库中。新版特性1、HDR素材原生编辑；2、可输出带有HDR色彩空间的广播级和网络流媒体文件，并提升了EDIUS3、对4K UHD素材的直接处理能力；4、支持同一时间线中混合剪辑SDR和HDR素材，并可任意输出颜色空间信息；5、支持主流厂商的相机、摄像机、无人机及手机拍摄的HDR视频；6、工作流程升级，新增支持佳能EOS C200“Cinema RAW Light”解码和7、静态原始文件解码，并改善了用户界面；8、第三方硬件支持更新；9、EDIUS 9捆绑的Mync（媒体管理软件），新增支持源数据智能搜索功能；下载地址：https://pan.baidu.com/s/1HkXk_wg-7yK5-ptiiB6zGg",
    "postDate": "2019-01-30T23:40:45.333914+08:00",
    "email": "admin@masuit.com",
    "label": "思杰马克丁,思杰马克狗",
    "keyword": "EDIUS,EDIUS Pro,非线性视频编辑,8.53.3262,汉化特别版",
    "id": 1267,
    "indexId": "Post:1267"
  },
  {
    "title": "鬼畜视频制作必备神器——专业非编视频剪辑软件 MAGIX Vegas Pro 16.0.0.307 中文注册破解版",
    "author": "懒得勤快",
    "content": "vegas pro破解版是一款非常强大的视频和音频制作的软件，它的主要功能还是视频编辑，比如：添加字幕、旋转视频、导入导出视频、导入导出视频等等，同时还提供了先进的悬停取消技术、高分辨率格式高达4K的音频素材以及支持4K UHD高清画面和RED camera，为视频编辑功能变得更加的强大。在vegas pro这个新的版本中，为我们用户带来很多新的功能，比如：画中画插件、画面修建插件、一键定格画面，另外还支持多线程音频引擎，更新了硬件加速编码/解码，让magix vegas pro的视频编辑、音频处理功能更加的强大，就算是新手也是非常的易上手，好操作。需要的用户欢迎前来下载vegas pro破解版！安装破解教程1、在本站下载好软件包后，你会得到如下图所示的几个文件，双击运行“VEGAS_Pro.exe”。2、语言的选择，有英语、法语、德语以及西班牙语，你可根据自己的需求进行选择，默认为英语，点击“Next”。3、选择magix vegas pro的安装目录，默认的安装路径为：C:\\Program Files\\VEGAS\\VEGAS Pro 16.0\\，建议不要修改，易导致破解时出错。勾选create a shortcut on the desktop（在桌面上创建快捷方式）”，点击“install”。4、开始安装vegas pro，安装的速度跟电脑的配置有关，时间的长短也不一样，时间长的请耐心等待！5、软件安装完成。6、双击桌面上的快捷方式打开软件，发现软件需要激活才能使用，下面我 就来开始盘破解。7、运行破解补丁8、再次打开软件，你会发现软件的激活界面已经没有了，然后点击“help”-“about”，你会发现已经生成了注册码，magix vegas pro破解完成。vegas pro使用教程使用vegas pro破解版制作视频时，常会用到的窗口有视频特效窗口、媒体发生器和轨道预览，本集主要为大家介绍这三个窗口的作用和功能。一、视频特效窗口视频制作软件的全部的视频特效都集中在这个窗口，包括它们的效果预览。可以选中某一种特效直接拖曳到素材上完成特效的添加。Vegas 的视频特效针对非编过程中的实际需要，虽然数量不多，也不那么花哨，但却非常实用。二、媒体发生器窗口媒体发生器中集中了vegas pro破解版内部生成的一些特殊素材，和外部采集导入的素材不同，它们是靠计算机模拟计算生成，并非真实的现实素材，比如一些纹理、文字、填充色、字幕，等等。Vegas 模拟生成的这些素材实用性非常强，在实际制作中有很大用处。三、轨道预览窗口轨道预览也是Vegas 中最重要的窗口之一，在本窗口中可以实现以下功能：1、预览轨道上剪辑合成的效果。2、设置当前项目的属性。3、切换到外部显示器中预览。4、添加视频输出特效。5、分屏显示。在调色时可以分屏观看调色前和调色后的效果对比。6、设置预览的显示比例，最大全屏预览，最小以原始画面的四分之一预览，默认为自动设置显示比例，以最佳的比例显示，同时兼顾性能，能够实时预览。7、显示安全框，关闭字幕，只显示RGB 通道中的某一个通道，或者将某一种颜色通道转变为灰度。8、保存快照，对当前画面拍照，保存为图像文件或者复制到剪贴板中。9、录音，在编辑过程中可以随时录音，并自动添加到轨道上，这样可以实现即时配音。功能介绍1、编辑工具使用拖拽功能，鼠标修建功能，和‘涟漪’剪辑功能包括专业字幕技术，多方位剪辑工具，32位浮点视频处理，自定义窗口预览，增强的 HDV/SDI/XDCAM支持，Cinescore插件支持，A/V同步的检波和修复，以及auto-frame量子化等等大量精确的工具编辑你的SD 或者 HD 视频。2、操作流程vegas pro破解版界面提供了可自定义的工作空间，达到广大创作产业所要求的标准。多窗口跨越多显示器，保存不同的界面设定以适合不同的工作要求；在时间线中嵌套 Vegas工程，自定义和保存快捷键，和自定义脚本替代重复的工作。系统强大的媒体管理创造出最大的效率。网络渲染使用多电脑渲染复杂的工程以节省宝贵的 时间。Vegas Pro软件还支持24p, HD and HDV剪辑。3、音频控制无限轨道，24-bit/192 kHz音频，punch-in录音（一种录音的修补技术），5.1环绕混响，音效自动控制，和压缩/延长时间。实时使用音频特效像EQ,反相，延迟等。使 用DirectX和 VST音频插件扩展你的音频处理和混音选项。使用混音控制台精确调整音频属性。4、DVD工具使用高清传输直接从时间线上烧录蓝光光盘。创建标准的多方位，多字幕，多语言和注解的DVD。应用亮度对比度调整，自动压限，修建和反闪烁滤镜。设 定CSS 和Macrovision防复制技术。DVD Architect Pro 4.5软件支持所有最新设备，包括双层DVD的刻录。5、交互式教程Vegas Pro 软件自带全面的帮助系统，也有逐步的交互式教学提供给新手学习入门。这些教学提供了简单人性化的操作流程，从而学习到需要掌握软件和完成基本任务的知识。6、工作流程直观和快速地从观看你的工程来编辑你多摄像机作品中的每一个。在多达32个视频源中使用键盘快捷键或鼠标点击切换。Vegas Pro 软件保存所有未使用的镜头让你可以重新调回微调。7、视频处理32位浮点视频处理大大超越了传统标准的10位浮点处理。提供了更宽广的色域和更鲜艳的颜色，减少了彩条的产生和色块，光学合成修正的线光源能力，和其他更多的增强。8、专业字幕插件使用路径，预设动作，和高级设置创建动态文字效果。可以添加投影，发光，模糊和变形等特效。支持Unicode 和 TrueType 文字，也支持OpenType字库的调整字距，预设样式，连写，自定义距离等等。新功能1、新的画中画插件2、vegas pro破解版内置LUT导入插件3、一键定格画面4、汉堡包菜单系统5、UI颜色可调（四色）6、支持更多颜色空间7、多线程音频引擎8、新增画面修建插件（可取代平移裁切功能）软件特色1、NewBlueFX Looks为每一张图片设置好的氛围，增加合适的视频效果：如来自NewBlueFX的电影色彩，色彩修正器Pro，渐变色调，Spotlight和辉光Pro给您的录音特别的外观。2、Vegas Pro综合DVD设计和创作使用Vegas DVD Architect完成项目：由于令人信服的布局和令人印象深刻的设计，您可以为DVD和蓝光光盘创建专业菜单。 从Photoshop导入您自己的图形自定义的背景，按钮和覆盖。通过简单地设置标记来定义电影的各个章节。 最后，完全控制编码器设置。3、转换项目格式Vegas Pro14支持的项目文件的输出格式非常广泛。本身的Veg文件AVID®ProTools®的AAF之间可以进行转换，同样苹果电脑公司的Final CutPro®7中的XML，Final Cut Pro的X(仅输出)，DaVinci Resolve的10和Adobe® Premiere® Pro CC和After Effects® CC的prproj等等都可以在Vegas Pro14中转换项目格式。4、扩展编辑模式编辑点双击查看详细A-B卷视图时间轴。在编辑点的事件的相邻帧清楚地出现在磁迹参考以上，并在时间轴上显示未使用的媒体。将编辑点/事件边缘以红色突出显示，你可以使用鼠标或数字键盘修剪。设置一个环区周围的编辑点动态地从编辑点两侧添加或删除帧，而媒体扮演着创造一个高度精确的，互动的编辑体验。5、GPU加速支持来自AMD，NVIDIA和Intel与OpenCL的™的设备格式，Vegas Pro14利用GPU加速的视频FX，转场，合成，平移/作物，田径运动和编码，提供了更快的显著工作流程。 GPU加速提供了播放性能增益和更快的渲染时间，以简化在Vegas Pro14中的视频编辑，非常适合行业中与时间争分夺秒的人士。6、vegas pro破解版支持4KVegas Pro14支持的帧大小最高4096×4096的数字电影放映的4K图像标准是4096×2160像素。分辨率此级别提供更多的细节和灵活性，在提供高清时，平移和作物。这是理想的合成和视频效果的工作，因为它提供了一个高品质的最终输出。Vegas Pro14支持XAVC和XAVC文件的文件，以及REDONE®和REDEPIC®文件。下载地址链接: https://pan.baidu.com/s/1mJQmAzWXzzdwSNwb0IuxvA&nbsp;密码: w6yz",
    "postDate": "2019-01-30T23:40:45.333979+08:00",
    "email": "admin@masuit.com",
    "label": "鬼畜,思杰马克狗",
    "keyword": null,
    "id": 183,
    "indexId": "Post:183"
  },
  {
    "title": "Pixologic ZBrush 2018 破解版",
    "author": "懒得勤快",
    "content": "Pixologic ZBrush自从1999年获奖以来，它已经成为2D或3D数字建模世界革新速度最快的领跑者。运用其直观的特性以及强大的雕刻和绘图能力，ZBrush使得数字艺术家和专家冲破了创造力的屏障。大量的娱乐产业的奖项以及行业艺术家和名人都见证了ZBrush以其革命性的能力绘制贴图并创作出杰出的角色，在二维和三维领域创建模型和环境纹理,快速而直观，完全不受常规的技术限制。ZBrush 为数字雕塑树立行业标杆，强大功能使您能够在提供即时反馈的实时环境下，使用可定制笔刷系统完成虚拟黏土形状、纹理和绘制。在使用 ZBrush 时，您将获得与世界各地电影工作室、游戏开发人员、玩具/藏品制造商、珠宝设计师、汽车/航空设计师、插图画家和艺术家所用工具相同的卓越体验。它也是越来越多的网络公司、艺术家、设计师、建模师、插画师、2D/3D整合爱好者工作流程当中的关键元素，也可以革新地应用在其他产业、商业部门。ZBrush的创造性可以表现在每天生活的很多方面：3D打印玩具制造业、牙科、科学与医学、珠宝设计等等。唯一正版官网：http://pixologic.com/上面是此软件唯一正版官网，国内垃圾代{过}{滤}理商的官方请不要去下载了，国内假官网：http://www.zbrushcn.com/ 下载地址附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!官方安装包：链接: https://pan.baidu.com/s/1RWUwaGB-43w8qEmZJWtzPg&nbsp;提取码: a2or破解补丁：稀缺资源统一下载地址页",
    "postDate": "2019-01-30T23:40:45.3340431+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "ZBrush,思杰马克丁",
    "id": 1362,
    "indexId": "Post:1362"
  },
  {
    "title": "条码标签设计软件 NiceLabel 2017 v17.2.0 Build 1825",
    "author": "懒得勤快",
    "content": "NiceLabel 2017是一款强大的条形码标签设计与打印软件，现全球已超过百万家公司使用它来简化标签设计，消除标签错误及提高生产率。它具有强大的商业条码标签设计功能，可快速创建和打印标准或定制的标签，可使标签打印流程自动化以此消除人为差错，并可确保标签和品牌的始终一致，同时 NiceLabel 2017 还可帮助您集中化的控制标签条码打印流程，在这里您可集中控制、消除错误和简化标签专业。新版 NiceLabel 2017 已将 Express 和 Standrad 两个打印产品合并，新增的打印模块彻底简化了旧版的标签打印流程，并显著提高了打印生产率和准确性，现在您可使用“全功能一体”的打印表单，打印表单包含所需的全部 UX 对象，如数据输入字段、数据库导航和选择、打印机设置以及整个打印作业的打印预览等等，同时新版提高了更高的功能性，即使是初次使用的用户，也可在几分钟内设计出专业的标签，并可设置动态数据，比如变量、函数、数据库等。此外，NiceLabel 2017 供了更多针对多用户版本的许可灵活性，多用户版本可以在任何数量的工作站上使用，多用户许可证只限制打印机数量，而不是用户数量。采用下一代许可技术，不需要使用许可证管理器或单独的服务器，不需任何配置或维护即可工作。软件特点快速设计和打印条码标签，而无需 IT 帮助您快速上手和完成工作所需的全套工具NiceLabel Design and Print 可帮助您快速设计标签和建立高效的打印流程，免除您每天担心打印出错，而使您可以专注于业务运营。快速设计专业标签，无需在培训和编码上进行投资。标签设计今天就上手和完成标签设计新 NiceLabel Designer 设计器提供人们熟悉的 Microsoft Word 风格用户体验。这意味着，任何人都可以快速设计专业标签，而无需条码知识或设计器培训。标签打印准确、一致、无差错地打印采用动态数据打印标签有别于打印其他类型的文档。标签系统必须能让生产和仓库工作人员快速、无差错地打印。NiceLabel 提供了一个全功能打印表单，帮助用户打印精确的标签，而无出错风险。获取 NiceLabel Designers您需要的所有标签设计对象NiceLabel Designer 包括您需要的能同时满足公司内部要求和客户要求的所有对象：文本、图形、线条、框、条码和 RFID。条码和 RFID 编码添加任何类型的线条或 2维条码到标签上：GS1-128 、DataMatrix、QR 码或 70 种其他类。NiceLabel 始终保持与最新标准同步，以确保法规遵从性。GS1 及其他标准的向导其他解决方案中，设计注入 GS1 运输标签时要求具备标签专业知识。NiceLabel 提供了一个简单的向导，不需要知识和培训投入，就能确保合规性。下载地址附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!复制链接，用IDM下载https://attachments-cdn.shimo.im/7JwoAifo9bUDwAfE/NiceLabel_2017_v17.2.0.1825.7z",
    "postDate": "2019-01-30T23:40:45.334105+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "思杰马克丁,条码",
    "id": 1357,
    "indexId": "Post:1357"
  },
  {
    "title": "Guitar Pro 7 中文破解版",
    "author": "懒得勤快",
    "content": "Guitar Pro 7中文破解版是一款倍受吉他手喜爱的吉他和弦、六线谱、BASS四线谱绘制、打印、查看、试听软件，它也是一款优秀的MIDI音序器，MIDI制作辅助工具，可以输出标准格式的MIDI。GP的过人之处就在于它可以直接用鼠标和键盘按标准的六线谱、四线谱进行乐谱输入、查看、打印和试听（可以实时、自动滚屏、多种模式的显示单声部或乐曲总谱），在做弹拨乐器的滑音、倚音、推弦、揉弦、泛音、摇把、闷音、琶音、分解和弦、BASS打弦等方面有绝对的优势。Guitar Pro 7在吉他和弦、把位的显示、推算、查询、调用等方面，也异常方便、简洁、直观和浩瀚，这是同类软件所根本无法与之相抗衡的一大显著特点。软件提供对包括简、繁体中文在内的25种不同的语言的支持。新版本增加了一些打印时针对个人用户的设置；对吉他面板（操作区）播放时的状态做了一些较大的改进，可以选择播放时显示当前音符，下一个音符，当前和弦图表，当前小节的音符；增加了对4弦乐器、5弦乐器、7弦乐器的和弦图表支持和鼓谱符号的输入；歌词输入的改进提供了更多的方便等等。打谱教程（简单易用）：步骤一：创建新文件首先，打开Guitar Pro破解版，点击工具栏上的创建新文件按钮创建新文件按钮，或者选择文件&gt;创建新文件,或者使用快捷键ctrl+N，这将关闭当前的文件，并创建一个新文件，并打开谱表信息窗口进行用户设置。步骤二：谱表信息设置点击文件按钮会弹出乐谱信息，或者使用快捷键F5也可以打开乐谱信息窗口。乐谱信息窗口可以输入一些有关乐谱的基本信息，比如在乐谱信息栏可以填写乐谱标题/副标题/艺术家以及其他信息等等。点击工具栏上的音调符号设置按钮或者选择小节—音调符号可以打开音调符号窗口，在这里可以设置演唱音色和大小调式，不过这只对五线谱的显示有影响，对六线谱没有影响。点击工具栏上拍号按钮,或者选择小节-拍号可以打开拍号窗口,这里设置乐谱的拍号，例如：2/2,2/4,3/4,4/4,6/8/12/8(4/4是默认），如果这些都不符合，也可以自定义设置。步骤三：新增音轨点击工具栏上的新增音轨按钮,或者选择音轨&gt;新增，或者使用快捷键shift+ctrl+insert可以增加一个新的音轨，此时会出现新增音轨窗口，需要选择新增音轨的类型和位置，接着按照提示继续就可以了。激活码_注册码1、NklOVDI4Nzc2OTEAAAAAADZJTlQyNklOVDI2SU5UMgCvM36mNZoSIP1GK；2、TcWJS0srbsXNfJdq5L2Dyufytyyuu1V9koIySWu5qSJGEnbxHQpW+7o8FGF1D；3、DI4Nzc2OTEAAAAAADZJTlQyNklOVDI2SfJdq5L2Dyufytyyuu1V9koIySWu13f；下载地址附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!官方安装包：链接: https://pan.baidu.com/s/1p9UQAtQOzOZOf-BI11MosQ&nbsp;提取码: 2v2k破解补丁：稀缺资源统一下载地址页",
    "postDate": "2019-01-30T23:40:45.3341672+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "Guitar,思杰马克丁",
    "id": 1360,
    "indexId": "Post:1360"
  },
  {
    "title": "条码标签打印 BarTender 2016 R7 11.0.7.3146 Enterprise Automation企业自动化版",
    "author": "懒得勤快",
    "content": "BarTender 可以说是一个超级强大的条码标签打印软件，现在很多商品上面都会有二维码这就让很多大型企业小型企业都会使用到条码标签打印软件，BarTender可以说是企业的首选，BarTender作为专业的条码标签打印软件，它的功能一直在改进和增强，尤其在标签、条形码、证卡和RFID 标记的设计和打印领域，应用十分广泛。软件特点创建和自动制作标签、条形码等的软件BarTender®&nbsp;企业自动化版专为需要与打印环境进行完全连接和控制的企业而设计，旨在提供最强大的功能合集，包括与 SAP 和 Oracle 的集成，以及集中管理打印、安全和管理。满足您最苛刻要求的最强大软件BarTender 企业自动化版可扩展最复杂的打印环境，具有无与伦比的企业系统连通性，以及对完整设计和打印系统的可靠控制。集中控制提高效率和可信度BarTender 的全面控制功能使得企业能够跨站点和区域，对其设计和打印操作进行集中监视、管理和保护。使用 Librarian 优化工作流程BarTender Librarian 使人数众多的设计师、管理员和其他用户能够共同合作，安全地管理标签格式及其他文件的存储和修订。Librarian 可帮助您更好地管理任何标签打印系统，尤其在监管程度很高的环境（如医疗和医药）和安全程度很高的环境（如军事和化学）中更具价值。与现有业务系统集成使用 BarTender Integration Builder，您可以创建高度可定制的集成，以将 BarTender 的打印功能与几乎所有企业业务运营无缝连接。此强大的服务使您能够执行企业级任务，包括：在“触发”事件（如收到电子邮件、保存文件或修改数据库）时自动启动打印。\n通过&nbsp;TCP/IP、UDP&nbsp;或&nbsp;HTTP&nbsp;与客户建立连接和通信。\n执行基本的文件操作，如移动、重命名、删除或复制。\n凭借对&nbsp;SAP、Oracle&nbsp;或&nbsp;IBM&nbsp;WebSphere&nbsp;连通性的直接支持，实现直接与&nbsp;ERP&nbsp;系统集成。具有 Intelligent Templates 实现无与伦比的多功能性和控制BarTender 企业自动化版提供 BarTender 所有强大却易于使用的设计功能，包括独有的 Intelligent TemplatesTM：利用根据条件打印，通过单一设计，制作各式各样的标签，而无需再对每一个标签维护一个文档的问题感到头痛。\n根据单个数据源或数据库字段或者根据多个条件，指示模板、图层，甚至个别对象何时打印，轻松支持复杂的打印方案，一切都不需要编写脚本。\n锁定强制性内容，以便其他设计人员无法对其进行更改。\n将内容打印到安全证卡的特定面板上，包括单色黑、紫外荧光和叠加面板。\n让&nbsp;BarTender&nbsp;的智能向导带领您完成关键的设计决策，以最大程度改善打印性能并符合重要的标准。\n使用自己的字体或内置于打印机的字体。\n无论是简单的序列号还是复杂的自定义序列化序列，都可以轻松生成。\n使用富文本格式，以任何方式格式化文本。\n使用高质量图像处理控件，增强导入的图形，包括亮度、对比度、饱和度、色调、锐度、平滑度和剪裁。\n通过导入旧的设计作为指引，轻松重新制作旧的标签。\n链接到外部图形，以启用动态更改。经过 SAP 认证、Oracle 验证使用户能够从 SAP、Oracle 和其他业务系统，打印标签以及执行其他任务，而无需了解 BarTender 在执行打印。基于浏览器的界面，可通过网络轻松部署和打印通过使用户能够从任何浏览器，只要几下点击，即可选择设计、完成打印时数据表单，并启动打印作业到互联网上的任何打印机，将打印基础结构扩展到防火墙之外。Visual Basic Script Editor 以实现轻松管理VB Script Editor 可以让您轻松在文档中实现不同脚本的导航浏览；在编写自己的代码时，访问受支持的代码片段为您提供帮助；访问特定于应用程序的 VB 脚本对象、属性和函数等。企业级打印灵活性通过让&nbsp;BarTender&nbsp;从&nbsp;SAP&nbsp;和&nbsp;Oracle&nbsp;系统、Excel&nbsp;文件、文本文件和各种数据库拉出数据，最大程度减少打印时数据输入。或者，设计自己的表单，以在打印时轻松输入数据。\n从专用的&nbsp;Print&nbsp;Station&nbsp;界面，轻松选择、预览和打印标签和证卡。\n以单一批次，打印多个标签格式，无论是从&nbsp;BarTender、Print&nbsp;Station&nbsp;还是&nbsp;Windows&nbsp;资源管理器。\n打印到任何真正的&nbsp;Windows&nbsp;打印机驱动程序，并使用免费的&nbsp;Drivers&nbsp;by&nbsp;Seagull，利用标签和证卡打印机的特殊功能，以获得优化的性能。随时随地按需免费提供支持我们的全球办公室可共同对所有 BarTender 版本提供每工作日每天 24 小时的免费电话和电子邮件支持。下载地址附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!官方安装包：https://pan.baidu.com/s/1tgGojgOuLrQUfjXmvUza_Q破解补丁：稀缺资源统一下载地址页",
    "postDate": "2019-01-30T23:40:45.3342421+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "思杰马克丁,条码",
    "id": 1356,
    "indexId": "Post:1356"
  },
  {
    "title": "XMind 8 Update8 Pro 直装破解版",
    "author": "懒得勤快",
    "content": "XMind不仅是一款易用且功能强大的思维导图软件，也是一个开源项目。XMind以构建一个社区向全球提供领先的跨平台思维导图和头脑风暴软件为目标，以帮助用户提升效率。XMind公司是XMind开源项目的主要代码贡献者，与此同时，我们欢迎更多的开发人员投入到XMind社区中。相比于XMind开源项目，XMind增强版/专业版则是专有软件。它们为用户提供XMind开源版本所不具有的高级功能，包括甘特图、演示、头脑风暴、风格和导出功能等。借助于这些高级功能的应用，XMind进一步地激发其创造力，提升效率，最终获得稳固的竞争优势。除此以外，XMind还提供免费的在线分享服务。用户能够以“秘密图、非公开和公开”三种方式存储思维导图和向全球用户分享。xmind 8 功能特点：1.用户界面升级用户界面的升级是有史以来最大的一次改动。带有全新大图标的工具栏、更加清晰的窗口风格和属性视图、重新设计的标签栏、以及改进的图标和剪贴画库。2.主页控制面板每次打开XMind，您都可以看见全新的主页控制面板。通过面板，您可以选择导图结构、选择一个漂亮的主题风格、打开最近使用的文件来创建思维导图。3.甘特图在“甘特图”视图中，您可以直接添加/修改任务信息，包括开始/结束日期、被指定人、优先级和进展。4.信息卡XMind提供直观独特的方法显示详细信息，每个主题的信息卡中，允许您显示或隐藏标签、备注、超链接和任务。5.评论可以将XMind文件发送给同事或朋友，征求他们的意见，这样他们便可以在您的思维导图上进行评论，而不是直接修改导图。6.标注标注是插入附加文本的一种很棒的方法，在XMind里，标注不仅是一种形状，也是附加到主题的真正附件，它还可以繁衍自己的子主题。7.导出/打印导图大纲以文本、PDF或MS Word文件格式导出思维导图大纲，得到一个宽泛的思维导图概述，以备后续使用。这有利于节省时间和提高生产力。通过打印大纲，思维导图会变成一系列想法的树状图形。8.保存到Evernote将导图保存为Evernote备注并共享，以便更方便地与其他人协作。可以将导图保存到最流行的笔记工具，作为大的图像、大纲文本，甚至.xmind文件本身。9.时间轴它可以按照时间顺序和主题趋势来展示事件列表。还可以使用它来帮助团队成员追踪项目的重要阶段和时间进度表。10.主题&amp;字体XMind里包含10种字体，可以神奇般地美化您的思维导图，所有字体都是开源且跨平台的，能够确保你的思维导图在Mac/Windows上都能看起来很漂亮。十多个新增的主题能给所有人带来惊人的体验，可以使用高级主题编辑器设计自己的主题。最后如果你是企业用户，请支持正版！！！！！个人免费用用就行了，别TM无耻的拿到淘宝上去卖，到底是多缺钱？要不要劳资赏你几块？下载地址：2018年7月1日，xmind官方澄清该软件与思杰马克丁再无“合作”关系。思维导图 XMind 官方澄清与苏州思杰马克丁代理合作主程序下载：http://dl2.xmind.cn/xmind-8-update8-windows.exe破解补丁：稀缺资源统一下载地址页直装破解版(复制使用IDM下载)：https://attachments-cdn.shimo.im/tsKVmiZBwE4m0WhZ/XMind_8_Update_8_%E4%B8%93%E4%B8%9A%E7%A0%B4%E8%A7%A3%E5%AE%8C%E7%BE%8E%E7%89%880921_2.exe",
    "postDate": "2019-01-30T23:40:45.3343617+08:00",
    "email": "admin@masuit.com",
    "label": "xmind",
    "keyword": "XMind,思维导图,xmind8 update8 破解版",
    "id": 62,
    "indexId": "Post:62"
  },
  {
    "title": "FL Studio 20 免安装破解版 + 破解补丁",
    "author": "Yamato Ryou",
    "content": "FL Studio 简介:前身为 FruityLoops, 一款由 Image-Line 公司开发的数位音频工作站, 是以样式 (Pattern) 为元素的编曲软件. 可使用 VST; VSTi 插件, 还可以作为 ReWire 客户端. FL Studio 非常适合制作电子音乐.FL Studio 免安装版是面向因各种原因无法运行原版装程序的用户及初学者准备的.本文会放出多个免安装版及破解补丁的下载地址, 以下说明文档基本通用, 差异部分请于下载后阅读压缩包内的说明文档.破解补丁仅适用于原版.FL Studio 20.0.5.681 免安装版说明文档:1. 此版本同时包含 32 / 64 位 FL Studio 程序, 但 64 位 FL Studio 只能运行于 64 位 Windows.2. 此版本面向新手以及无法运行安装程序的用户.3. [重要] 免安装版与其它版本 (包括原版; 历史免安装版) 不能共存. 要使用此版本, 请先撤消部署并删除上一版本的文件.4. [重要] 部署程序可能会被某些杀毒软件误报为病毒, 此问题作者无法解决, 请自行决定是否继续使用.5. [重要] 除非免安装版集成汉化, 否则切勿随意为免安装版安装汉化补丁, 以免被强制降级而影响软件功能.6. [重要] 由于官方不再为 FL Studio 集成下载管理器, 因此所有 Maxx 系列插件 (Pitcher 除外) 现在可以直接从插件的预置列表中选择. 若仍然没有出现请等待约 30 秒后重新打开插件再试.简介:1. 基于 FL Studio 20.0.5.681 官方安装程序整理, 集成 R2R 破解, 无任何阉割或精简.2. 整合 Shared 目录组件; 下载管理器组件到 FL 目录, 方便停用后一次删除.3. 集成了 ASIO4ALL 2.14 与 FL Studio ASIO 作为可选 ASIO 驱动.4. 集成离线帮助文档并默认启用, 方便无法联机的用户参考.5. 部署程序现已支持检查更新. 当连接到 Internet 且有可用的更新时, 部署程序会于运行时通过日志提示用户.&nbsp;由于网站不可访问,&nbsp;检查更新功能现已失效.如何解压缩及使用:1. 解压缩文件夹到任意路径.2. 解压完毕后转到该文件夹, 运行部署程序.3. 单击 &quot;开始&quot; 进行部署.4. 退出部署程序, 从桌面或 &quot;开始&quot; 菜单找到相应的快捷方式.5. 因更新或其其他原因要停止使用的, 再次运行部署程序, 单击 &quot;停用&quot;.6. 停用后若不再需要免安装版, 则直接删除整个文件夹. 删除文件夹前请先检查 \\Misc\\Shared Data\\FL Studio 是否有要保留的文件, 如果有, 请先移动这些文件.7. 推荐随部署程序下载最新的更新.&nbsp;由于网站不可访问,&nbsp;检查更新功能现已失效.注意事项:1. 在任何情况下运行部署程序时必须关闭 FL Studio.2. 在安装其它版本前请撤消部署或卸载, 此操作会删除 FL Studio 的设置和导入的注册信息.3. 你的第三方插件; 音色库等额外内容切勿放置在免安装版文件夹, 否则影响撤消部署的后续工作.4. 此版本的压缩文件包含一个数字签名, 用于验证压缩文件来源以及是否被修改. 在文件属性的 &quot;数字签名&quot; 选项卡中可以查看相关信息.5. 原演示工程已被替换为 Yamato Ryou 的 Chiptune 工程. 工程仅作为技术展示, 于部署完毕后首次运行时打开.6. 32 / 64 位 FL Studio 共用 FLP / FSC / FST 扩展名, 要立刻默认使用 64 位 FL Studio 打开工程文件, 请手动在部署程序中设置文件类型关联. 否则部署程序将默认将上述扩展名关联到 32 位 FL Studio.7. 由于集成的 ASIO 驱动是免安装版的一部分, 因此会随撤消部署而被卸载.8. FL Studio 已默认更改用户数据文件夹, 在免安装版中的路径为 \\Misc\\Shared Data\\FL Studio.9. 运行 ignorehash.bat 可使部署程序于本次运行时不校验 FLEngine.dll 的哈希值, 从而允许关键文件被修改的情况下撤消部署.10. 已破解的情况下请勿登录 Image-Line 账户, 否则因此造成账户被限制等不希望发生的后果作者概不负责.11. 免安装版无法对 FL Studio 任何已知问题或 bug 负责.12. 免安装版只能为计算机中当前用户账户部署, 切换其它账户使用可能会出现设置被重置; 授权丢失等问题.13. 免安装版文件夹内只有 FL Studio 相关文件时可用于移动存储介质, 例如 U 盘或移动硬盘, 但注册表中的设置无法随时迁移.部署程序在线扫描结果:各个版本的部署程序扫描结果, 请参阅各个版本压缩包内的说明文档.Maxx 系列插件包括:BassDrum; Drumaxx; Drumpad; Groove Machine (未集成); GMS; Hardcore; MiniSynth; Morphine; Pitcher (无预置支持); PoiZone; Sakura; Sawer; Toxic Biohazard已知问题:1. TS404 已不可用.2. DX / DXi 插件支持已不可用.3. 64 位 FL Studio 无法使用 Wasp / Wasp XT / Soundfont Player.4. FL Studio 20 for Windows 已逐渐放弃兼容早于 Windows 7 (6.1.7600) 的操作系统, 在这些系统下你仍然可以部署, 但使用过程中会出错.其它可用的运行参数详见 \\Misc\\Shared\\Start 文件夹中的快捷方式.FL Studio 20.x 破解补丁 (R2R, Windows) 使用说明:1.&nbsp;运行 FL_Studio_20_xxxxxx_Patched.7z.exe, 将所有内容解压到 FL Studio 安装目录的上一级 (即 Image-Line 文件夹, 适用于未更改 Program Files 目录的用户), 覆盖所有文件及文件夹.2.&nbsp;运行 ImageLine_RSA2048_Keygen.exe, 键入 Fuck CJMarketing, 单击 Register.FL Studio 20.x 破解补丁 (HEXWARS, macOS) 使用说明:1.&nbsp;下载后解压到桌面, 运行程序, 在 Name 栏键入 Fuck CJMarketing, 然后点按 Generate. 生成的注册文件将自动保存到桌面.&nbsp;2.&nbsp;从程序坞或 Launchpad 运行 FL Studio, 按 F10 打开设置, 然后点按 About.3.&nbsp;在 About 窗口左下角点按 Unlock with file, 找到桌面上的注册文件, 点按 &quot;打开&quot;.4.&nbsp;点按 Yes 或 No 保存或不保存当前工程文件, FL Studio 将重新启动.下载地址汇总:版本操作系统下载地址注释FL Studio 20.0.5.681 免安装破解版Windows谷歌网盘&nbsp;|&nbsp;微软网盘&nbsp;|&nbsp;私有云FL Studio 20.0.4.629 免安装破解版Windows谷歌网盘&nbsp;|&nbsp;微软网盘&nbsp;|&nbsp;私有云部署程序在线扫描结果:&nbsp;VirScan&nbsp;|&nbsp;VirusTotalFL Studio 20.0.3.532 免安装破解版Windows谷歌网盘&nbsp;|&nbsp;微软网盘&nbsp;|&nbsp;私有云FL Studio 20.0.2.477 免安装破解版 (修正)Windows谷歌网盘&nbsp;|&nbsp;微软网盘&nbsp;|&nbsp;私有云FL Studio 12.5.1.165 免安装破解版Windows谷歌网盘&nbsp;|&nbsp;微软网盘&nbsp;|&nbsp;私有云FL Studio 20.0.5.681 破解补丁 (R2R)Windows私有云FL Studio 20.0.4.629 破解补丁&nbsp;(R2R)Windows私有云FL Studio 20.0.3.532 破解补丁&nbsp;(R2R)Windows私有云FL Studio 20.0.2.477 破解补丁&nbsp;(R2R)Windows私有云FL Studio 20.0.2.25 破解补丁 (HEXWARS)macOS私有云FL Studio 20.0.5.91 破解补丁 (HEXWARS)macOS私有云FL Studio 12.5.1.165 破解补丁&nbsp;(R2R)Windows私有云适用于&nbsp;Windows, 适用于 12.5.0.59; 12.5.1.5; 12.5.1.165FL Studio 注册文件&nbsp;(R2R)Windows私有云适用于&nbsp;Windows, 注册文件适用于 11.0.1 ~ 12.4.2.33联系作者:Telegram&nbsp;|&nbsp;豆瓣小站FL Studio 20 破解补丁主站：http://fuckcjmarketing.com/FL/flreg.html",
    "postDate": "2019-01-30T23:40:45.3345456+08:00",
    "email": "yamatoryou@hotmail.com",
    "label": "FL Studio,思杰马克丁",
    "keyword": null,
    "id": 1373,
    "indexId": "Post:1373"
  },
  {
    "title": "Mac平台虚拟机 Parallels Desktop v14.0.1 中文直装破解版",
    "author": "懒得勤快",
    "content": "Parallels Desktop for Mac是功能强大灵活度高的虚拟化方案，无需重启即可在同一台电脑上随时访问Windows和Mac两个系统上的众多应用程序。从仅限于PC的游戏到生产力软件，Parallels Desktop都能帮您实现便捷使用。Parallels Desktop 是一款专业的Mac虚拟机，可在Windows 与Mac OS 应用程序之间随意拖放文件并直接从Mac dock 启动Windows 程序，能够在Mac上以最便捷、快速、高效的方式运行Windows！Parallels Desktop 13 for Mac完全支持macOS Sierra，提供数十种工具供用户使用，Parallels Desktop 13 for Mac 提升了性能，清理驱动器、保护私人文件、下载视频、制作 GIF 等。针对 macOS High Sierra 和 Windows 10 Fall Creators Update 进行了优化。Parallels Desktop for Mac 功能简介简易体验便捷安全向导：便捷的虚拟机安装向导可直接通过系统镜像包及U盘来安装系统，且能自动查找操作系统无需担心Mac上是否有光驱，也可手动选择媒介类型范围。并保证Mac上和Windows虚拟机中所有一切程序的安全。多虚拟机支持：Windows、Linux、Chrome OS、Mac OS、Android OS等。 其Linux虚拟机整合可实现共享应用程序、共享配置文件和自动更新 虚拟机管理工具：通过图形模式查看虚拟机使用的 Mac 处理器与内存来监控 Mac 资源。整合共享设备共享：进一步集成整合Windows与Mac，无缝共享Windows与Mac之间的蓝牙设备，Mac废纸篓与Windows回收站整合，只需要管理一个。超强的安全稳定性：完美的整体性能与超强的稳定性：电池寿命更长、显卡可达 1GB、通过Intel AES-NI加速虚拟机加密，所有的Windows程序都会进行安全加密。超人性化手势共用：Mac和Windows深度整合，可以使用Mac的查字典手势在Windows中查字典。Safari中引用IE按钮：当网页在 Safari 中运行不好时，点击一下”IE“图标就可以从Safari切换到Internet Explorer中显示该网页。拖放附件到 Outlook：轻松地从桌面拖放文件到Dock图标用以在Windows的Outlook中作为新邮件的附件。Parallels Desktop for Mac 新增功能1、全面支持最新的macOS Sierra系统这个版本的应用将全面支持最新的macOS Sierra系统，让用户可以在第一时间里享受虚拟机软件的应用，所以已经升级mac操作系统的用户，这个版本更适合。2、一键式工具为了使日常任务尽可能的简化，Parallels Desktop13作出了这样一套工具，无需复杂的操作只需点击按钮就会弹出一个工具集，可进行：截屏、录音、防睡眠等操作，提高了用户操作的便利性。3、性能提升与之前的版本相比较，访问共享文件夹的速度提高了25%，挂起速度提升60%，拍快照的速度提升25%，电池的续航时间延长10% 以上，这些提升使虚拟机运行更加流畅。4、可通过Acronis True Image进行快速增量备份一年期的Acronis True Image免费订阅，其中包含多达500 GB的云备份存储容量和快速增量备份，这可以让用户能够更好地存储文件，且不会影响系统空间大小。5、安全性提高在Mac和Windows上轻松快速地存档文件，并对文件进行密码保护。6、macOS Sierra系统优化存储插件集成即将问世的macOS Sierra存储优化功能。你可以在本机查看控制虚拟机Parallels Desktop VM存储。7、支持将密码存储在Mac密钥链中你可以在本机mac密钥链中存储并管理你所有密码，其中包括：Windows、Internet Explorer和Microsoft Edge，这样会更加方便使用。8、Office 365无缝集成无缝集成可以实现在本地Windows Office应用程序中打开Safari中的Word、Excel或PowerPoint文档。9、“请勿打扰”模式通过临时禁用所有干扰(包括应用程序和OS通知)并防止您的Mac进入休眠状态来提高你的使用效率。10、Finder中的EXE文件图标现在Windows EXE文件图标显示在Finder中。11、计划Windows 更新计划您想要进行Windows更新的时间，并避免烦人的通知和Windows意外重启。12、Retina支持Retina显示屏支持智能调整大小，各个显示屏具备独立的屏幕分辨率，可以帮助mac Retina显示屏连接额外的外部显示器。13、随时可用您可以随时准备使用Parallels Desktop。打开Windows应用程序或文档的速度提升高达三倍(即使您已经退出 Parallels Desktop)，无任何其他CPU耗用。14、闹钟、秒表和计时器一套方便快捷、简单易用的时间管理工具，使您始终保持高效、跟进工作日程。Parallels Desktop for Mac 工具1.不进入休眠模式，防止电脑进入休眠模式并防止显示器变暗。通过禁用允许电脑进入休眠模式的设置来确保任务或演示不会被中断。2.转换视频，为 iPad 或 iPhone 优化您的自制影片或电视节目。3.锁定屏幕，立即锁屏，以防止其他人未经授权访问您的电脑—无需等待采用密码保护的屏幕保护程序启动。4.清理驱动器，使 Mac 保持整洁，确保以最大速度运行。扫描、检测、自主选择要删除的内容。5.隐藏桌面，在进行文档演示、共享或录制屏幕或截取屏幕截图时，隐藏桌面上的所有文件、文件夹和其他图标。6.存档文件，一键即可压缩文件以使用更少的存储空间。取消存档任何已存档的文件、RAR、zip 等。7.制作 GIF，从视频轻松创建和自定义动画 GIF。调整开始点和结束点，添加字幕，选择帧速率和大小并立即保存到桌面上。8.下载视频，从互联网下载您最喜爱的视频：Facebook、YouTube、Vimeo 等。9.请勿打扰，避免受到干扰，以便您可以专注于当前任务。激活后，将禁用所有通知和 Dock 应用程序动画。破解说明直接安装即可，内置了破解激活文件序列号无需注册激活下载地址链接：https://pan.baidu.com/s/1Aa0-po4q5dpnwjQPVuP3jw&nbsp;提取码：9gynParallels Desktop Mac 公司取消思杰马克丁国内代理权",
    "postDate": "2019-01-30T23:40:45.3346537+08:00",
    "email": "admin@masuit.com",
    "label": "思杰马克丁,虚拟机,mac",
    "keyword": null,
    "id": 1232,
    "indexId": "Post:1232"
  },
  {
    "title": "Logo制作——硕思logo设计师Sothink Logo Maker Professional v4.4 Build 4625",
    "author": "懒得勤快",
    "content": "Sothink Logo Maker提供了七种类别的模板，包括Business、Technology、Organization、Fashion、LetterBased、Badge、Festival等(近300个模板)，具有强大的颜色和文本效果设置，可自定义很多细节，另外一个特色功能就是提供680多种的配色方案，每一个图形都可以轻松设置色彩方案。为自己的网站或者博客设计一个令人印象深刻而又能传达信息的LOGO，是每一个小站长梦寐以求的事。但对于一些新手来说设计与制作却是如此困难。那就马上来尝试一下Sothink Logo Maker吧，它能免帮你在短时间内设计出一个具有专业水准的 LOGO 。而且Sothink Logo Maker对中文支持良好，从此LOGO设计不再是那些专业标志设计师的专利啦。软件功能Make Your Business LogoPut Your Logo On Business Card, T-shirt, anywhereCreate The Logo for Your App, Mobile GamesGet Your Logo in 1 Minute NowNew build is released with new templates软件特点Master Color SchemesOver 2000 preset color schemes for any DIY design. You choose a dominant color and a pattern in Color Wheel, we list four-color palettes to colorize your logo.Wide Variety of Logo EffectsUtilize rich effect styles from shadow, bevel, to gradient, with one-click application. Easily make text logos by converting text into shapes. Stylize your logo!Expert Drawing ToolsDraw logo elements using hand-drawing tools — pen, pencil, brush and more in a WYSIWYG interface. Create a unique logo for business or personal use.Free Logo ResourcesProvide 450+ free logo templates and more than 5000 logo resources. Also support importing PNG/JPG/BMP/GIF/ SVG/SWF files for use in logo designs.Friendly User ExperienceOffers user-friendly interface that facilitates easy logo creations. Few mouse clicks quickly duplicate logo elements and styles with smart paint tools.Mix &amp; Match SkillsExclusive hollow and split tools adds more diversity to logo design choices. Design from monogram, rainbow texts, to doodle, feel free to mix and match all effects.下载地址附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!点击前往稀缺资源统一下载地址页",
    "postDate": "2019-01-30T23:40:45.3347538+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "思杰马克丁,硕思logo设计师",
    "id": 1354,
    "indexId": "Post:1354"
  },
  {
    "title": "3D渲染 KeyShot Pro v7.3.37 for Windows",
    "author": "懒得勤快",
    "content": "神奇的实时3D渲染和动画制作软件—Keyshot 7已经推出，新版本带来了强大的功能改进，提供全新的材质库和室内照明模式，该软件渲染速度从始至终一直很快且操作简单，本次又采用的新算法又再次提高了工作流程效率。Keyshot Pro 7是一个互动性的光线追踪与全域光渲染程序，具备了创建快速、准确、神奇的视觉效果所需的一切功能，提供500多种材料预置和50+ HDRI照明环境，支持超过20种的3D文件格式（Catia/Solidworks/Rhino等），支持第三方应用插件程序（ Creo / Solidworks/ Rhino等），以实时的工作流程为特色，即时查看渲染和动画的形成，减少了创建完美照片的时间，从科学准确的材质和环境预设到先进的材质编辑和动画，无需复杂的设定即可产生相片般真实的3D渲染影像。软件特点提高工作流程效率KeyShot软件的渲染速度从始至终一直很快，而且操作简单。KeyShot 7延续了这一点，让您的工作流程更加流畅，从导入到最终渲染，这些功能能够让您前所未有地快速创建视觉效果。室内照明模式KeyShot 7自带6种新的照明模式，由全新的照明算法提供技术支持，可以设置或调整为室内照片或产品照片优化的场景照明，切换到性能模式，或者通过点击几下按钮，使用自己自定义的预先设置。增进材质控制有了KeyShot科学准确的材质，很容易获得用户想要的外观。KeyShot 7通过先进的编辑功能和更多的材质选项，能够让您更好地控制材质，实现扩展材质和纹理的可能性。神奇新特性当用户希望自己的工作流程更多地涉及创建过程时，KeyShot 7新增的功能提供了无与伦比的方法来减少那些耗时的步骤，自动处理任务，完全消除了后期处理过程。强大的功能改进有了KeyShot 7，便拥有了KeyShot Pro中更加强大的KeyShot HD和KeyShot动画的无限分辨率，新增的动画和KeyShotVR功能允许您创建视觉效果，并以从未有过的方式将它们呈现出来。下载地址附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!复制链接，用IDM下载https://attachments-cdn.shimo.im/yXwC4kphjVQu06rH/KeyShot_Pro_7.3.37.7z",
    "postDate": "2019-01-30T23:40:45.3348633+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "思杰马克丁,实时3D渲染",
    "id": 1355,
    "indexId": "Post:1355"
  },
  {
    "title": "专业打谱软件Overtrue 5.5.4 破解版",
    "author": "懒得勤快",
    "content": "Overture是GenieSoft公司出品的专业打谱软件，它能提供各种五线谱上的记号，整理谱面及输出打印。在写谱的时候当然可以边听边修改。而且打印效果远强于图片格式！&nbsp;Overture在国内由流行钢琴网首推并迅速发展壮大，是目前最流行的打谱软件之一。流行钢琴网是专业的钢琴网站，拥有大量Overture制作的琴谱并免费提供下载，出版了十余本钢琴相关图书，在海内外都具有相当高的知名度。软件简介：1、功能强大Overture除了五线谱中输入和编辑音符和各种记号（包括六线谱和打击乐）、按照较高规范度和整洁度调整谱面、用图解窗口制作各种高级音效等打谱软件的主要功能外，还具备双手拍号不同、分叉符干式和弦、特殊谱号（如倍低音、低八度高音）等功能，功能更为强大；2、上手容易Overture的界面设计十分简单，功能布局一目了然，即便是新手上手也十分容易。3、强大MIDI效果制作器该功能是Overture的亮点功能之一。用户可通过此细致调节力度、速度、踏板、弯音、揉弦等逼真的音效，在许多钢琴网上都有大量Ove格式的琴谱或由Overture导出的图片格式琴谱。软件简介：1、在五线谱中输入和编辑音符和各种记号(包括六线谱和打击乐)；2、按照较高规范度和整洁度调整谱面、用图解窗口制作各种高级音效；3、Overture可进行MIDI效果制作；4、将MIDI格式的文件导入软件进行五线谱的编辑；5、用VST音色插件以交响乐级别播放乐谱；6、将制作出来的五线谱导出为MIDI音频文件或PDF格式的文档；7、双手拍号不同8、分叉符干式和弦9、特殊谱号（如倍低音、低八度高音）汉化破解说明更改语言的方法：点击主界面的options选项，然后依次点击preference-general-language-Chinese Simplified-done破解补丁使用方法：在Overture未运行的情况下，打开破解补丁，点击右侧的豹子头，稍等片刻，即可破解成功！下载地址附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!官方安装包：链接: https://pan.baidu.com/s/1elbJ3NySrCmNUTFeX-gRhQ&nbsp;提取码: 8x4q破解补丁：稀缺资源统一下载地址页",
    "postDate": "2019-01-30T23:40:45.3349586+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "专业打谱软件,思杰马克丁",
    "id": 1359,
    "indexId": "Post:1359"
  },
  {
    "title": "Flash解析工具——硕思闪客精灵Sothink SWF Decompiler v7.4.5320 for Windows",
    "author": "懒得勤快",
    "content": "现在你总能在互联网上看到不少精彩的 Flash 视频作品，如何将其中一些你喜欢的元素（声音、图像、ActionScript 代码）导出，然后借鉴到自己的 FLASH 作品中？一款 Flash解析工具必不可少，比如 Sothink SWF Decompiler，即硕思闪客精灵。Sothink SWF Decompiler 硕思闪客精灵，是一款能够解析 SWF 并能将 SWF 文件还原为 FLA 文件的专业工具。它可以浏览、播放、分析 Flash 动画(.swf 文件和。exe 文件)，解读动作脚本 ActionScript 3，并能够将每个 SWF 元素以不同的格式导出（如 动作脚本、声音、图片、矢量图、动画帧、字体、文字、按钮和动画片段）。Sothink SWF Decompiler 硕思闪客精灵能够分析 Flash 动画中的视频文件并导出为 *.flv 格式的文件。软件友好的用户界面可以让你轻松掌握。你还可以选择是将 SWF 转换为 FLA 文件还是只导出您喜欢的元素。转换后的 FLA 能够在 Flash6、7 或 Flash8 中打开。完全兼容 Flash 8，包括 Flash 组件、9切片的转换和文字反锯齿参数等。此外，Sothink SWF Decompiler 硕思闪客精灵还提供了一个辅助工具——闪客名捕。当你在IE浏览器或 Firefox 浏览器中浏览网页的同时，可以使用它来获取 Flash 动画并保存到本机。软件特点Dedicated to Flash SWF Decompiler technology for over 12 years.Always keep accuracy and performance in Flash Decompiler and retrievement.Replace image/shape/text/sound and export font/button/sprit/ActionScript.Support Flash CS3/4/5/6 and ActionScript 2.0/3.0.The first and only SWF Decompiler to support XFL &amp; HTML5.软件功能Recover FLA from SWFEasily convert SWF to Flash document (*.fla)Recover lost FLA files easily and completely. Convert FLEX-made SWF to FLEX source code.The latest Flash Decompiler supports can decompile SWF with TLF text included. Compatible with Win10.View and Extract FlashExtract SWF elements in all for re-useOne-click to view and extract all SWF elements from existing SWF files. Enrich your own Flash design resources.Export all (morph) shapes, images, sounds (mp3/wav), videos (flv), fonts, texts, buttons, sprites, frames and AS.Convert Flash to HTML5Play Flash movies in HTML5 browsersConvert Flash SWF to HTML5 files, and then you can play it normally in HTML5 compatible browsers.Enable visitors to enjoy your Flash movies on PC, iPad, iPhone and other devices that support HTML5.Edit SWF ElementsEdit shape. Replace image/ text/ sound etcFlash Decompiler can help you edit all shape elements by modifying both figures and filling types.Simply edit SWF by replacing images /texts/sounds/shape, creating a new Flash movie in minutes.Easy to UseMulti-language interfaces are availableSWF Decompiler offers Office 2007 style, multi-language interfaces, and the system language can be auto-recognized.To improve efficiency, you can decompile SWF in batch mode, and Globally search all ActionScript.Free AssistanceCapture and download online Flash&nbsp;FREE Flash Downloader plugin allows you to capture online Flash from IE or Firefox in one click. You can try SWF Catcher Pro.A built-in Flash player is also provided to easily and smoothly play any SWF/FLV /F4V movies.下载地址附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!包含Sothink SWF Decompiler、Sothink SWF Editor、Sothink SWF Catcher：点击前往稀缺资源统一下载地址页",
    "postDate": "2019-01-30T23:40:45.3350534+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "硕思闪客精灵,思杰马克丁",
    "id": 1353,
    "indexId": "Post:1353"
  },
  {
    "title": "EasyRecovery数据恢复（12.0.0.2）企业汉化绿色特别版",
    "author": "非常勤快",
    "content": "EasyRecovery12是全新的一个版本，数据恢复更快速更准确，老殁希望大家在误删数据后能完整的找回来！修改介绍* 根据官方版本汉化* 包含绿色免安装版和单文件版* 无须注册* 解压后直接使用版本区别个人版：家用数据恢复，常规恢复各种文档，音乐，照片，视频等数据专业版：高级数据恢复，除常规数据恢复外，还添加高级工具，更专业，恢复更多企业版：企业级数据恢复，能恢复所有类型的数据，正版授权注册密钥价值5500块下载地址https://www.lanzous.com/i2eyqmd",
    "postDate": "2019-01-30T23:40:45.3351466+08:00",
    "email": "yykm001@126.com",
    "label": null,
    "keyword": "数据恢复,思杰马克丁",
    "id": 1348,
    "indexId": "Post:1348"
  },
  {
    "title": "杨中科+苏坤系列视频教程(.net+java)",
    "author": "懒得勤快",
    "content": "特别说明：本视频教程资源完全免费，并且无加密，如果你是通过某宝、或是其他论坛等渠道，通过任何付费的方式获取到本资源，请直接退款并在相应的平台举报，如果是论坛的，请将本页链接分享到你购买源的评论区，告诫他人谨防上当，或者直接将本页链接转发分享给有需要的人，感谢您的支持和监督。下载地址：如果链接失效，请在下方评论区或者网站留言板反馈，或者直接私信博主。https://pan.baidu.com/s/1IqbfTUuzSCnRpdoNXhwNHw",
    "postDate": "2019-01-30T23:40:45.3352693+08:00",
    "email": "admin@masuit.com",
    "label": ".net,视频教程,传智播客,杨中科,苏坤",
    "keyword": null,
    "id": 47,
    "indexId": "Post:47"
  },
  {
    "title": "思维导图 iThoughts 5.0.0.0 Multilingual for Windows破解版",
    "author": "懒得勤快",
    "content": "iThoughts Windows版是一款思维导图软件，适用于win、mac、android、ios等平台，iThoughts可以把你的想法、创意、会议记录等内容以树状图的形式的显示出来，整体上更加直观，同时还可以导出为Freemind，Mindmanager，OPML等程序所兼容的格式。iThoughts 初上手新版 iThoughts 的图标进一步向 Apple 原生风格靠拢，毫无违和感。首次打开，会展现一张名为「Welcome」的导图，既是一张完美的模版，也在字里行间展现了全部功能。工具栏只有简洁的一列，寥寥几个按键就能完成百分之 80% 的操作，易于上手。最左边书本样式的按钮是文件管理器，点开就能看到程序中全部导图，可以方便地按照文件名或者编辑时间排序。齿轮按钮用来给导图进行模板设置，从层级风格到自己粗细均能设置。吐槽一句，没有原生中文支持对很多用户来说是个障碍。点击右下角的加号就能新建一张导图，输入名字，程序会在界面中间新增一个以文件名为核心的色块，这就是所有思维发散的起点了。取代纸笔？iThoughts 的四样武器1. 便于编辑软件内可以快速的增添层级，相关的边框等会自动生成。通过「Undo」和「Redo」两个按钮可以快速撤销或重做上一个动作，对于需要反复思考的创作过程非常实用。界面不像纸笔一样受面积的制约，理论上可以增添无限多的内容，同时，可以随意插入新内容或者调整现有内容次序，纸张上就不能做到。iThoughts 还可以随时插入注释气泡，并在任意两个元素当中添加相互逻辑的注释，便于理解。2. 界面清晰用纸笔记录时为了对有效内容做出区分，传统的办法是使用不同颜色的笔迹，或者手绘一些色块元素，但这些器材本身就与随身移动的属性相违背。对 iThoughts 来说这却不算问题，程序提供了强大的编辑功能，可以调整背景色彩、字体样式，并提供了一个包罗万象的素材库，非常容易作区分和标记。此外还支持插入系统图片、超链接来当作注释，如果这还不满意，最终大招等着你：使用手绘，写下你想到的任何创意。3. 整理方便厚厚的本子可能密密麻麻的挤满了各种奇思妙想，但是着急用的时候，一下子找不到所需的内容。iThoughts 则是秒搜索，只要你曾经记录过，就能随时找到，我们记录思维导图的目的在于方便的进行二次整理，这时 iThoughts 电子化的优势就被彰显的淋漓尽致。4. 分享容易整理好的思维导图，躺在设备里是没有生命力的，要么分享给同事，要么上传到社交平台供人评判，要么传到网盘当中加以备份。这方面 iThoughts 相对纸笔有着无以复加的优势，开发者骄傲地把分享按钮放在了控制栏的最中央，点击就可以进行下一步操作了。自从接触 iThoughts 之后，我就习惯于用它来整理身边的日常事务，本篇稿件的大纲就是在这个 App 当中完成的，受益良多。目前该 App 正在二折促销，只需 12 元，诚意满满。工欲善其事，必先利其器，对于有这方面需求的人来说，正是下手好时机。下载地址https://www.lanzous.com/i2fd5hc",
    "postDate": "2019-01-30T23:40:45.3353636+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "脑图,思维导图,mind",
    "id": 1367,
    "indexId": "Post:1367"
  },
  {
    "title": "[百度传课]简快思维导图·速成宝典_xmind思维导图软件视频教程下载",
    "author": "懒得勤快",
    "content": "课程简介：适用人群职场人士、中小学生/家长、对思维导图、学习方法感兴趣的人士课程概述这是一套适合初学者的简单快速的思维导图教程，通过这套宝典，你将快速的从菜鸟迈入达人的殿堂！正如你将要知道的——菜鸟和达人其实仅一个课程的距离。此课程专为零基础的学习者设计。为帮助你更好的理解和应用，对细节的阐述较多，对于已经有一定基础或者急性子的朋友，不足之处请多多包涵。课程目录：章节1:【基础篇】「解密」导图的创始课时1「解密」导图的创始课时2「探究」博赞的秘诀课时3「拆解」导图的核心课时4「简快」导图的规律章节2:【基础篇】「畅谈」导图的绘制课时5「畅谈」导图的绘制（本课简介）课时6「自修」导图的书籍课时7「七步」博赞的绘图课时8「五步」简快的导图课时9「探究」手绘VS软件章节3:【基础篇】「秘诀」导图的修炼课时10「秘诀」导图的修炼（简介）课时11「搬字」纠结的菜鸟课时12「精炼」敏锐的达人课时13「程序」睿智的大神章节4:【技巧篇】「提炼」关键词课时14「提炼」关键词（简介）课时15「探析」为什么要提炼关键词课时16「定义」关键词具体由何组成课时17「实操」抓关键词的九大捷径章节5:【技巧篇】「文科」轻松背记课时18「文科」轻松背记（简介）课时19「语文」快速拆记成图课时20「英语」快速吃透语法课时21「提分」借力考试大纲章节6:【技巧篇】「理科」高效解题课时22「理科」高效解题（简介）课时23「预习」整理全册知识课时24「深入」整理章节重点课时25「分析」提炼解题模型章节7:【高阶篇】「解读」精品实例课时26「解读」精品实例（简介）课时27「学霸」必修应用（知识➜题型➜应考）课时28「生活」实用案例（养生+ 驾校 + 时间管理）课时29「职场」快速充电（拆书+ 文案 + PPT）章节8:【高阶篇】「解密」思维达人课时30「解密」思维达人（简介）课时31「归类法」倍增效率（时间归类、 细节归类与环节归类）课时32「联想法」挑选美图（三种转换技巧与三大挑选标准）课时33「偷师术」复制卓越（那些年我是如何偷师的！）章节9:【福利篇】各种惊喜~你懂的！课时34思维导图应用：最常见的12个问题课时35大量福利——导图/电子书/图库课程截图：下载地址链接: https://pan.baidu.com/s/1SsCJxTiFX8wI8PzOJ-wY3w&nbsp;密码: 24jt",
    "postDate": "2019-01-30T23:40:45.3354613+08:00",
    "email": "admin@masuit.com",
    "label": "xmind",
    "keyword": "思维导图,脑图",
    "id": 1338,
    "indexId": "Post:1338"
  },
  {
    "title": "自由之思想，独立之人格——大学生活，我们该如何抉择",
    "author": "懒得勤快",
    "content": "今天闲暇时看了一场往期的《非你莫属》节目之后，节目中有两个应试者在大学里面没有好好学习，几乎放弃课堂的问题。因此很多老板和有经验的人都对这些事情做出了很深刻的批判，对我的感触也挺深的。那么接下来我将谈一谈我的感受，以及我的教育观。其实，经历过大学的都知道，尤其是像我们这些IT/互联网行业的人可能有更深入的体会。不是我们不想，甚至很多学生非常想学，学得更深入，更加与企业接轨。然而实际上，大学里那种填鸭式教育，教科书式的、照着ppt念完的教学，三四年下来，只学到了基础中的基础，而且很多所谓的&#39;教授&#39;级的老师，自己都没经历过实际的项目的锤炼，大多就是大学毕业了留校教书的，没有实际的软件开发的经历，怎么可能给学生带来实际中总结出来的工作经验的启发。还有大学这种死板的教学方式，懒惰的学习氛围让课堂成为了老师谋生的工具，学生混时间的地方，而很难再找到那种真正为了学生而奉献出自己的所知所学的精神的老师了。噫吁嚱，呜呼悲哉！经历过社会的锤炼，经历过一些事情，对社会对人生有了更多的感悟后，我发现人生不仅仅是奢华享受，那种低俗的人生观是可悲的，是在这物质化的社会影响下，太多的人这样贪图享受。所以这也是我痛下决心进入这个行业，改变这种死板的愚昧式的教育做出自己的贡献。当然，人生立世要尽孝道，这是为人的第一准则。而我也逃避不了这些必须的事情。所以我只能利用我自己对于软件开发上的理解来带来一些收入。但是，真正的教育绝对不能以营利为目的。当我所有该做的事情都做完的时候，我会为下一代启迪自由之思想，独立之人格做点事，让自己做人做的有意义。这也是我的人生观。再回头来谈大学教育，其实我从小一开始就是这种愚昧和蒙蔽式的教育。我印象最深刻的是，小学时候学古诗！那么小的年龄，那么简单的人生经历怎么能理解古人那么经过那么多事情的锤炼后写出的精华的短句呢？而小学、中学、大学都是这种对与错的教育延伸。条条框框下限制了太多人的思维的扩散。而蔡元培时代的北大的教育，思想兼容并包。鲁迅、陈独秀这样的进步青年可以在北大教书，而固步自封的老顽固也可以在北大教书，让学生接触不同的思想，让他们思想更自由，更开放，学生受到的启发更大。而当今的北大....当今的知识分子，还有谁不是为了利益写文字，他们都忘了知识的责任和义务。像孔庆东这样的教授能在北大这样的学府存在，那可是北大啊....那另外一个问题：为什么中国离着诺贝尔奖那么远？而我们看新加坡，看美国，看德国的教育，他们那种从小就培养孩子独立的判断能力，组织领导能力还有演讲的能力。最近看美国的达人秀的选秀节目，看到他们的文化对我的冲击还是蛮大的，他们每个人都是那么的自信，那么开朗，面对评委他们很坦然的面对成功失败，而从来不认为自己跟评委有地位的差距。而回头看看国人的文化，看看国内的节目....那我们看看国内的大学给了我们什么，其实学习那些基础知识，完全自己学习就可以了。当然老师在教导我们的时候，我们会很快的进入到角色里面去，而且学习起来很快。但是那样很容易受到老师思想的干扰，让自己思维局限到那种思考的方式里面去。而作为老师一定要注意不要强奸学生的思想，要培养学生自己思考的能力，有些事情让学生自己去探索吧，他自己看问题的角度对他自己的启发会更大的。所以我也不建议大家不要不去听课，作为年轻人，大学时我们思想最活跃，精力最充沛的时间，一定要好好把握住这个时间。多出去走走，多看看其他方向的书，多找找自己相关专业的资料。开阔自己的思维，提高自己的修养。锻炼自己的思维和判断能力，提高自己的演讲才能，提高自己的自信。大学带给我们的是一个独立的时间，让我们独立的去做一些事情，另外就是让我们充分的去充实自己。大学带给我们的另外一个就是：你接触的人中大部分是有修养的人，所以你潜移默化中受到了这种熏陶，你自己的修养和看待事情的能力也慢慢的提升。我向来认为读研究生给我们知识方面带来的不会是太多的东西，但是带给我们的是修养和看问题的视野，以及学习和研究的能力是在其他地方学不到的，因为研究生阶段你接触的都是导师、教授、博士、院士等一些社会真正的高级知识分子(虽然我不是研究生，甚至不算是大学生)。我给正在读大学和即将上大学的朋友一点建议吧：大学充分利用这些时间，让自己更加充实。勇于打开自己的视野，跟更多的人交流，只有交流才会有思想的碰撞，才会有更宽广的角度看问题。课还是要上，今天你懒在了床上，明天你还是要拿出更多的休息时间来走完你没走的路。最后，大学给我们一个死的教学制度，但我们有一个活的思想，大家一定要自己把握自己，让自己思想更自由，人格更健全。最后送大家一句话，也送我自己：在最美的年纪遇到最好的自己，自由之思想，独立之人格。",
    "postDate": "2019-01-30T23:40:45.3355489+08:00",
    "email": "admin@masuit.com",
    "label": "大学生活",
    "keyword": null,
    "id": 87,
    "indexId": "Post:87"
  },
  {
    "title": "亿图思维导图 MindMaster Pro v6.5.5+6.2.2 破解专业付费版",
    "author": "懒得勤快",
    "content": "亿图MindMaster Pro 是一款专业于(心智图)思维导图的软件，MindMaster帮助用户在头脑风暴产生的时候记录下一瞬间精彩时刻，待办事宜、准备演示、做笔记、问题解决、项目计划、做决定、知识管理、项目管理、个人思考和写作都可以使用MindMaster实现，MindMaster 是亿图最新推出的一款跨平台、多功能的思维导图软件。它具有简洁的操作界面、稳定性高、自定义功能强大等特点，让您快速创建内容丰富、时尚精美的思维导图。功能介绍幻灯片展示MindMaster 自带幻灯片展示功能，不需要借助其他的工具，就可以进行幻灯片展示。同时支持一键将思维导图拆分成多个幻灯片页面，可以在全屏模式下遍历思维导图的主题或者分支，当思维导图内容较多时，也可以很好的将每个细节展示清楚，除此之外，MindMaster 专业版还可以将思维导图幻灯片导出为 PPT 格式，在 Office PowerPoint 中，进行分页展示和打印。合作与管理MindMaster 专业版搭载亿图云服务，提供多人协作办公的功能，团队办公中轻松实现文件共享、编辑，1G 云空间让文件保存和分享更方便自由。通过添加、管理自定义的标签，在进行任务管理的人员分配时，还可以更高效地设置任务信息。MindMaster 专业版还可以从思维导图一键生产甘特图。在思维导图中添加的任务信息会一一对应到甘特图中，思维导图和甘特可以同步编辑、更新。绘制好的甘特图，还可以导出至 PDF 格式，对于进行日程计划、安排、任务管理等，都非常的实用。更多高级样式MindMaster 专业版在免费版的基础上，增加了更多主题样式，通过彩虹色、单色、对称色、交替色四种配色，让思维导图色彩更丰富，同时还可以一键切换漂亮的手绘模式的思维导图，除此之外，MindMaster 专业版还提供了丰富的高清且纯矢量剪贴画，适用于商业、教育、人物、自然、科技等各个领域。高质量的文件导出MindMaster 专业版可以将思维导图导出为 Word、PPT、Excel、PDF 等文件格式，无需使用MindMaster 软件就可以进行再次编辑、修改。同时 MindMaster 专业版还支持导出更高 DPI 图片格式，以及 HTML 和 SVG 格式。破解说明1.安装原版MindMaster；2.将Crack文件夹下的dll文件复制到MindMaster安装文件夹下；3.启动MindMaster，然后运行MindMaster-KeyGen.exe，点击【计算】按钮，完成激活；4.压缩包内的msimg32.dll文件会被报病毒、请知悉；注意：使用注册机激活之前必须断掉网络或拔掉网线，实在不会的自己用锤子砸电脑万能的断网方式；下载地址官方安装包：http://www.edrawsoft.cn/2download/mindmaster-cn-6.5.5.exe破解补丁：稀缺资源统一下载地址页6.2.2绿色版(输入法正常)：https://www.lanzous.com/i2ex40d",
    "postDate": "2019-01-30T23:40:45.3356395+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "亿图,思维导图,MindMaster,Mind Master",
    "id": 1218,
    "indexId": "Post:1218"
  },
  {
    "title": "Mindjet MindManager 2018 思维导图（19.0.306）中文直装破解版",
    "author": "懒得勤快",
    "content": "著名思维导图软件 MindManager&nbsp;2018 是一款多功能思维导图绘制软件，如同一个虚拟的白板，仅仅通过单一视图组织头脑风暴、捕捉想法、交流规划信息，有其他软件无法媲美的项目管理和商业规划高级功能。利用它可以创建思维导图和可视化框架、组织管理信息、推进商业项目，也可以用它制作学习计划和进度、展示各种信息等。MindManager 2018 Windows 版为您理清信息的来龙去脉并充分发挥其影响，强大效果前所未见，借此激发您的创意、指导您的行动、助推您的业务并决定您的成功。创建进度表、验证需求、设定优先级，从头脑风暴到预算预测， MindManager 提供协调项目与避免障碍所需的功能，无论是简单的小项目还是复杂的创作，都可以通过 MindManager 创建通往成功的蓝图。MindManager 思维导图主要由中心主题、主题、子主题、附注主题、浮动主题、关系线等模块构成，通过这些导图模块可以快速创建您需要的思维导图。MindManager 2018中的新功能优先视图在整洁的界面中将您的优先级隔离，使下一步骤变得清晰。用优先图标标记的项目将自动显示在视图中。或者将未分配的任务拖放到优先级列中。当优先级改变时，您可以在几秒钟内重新排列它们，以保持项目正确的轨道前进，要确保你在正确的时间正确的工作，保持团队的优先级，以尽量减少错过的最后期限和瓶颈、头脑风暴，优先考虑和安排想法在一个单一的，流畅的应用程序。计划视图在干净，易于阅读和即时访问的日历中组织您的待办事项。当你知道什么时候到来，你可以更有效地计划和花费你的时间。通过简单的拖放计划，将日期附加到您创建的行动项目上，同时进行头脑风暴或计划不会使您脱离流程、整理一天，一周，一个月或一年的工作量、通过简单的拖放操作将日期分配到日历中 – 不需要输入、更好地理解和管理自己或团队的任务，优先级和带宽。仪表板向导通过新的条件格式化功能让您的仪表板焕然一新。根据您选择的数据的波动触发动态变化 – 这样您就可以立即了解并对计划，项目或业务中的新发展做出反应，而无需阅读任何文字、编制你的地图来讲述你的项目或业务的实时故事、管理例外情况，理解和减轻风险，并为自己加快行动和更明智的决策、根据各种值设置标准，包括主题文本值和属性，任务信息，标记，属性等。数字建筑师通过扩展背景对象和制图工具来重塑您使用MindManager的方式。定制现有的模板或创建全新的结构来组织和理解你的世界。您可以自由地掌控地图的外观，讲述您的业务的故事以及帮助您实现的结果、创建美观，有意义且易于执行的自定义业务流程模型和战略计划、以新的方式将计划，建议或整个业务形象化，从而揭示风险，突出机遇并揭示意想不到的新目标、为品牌外观添加标志，标题，图片和设计元素。业务战略工具包将我们新的背景对象库提升到新的水平，并提供十几个灵感新颖且经过改进的模板，帮助您以更明智的思维，更明智的决策和更好的结果来看待创意，计划和可能性、新的维恩，洋葱和泳道图让你更清楚地了解关系和交叉点、新的可定制矩阵使您能够将想法联系起来，并快速评估风险，回报，价值，紧迫性，优先级等等、利用MindManager功能和功能的全面丰富功能丰富图表，以创建强大的概念，策略和计划的三维肖像。智能过滤在巧妙的新层次视图中呈现您需要的信息，使您的选定项目成为清晰的焦点，同时保持地图的其余部分在背景中可见 – 细节和上下文的完美融合。现在你可以专注于一件事情，而不会失去任何东西、清楚地查看过滤的主题，同时保持对不匹配主题的可见性、过滤任何同步属性 – 包括来自Outlook，SharePoint（MME）和其他集成应用程序的数据 – 以及标签，标记和图标、使用单个命令同时对所有选定的主题应用更改。互动演示文稿导出HTML5互动地图导出的最新发展为您的地图展示引入了一个新的波兰，专业，轻松和影响的水平、可自定义的演示模式允许您为每个收件人创建一个独特的体验、地图可以像PowerPoint一样方便地浏览和浏览，消除了内容和观众之间的障碍、收件人还可以访问和控制演示文稿设置，以更轻松地共享和传播组织和网络中的地图。hosts屏蔽下列网址hosts在系统中的位置：C:\\Windows\\System32\\drivers\\etc0.0.0.0 www.mindjet.com0.0.0.0 mindjet.com0.0.0.0 ipm.corel.com下载地址非官方（代理）购买的激活码可能无法使用官方版本激活更新，请勿购买使用其他代理版本！复制链接，用IDM下载。直装破解版：https://attachments-cdn.shimo.im/Sr0sEIt3L6Itw5S9/Mindjet_MindManager_2019_19.0.306_x64.exe官方安装包：🔰x86&nbsp;/&nbsp;🔰x64激活方式一：注册码：MP19-886-7P66-6533-9F67激活方式二：稀缺资源统一下载地址页网络上所谓的破解版，也是使用激活码：附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!",
    "postDate": "2019-01-30T23:40:45.3357502+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "mind,思维导图,xmind,Mindjet,MindManager",
    "id": 1289,
    "indexId": "Post:1289"
  },
  {
    "title": "XMind思维导图（1.2.1）直装内购特别版 Android",
    "author": "懒得勤快",
    "content": "XMind是一款让你专注思维，捕捉每一个灵感瞬间的App。每当你有一个想法，XMind帮你专注于它的扩展延伸和梳理，融合艺术与创造力，让思维清晰可见。你可以创建workflow，接下来心无旁骛投入工作流程，以灵感为中心，在无限的脑图幕布上延伸想法，随手记录点滴灵感、待办清单、会议记录或是项目规划，尽情享受逻辑思维。软件特点XMind是一款让你专注思维，捕捉每一个灵感瞬间的 App。每当你有一个想法，XMind帮你专注于它的扩展延伸和梳理，融合艺术与创造力，让思维清晰可见。你可以创建 workflow，接下来心无旁骛投入工作流程；以灵感为中心，在无限的脑图幕布上延伸想法；随手记录点滴灵感、待办清单、会议记录或是项目规划，尽情享受逻辑思维。1、为工作增色不少白领、商务人士、互联网er 等，用于每天头脑风暴、整理思路、工作计划必备的高效率办公软件，也是跨多平台工作必备。多种多样的可能性，让你的工作方式从此大不相同。2、会议速记在会议的同时，将内容和想法记录成思维导图，整理成清晰美观的图表，让 PPT、Keynote 增色不少。你还可以即时导出你的工作成果到 Office / PDF 来为你的会议或报告提供便利。3、个人简历用二维图或时间轴的形式，更好地理清个人经历，增添自信。4、协作共享通过脑图让工作思路在印象笔记、有道云笔记等记事本备忘录中清晰呈现；分享 .xmind 文件至 QQ、钉钉、微信企业版，每一位同时随时通过 XMind 打开浏览想法。5、让学习更添动力适合在校学生和教师，整理笔记、备课、学期计划和背单词等。在做出一张漂亮的思维导图同时，也将自己的学习和备课计划整理好。在课堂上大大转变学习、授课和创造的方式。6、课程笔记整理学习笔记时，用思维导图更有条理地表达出来，告别杂乱无章的思绪。7、灵感集合无论在什么场合，都能随手记录灵感和想法，形成自己庞大的知识库，还能激励身边的朋友一起进行深度的头脑风暴。8、使生活多姿多彩人脑每天能产生 6000个念头，而其中 95% 是杂念。一念三千，抓住最重要的思绪，提高思考的效率，正是思维导图的一个重要作用。9、旅行规划在行程前，做好每日规划。在旅途中，记录旅游的点滴。10、年度计划除了每日计划，每周每月甚至年度计划，都可以在一张思维导图中清晰地呈现。11、无处不在的思维导图XMind，为所有努力工作、学习的人而设。你思考的方式，将会因 XMind 而改变。12、思维导图介绍思维导图，又称脑图、心智图，是一种图像式思维的工具以及一种利用图像式思考辅助工具来表达思维的工具。在思维导图的基础概念下，它可以利用不同的方式去表现人们的想法，不局限于格式，样式与概念。官方更新* 增加新功能：添加备注、超链接、标签* 修复部分机型上无法生成缩略图的问题* 修复部分机型上无法分享PNG的问题* 修复其它Bug并提升稳定性修改介绍* 内购破解XMind安卓订阅版* 永久使用全部功能，无限制下载地址https://www.lanzous.com/i2i74ij",
    "postDate": "2019-01-30T23:40:45.3358457+08:00",
    "email": "admin@masuit.com",
    "label": "Android,xmind",
    "keyword": null,
    "id": 1281,
    "indexId": "Post:1281"
  },
  {
    "title": "由double类型判等引发的一点小思考",
    "author": "懒得勤快",
    "content": "其实这篇文章很早就想发出来的，由于工作比较忙碌，所以一直也没写，最近有点空闲时间了，所以趁此整理一下，分享出来。今年以来一直在做一个交易所的项目，其中有部分交易的需求需要通过汇总统计来进行数据的聚合筛选，而聚合筛选的数据就是double类型的，我当然知道double类型进行判等的时候会有点坑，直到后来，有些业务需要其他同事来协同，然后就有个同事问我代码里面，写的if(Math.Abs(x-y)&lt;=1E-7)是什么意思，SQL语句里面也这样写的，类似于这样的：double[]&nbsp;price&nbsp;=&nbsp;{&nbsp;0.1,&nbsp;0.2,&nbsp;0.3,&nbsp;0.8,&nbsp;0.5&nbsp;};\ndouble&nbsp;sum&nbsp;=&nbsp;1.9;\nif&nbsp;(Math.Abs(sum&nbsp;-&nbsp;price.Sum())&nbsp;&lt;=&nbsp;1E-7)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;//todo\n}我解释说：double类型可能会有精度溢出的情况，导致在判等的时候会有丢失精度的问题，直接用“==”判等不行，所以就需要相减取绝对值再判断小于等于0.00000001的就认为它们是相等的。因为这个细节上的问题，公司让我新出的面试题我也加进去了，但最后评审的时候说这道题涉及到的不仅仅是C#的知识点，万一人家没学过计算机组成原理那不整来瓜起了，所以又把这道题剔除了。其实要究其真正原因，那还是得从计算机组成原理讲起。我们知道double双精度类型有53 位有效数字精度(包含符号号)，并总共占用8字节。程序里面我们处理的大多是十进制，而计算机处理直接收二进制数据，学过进制转换的童鞋肯定知道整数都可以完美地进行进制间的转换，而double是小数，小数的进制转换就会出现循环小数的情况，而double的位数有限，就导致了十进制小数转二进制时出现了精度丢失的情况。经典案例：0.1+0.2-0.3=5.551115123125783e-17？。why？0.1+0.2-0.3居然不等于0？！！来，把它们都转换成二进制来看看：十进制0.1&gt;二进制0.00011001100110011…(循环0011)&gt;尾数为1.1001100110011001100…1100（共52位，除了小数点左边的1），指数为-4（二进制移码为00000000010）,符号位为0&gt;计算机存储为：0 00000000100 10011001100110011…11001&gt; 因为尾数最多52位，所以实际存储的值为0.00011001100110011001100110011001100110011001100110011001再看看十进制0.2&gt;二进制0.0011001100110011…(循环0011)&gt;尾数为1.1001100110011001100…1100（共52位，除了小数点左边的1），指数为-3（二进制移码为00000000011）,符号位为0&gt;存储为：0 00000000011 10011001100110011…11001因为尾数最多52位，所以实际存储的值为0.00110011001100110011001100110011001100110011001100110011十进制0.3&gt;按照上面相同的套路，得出来：0.0011001100110011001100110011001100110011001100110011，结尾的0011循环。那么两者相加得： 0.00011001100110011001100110011001100110011001100110011001+0.00110011001100110011001100110011001100110011001100110011=0.01001100110011001100110011001100110011001100110011001100也就是说只要0.3在最低位加一的话就和0.2+0.1一样了，而尾数的最低位是第52位，再乘上-2的阶码，就是2的负54次方，这个数刚好就是：5.551115123125783e-17。所以如果要判等0.1+0.2-0.3和0，不能直接用“==”，必须相减取绝对值！特别提醒：这绝对不仅仅限于C#，所有的编程语言的double都需要这样去判等，包括js、Python等弱类型语言(浮点型)，谨记！",
    "postDate": "2019-01-30T23:40:45.3359375+08:00",
    "email": "admin@masuit.com",
    "label": ".NET,C#",
    "keyword": null,
    "id": 1188,
    "indexId": "Post:1188"
  },
  {
    "title": "[虎课网]Xmind-软件基础操作_Xmind学习操作视频教程下载",
    "author": "懒得勤快",
    "content": "Xmind软件入门视频教程_为您提供Xmind-软件基础操作图文制作视频浏览以及下载，帮助您快速的学会Xmind-软件基础操作制作过程。课程目录：课时1-软件基础操作课时2-不同思维导图对比课时3-显示调整优化课时4-图标的运用课时5-制作注意事项课时6-制作公司部门架构图课时7-制作年度工作报告课时8-进行设计项目逾期分析课时9-演示商业计划书下载地址链接: https://pan.baidu.com/s/1pBy57jq_rR55vHIluf6p-Q&nbsp;密码: 063l",
    "postDate": "2019-01-30T23:40:45.3360294+08:00",
    "email": "admin@masuit.com",
    "label": "xmind",
    "keyword": "思维导图,脑图",
    "id": 1337,
    "indexId": "Post:1337"
  },
  {
    "title": "PhotoZoom Pro v7.1.0 破解专业版单文件",
    "author": "懒得勤快",
    "content": "BenVista PhotoZoom&nbsp;是一款使用了革命性技术、效果最好的图像无损放大工具。利用它可以对图片进行放大而没有锯齿，不会失真，让您无与伦比完美放大图像质量。PhotoZoom Pro使用了S-Spline Max增强算法、增强了图片格式支持、支持多处理器、GPU加速等。这种算法是一种拥有自动调节、高级插值算法的专利技术，可以尽可能地提高图片放大或缩小时的品质，对图片放大或缩小而没有锯齿、较少失真。软件使用很简单，打开图片后，默认是 S-Spline Max，首先选择「更改大小的方式」，就会自动调整图片。Benvista PhotoZoom Pro 7.0 主要特性2018-01-04 v7.1.0http://www.benvista.com/photozoompro7/download/winPhotoZoom Pro 7 采用屡获殊荣的 BenVista S-Spline 独特技术，为您带来世界一流的数字图像放大及缩小技术。PhotoZoom Pro 7 可以渲染出完美的放大照片，呈现无与伦比的画质效果。您可以创建出锐利清晰的放大图像，避免锯齿状边缘、模糊细节以及不自然的人工效果。PhotoZoom Pro 7 主要功能—屡获殊荣的 S-Spline 技术，其中包括最新的 S-Spline Max 方法—更高质量的图像放大、更高质量的尺寸缩减—适用于不同图像类型的预设—高级微调工具：创建您自己的调整大小方法预设—调整大小配置文件：一键选择自己钟爱的调整大小方法和尺寸设置的综合编辑。—采用最新科技减少 JPEG 压缩带来的不自然感和杂色—新的“清脆度”和“鲜艳度”设置可实现更亮丽、更逼真的照片放大—放大时甚至能修复过曝和阴影问题—用于增强自然逼真效果的“胶片颗粒”功能—极度放大：最大为 1 百万 x 1 百万像素—多内核支持：实现极速提升！—图形处理单元 (GPU) 支持：图像处理速度最大提升 5x 倍（具体取决于系统配置）—批量转换：可一键调整多幅图像的大小—分屏预览：不同的调整大小效果一览无余—高级裁剪工具—直接从 PhotoZoom 打印图像—既可作为独立应用程序也可作为“自动化”和“导出”插件用于 Adobe Photoshop (系统要求)—与 Adobe Lightroom 集成—保留元数据和颜色配置文件—支持 16 位/通道（包括 Raw）图像—支持 32 位/通道 (HDR) 图像（使用“自动化”插件）—支持层（使用“自动化”插件）—支持更多图像文件格式（使用“自动化”插件）—与 Windows、macOS、Adobe Photoshop、Adobe Photoshop Elements、Adobe Lightroom、Corel PHOTO-PAINT 和 Corel PaintShop Pro 的最新版本完全兼容—独立应用程序和插件版本均与 64 位和 32 位系统环境完全兼容。此版特点# 反汇编破解，无需解锁码免注册，启动即为专业版，无任何功能限制；# 去升级，禁止首次打开检测更新提示，去工具栏帮助按钮、菜单帮助；# 基于官方版解压UPX压缩壳，破解修改后加回UPX壳以减小文件大小;下载地址此软件不是苏州思杰马克丁软件有限公司的，该软件来自于官网。附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!稀缺资源统一下载地址页",
    "postDate": "2019-01-30T23:40:45.3361186+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "PhotoZoom,无损放大,图片放大",
    "id": 177,
    "indexId": "Post:177"
  },
  {
    "title": "补上博文一篇：由鹿晗公布恋情而引发的一次人生思考🤔",
    "author": "懒得勤快",
    "content": "人生处处是惊喜。国庆假期最后一天，当红流量小生鹿晗于正午 12 点，在微博公布恋情。微博一经发布后，瞬间刷爆朋友圈、各大网站头条，还导致了微博一时间瘫痪。微博客服也很无奈表示：具体怎么造成的，大家心里也都有数。然整个事件当中，除了无数粉碎的少女心，最无辜躺枪还如此敬业的小哥哥，非这位微博搜索工程师丁振凯莫属啦，结婚当日，遇鹿晗公布恋情，不得不从酒席上离开处理微博异常后继续婚礼，心疼小哥哥三秒钟......回顾一下，究竟是多大的流量使得曾豪言“微博服务器稳定，能同时应付三对劈腿的”壮志秒破功，具体数据如下图所示：按照微博明星势力榜各个榜单计分方式：满分100分，由阅读数、互动数、社会影响力、爱慕值四项组成，所占比例分别为30%、30%、20%、20%。由上可以看出，鹿晗所发微博的每一项到达到了峰值，那么在如此高流量的情况之下，作为开发者是否有好的方法来快速提高系统性能呢？接下来，来自 CSDN 博客专家的“拿客_三产”，拿客站长，与我们分享目前最为炙手可热的 Key-Value 数据库、常用做缓存、Session 共享中间件、分布式锁等的——Redis 技术。说明：阅读本文章需要一定&nbsp;Web&nbsp;开发经验，最好对&nbsp;Redis&nbsp;有一个基本的认知，文章最后的附录也会为大家提供一些相关的文章，本文章只是为了让那些对&nbsp;Redis&nbsp;的应用仅仅局限于&nbsp;缓存&nbsp;的开发人员了解到&nbsp;Redis&nbsp;更多可能的应用场景，由于篇幅限制，文中很多场景只是阐述了实现的思想及部分原理，仅仅提供了部分功能的具体实现。现代高并发复杂系统面临的挑战现代系统随着功能的复杂化，各种各样需求层出不穷，面对愈加复杂话的业务系统、越来越庞大的用户群体，以及用户对体验的要求越来越高，性能就变得更加重要。抛开代码逻辑、服务器性能的相关问题外，提高性能的方式有以下几种：动静分离\n负载均衡\n分布式\n集群化\n缓存\n限流处理\n数据压缩\n其他我们来分析一下负载均衡、分布式、集群化涉及的问题：配置管理变得复杂，因此需要设置配置中心来解决该问题。\n同一个用户的请求会转发至不同的&nbsp;Web&nbsp;服务器，从而导致&nbsp;Session&nbsp;丢失等问题。\n同一个请求在分布式环境中需要不同服务来提供不同处理，从而需要分布式事务来确保数据的一致性。\n分布式唯一&nbsp;ID&nbsp;问题。另外针对不同部分系统中的一些特定问题又有其他的一些特殊业务需求：IP统计\n用户登录记录统计\n实时的排行榜\n原子计数\n最新评论诚然，以上各种问题都有花样繁多的解决方法，例如：配置中心可以使用 Zookpeer、Redis 等实现。Session 丢失可以使用 Session 同步、客户端 token、Session 共享等解决，其中 Session 共享又可以细分不同实现方式。面对层出不穷的概念，以及各种新兴的技术，我们往往会显得力不从心，那么有没有一个银弹可以解决这些问题呢？Redis 非银弹却无比接近我这里为大家推荐的就是 Redis ，虽然它离真正意义的银弹还是有些距离，但是他是为数不多的接近银弹的解决方案：Redis&nbsp;使用&nbsp;C&nbsp;开发，是一款内存&nbsp;K/V&nbsp;数据库，架构设计极简，性能卓著。\nRedis&nbsp;采用&nbsp;单线程&nbsp;多路复用的设计，避免了并发带来的锁性能损耗等问题。\nRedis&nbsp;安装、测试、配置、运维较其他产品更为容易。\nRedis&nbsp;是目前为止最受欢迎的&nbsp;K/V&nbsp;数据库，支持持久化，value&nbsp;支持多种数据结构。\nRedis&nbsp;命令语法简单，极易掌握。\nRedis&nbsp;提供了一种通用的协议，使得各种编程语言都能很方便的开发出与其交互的客户端。\nRedis&nbsp;开放源码，我们可以对其进行二次开发来定制优化。\nRedis&nbsp;目前有较好的社区维护，版本迭代有所保障，新的功能也在有条不紊的添加完善。\nRedis&nbsp;有较好的主从复制、集群相关支持。最新版本提供模块化功能，可以方便的扩展功能。接下来我们就来说说怎么使用 Redis 解决之前提到的问题：1. 配置中心Redis 本身就是内存 K/V 数据库，支持 哈希、集合、列表等五种数据结构，从而配置信息的存储、读取速度都能够得到满足，Redis 还提供订阅/发布功能从而可以在配置发生改变时通知不同服务器来进行更新相关配置。2. 分布式锁使用 Redis 的 SETNX 命令或者 SET 命令配合 NX 选项的方式以及过期时间等功能可以很方便的实现一个性能优越的分布式锁。3. 缓存Redis 支持多种过期淘汰机制，本身性能的优势也使 Redis 在缓存方面得到广泛使用。4. Lua 脚本Lua 是一种轻量小巧的脚本语言，用标准C语言编写并开放源代码。Redis 支持 Lua 脚本的运行，从而可以扩展 Redis 中的命令实现很多复杂功能。Redis 支持使用 Lua 脚本来实现一些组合命令逻辑处理，从而可以使用 Redis 做为限流、分布式唯一 ID 相关技术的实现。5. Redis 支持 BitMaps位图（bitmap）是一种非常常用的结构，在索引，数据压缩等方面有广泛应用,能同时保证存储空间和速度最优化（而不必空间换时间）。使用 Redis 的 BitMaps 做为用户登录记录统计，不仅统计速度极快，而且内存占用极低。6. Redis 支持 HyperLogLog 算法Redis HyperLogLog是一种使用随机化的算法，以少量内存提供集合中唯一元素数量的近似值。HyperLogLog 可以接受多个元素作为输入，并给出输入元素的基数估算值：HyperLogLog 的优点是，即使输入元素的数量或者体积非常非常大，计算基数所需的空间总是固定的、并且是很小的。在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。使用 HyperLogLog 算法，我们可以轻而易举的实现 IP 统计等对数据容许些许误差的统计功能。基数：集合中不同元素的数量。比如&nbsp;{‘apple’,&nbsp;‘banana’,&nbsp;‘cherry’,&nbsp;‘banana’,&nbsp;‘apple’}&nbsp;的基数就是3。\n估算值：算法给出的基数并不是精确的，可能会比实际稍微多一些或者稍微少一些，但会控制在合理的范围之内。7. Redis 支持 Geo 功能我们可以使用基于 Redis 来实现地理位置相关管理，附近的人、两地理位置间距离计算等功能变得极为容易实现。8. 简单消息队列Redis 列表 + 发布/订阅功能可以很方便的实现一个简单的消息队列，将消息存入 Redis 列表中，通过 发布/订阅功能通知指定成员，成员获取到通知后可以根据通知内容进行对应处理。9. 全文检索Redis 官方团队开发了 RediSearch 模块，可以实现使用 Redis 来做全文检索的功能。10. 分布式唯一IDRedis 的设计使其可以避免并发的多种问题，使其命令都是原子执行，这些特性都天生匹配分布式唯一ID生成器的要求。而且通过与 Lua 脚本的结合使用更是能生成复杂的有某些规律的唯一ID。部分代码实现下面我们以 Java代码作为演示（编程语言实现方式原理类似只是具体实现方式有些许差别而已）讲解几个功能的实现：Session 共享原理：将不同 Web 服务器的 Session 信息统一存储在 Redis 中，并且获取 Session 也是从 Redis 中获取实现方法：方法一：基于 Tomcat 实现 Sessioin 共享：Tomcat 配置步骤（相关代码资源可以从https://gitee.com/coderknock/Tomcat-Redis-Session-Manager-Demo 获取）：将 commons-pool2-2.4.2.jar、jedis-2.9.0.jar、commons-pool2-2.4.2.jar 三个 jar 包放到 Tomcat 下的 lib 目录下（注意：不是项目的 lib 目录）。修改 Tomcat conf 下 context.xml：&nbsp;&nbsp;&nbsp;&lt;Context&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Valve&nbsp;className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve&quot;&nbsp;/&gt;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Manager&nbsp;className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionManager&quot;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;host=&quot;127.0.0.1&quot;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port=&quot;6379&quot;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;database=&quot;0&quot;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxInactiveInterval=&quot;60&quot;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;password=&quot;admin123&quot;&nbsp;/&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......\n&nbsp;&nbsp;&nbsp;&lt;/Context&gt;方法二：基于 Fileter 、 自行实现 HttpServletRequestWrapper 、 HttpSession ：关键代码：HttpSessionWrapper.java&nbsp;&nbsp;&nbsp;import&nbsp;com.alibaba.fastjson.JSON;\n&nbsp;&nbsp;&nbsp;import&nbsp;com.alibaba.fastjson.JSONException;\n&nbsp;&nbsp;&nbsp;import&nbsp;com.coderknock.jedis.executor.JedisExecutor;\n&nbsp;&nbsp;&nbsp;import&nbsp;com.coderknock.pojo.User;\n&nbsp;&nbsp;&nbsp;import&nbsp;org.apache.commons.lang3.StringUtils;\n&nbsp;&nbsp;&nbsp;import&nbsp;org.apache.logging.log4j.LogManager;\n&nbsp;&nbsp;&nbsp;import&nbsp;org.apache.logging.log4j.Logger;\n&nbsp;&nbsp;&nbsp;import&nbsp;javax.servlet.ServletContext;\n&nbsp;&nbsp;&nbsp;import&nbsp;javax.servlet.http.HttpServletRequest;\n&nbsp;&nbsp;&nbsp;import&nbsp;javax.servlet.http.HttpServletResponse;\n&nbsp;&nbsp;&nbsp;import&nbsp;javax.servlet.http.HttpSession;\n&nbsp;&nbsp;&nbsp;import&nbsp;javax.servlet.http.HttpSessionContext;\n&nbsp;&nbsp;&nbsp;import&nbsp;java.util.Enumeration;\n&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&lt;p&gt;&lt;/p&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;*\n&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@author&nbsp;三产\n&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@version&nbsp;1.0\n&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@date&nbsp;2017-08-26\n&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@QQGroup&nbsp;213732117\n&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@website&nbsp;http://www.coderknock.com\n&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@copyright&nbsp;Copyright&nbsp;2017&nbsp;拿客&nbsp;coderknock.com&nbsp;&nbsp;All&nbsp;rights&nbsp;reserved.\n&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@since&nbsp;JDK&nbsp;1.8\n&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;HttpSessionWrapper&nbsp;implements&nbsp;HttpSession&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;final&nbsp;Logger&nbsp;logger&nbsp;=&nbsp;LogManager.getLogger(HttpSessionWrapper.class);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;sid&nbsp;=&nbsp;&quot;&quot;;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;HttpServletRequest&nbsp;request;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;HttpServletResponse&nbsp;response;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;long&nbsp;creationTime&nbsp;=&nbsp;System.currentTimeMillis();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;long&nbsp;lastAccessedTime&nbsp;=&nbsp;System.currentTimeMillis();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//过期时间单位秒\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;expire_time&nbsp;=&nbsp;60;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;HttpSessionWrapper()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;HttpSessionWrapper(String&nbsp;sid,&nbsp;HttpServletRequest&nbsp;request,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpServletResponse&nbsp;response)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.sid&nbsp;=&nbsp;sid;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.request&nbsp;=&nbsp;request;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.response&nbsp;=&nbsp;response;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Object&nbsp;getAttribute(String&nbsp;name)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.info(getClass()&nbsp;+&nbsp;&quot;getAttribute(),name:&quot;&nbsp;+&nbsp;name);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;obj&nbsp;=&nbsp;JedisExecutor.execute(jedis&nbsp;-&gt;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;jsonStr&nbsp;=&nbsp;jedis.get(sid&nbsp;+&nbsp;&quot;:&quot;&nbsp;+&nbsp;name);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(jsonStr&nbsp;!=&nbsp;null&nbsp;||&nbsp;StringUtils.isNotEmpty(jsonStr))&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jedis.expire(sid&nbsp;+&nbsp;&quot;:&quot;&nbsp;+&nbsp;name,&nbsp;expire_time);//&nbsp;重置过期时间\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;jsonStr;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;obj;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(JSONException&nbsp;je)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.error(je);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.error(e.getMessage());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setAttribute(String&nbsp;name,&nbsp;Object&nbsp;value)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.info(getClass()&nbsp;+&nbsp;&quot;setAttribute(),name:&quot;&nbsp;+&nbsp;name);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JedisExecutor.executeNR(jedis&nbsp;-&gt;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(value&nbsp;instanceof&nbsp;String)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;value_&nbsp;=&nbsp;(String)&nbsp;value;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jedis.set(sid&nbsp;+&nbsp;&quot;:&quot;&nbsp;+&nbsp;name,&nbsp;value_);//普通字符串对象\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jedis.set(sid&nbsp;+&nbsp;&quot;:&quot;&nbsp;+&nbsp;name,&nbsp;JSON.toJSONString(value));//序列化对象\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jedis.expire(sid&nbsp;+&nbsp;&quot;:&quot;&nbsp;+&nbsp;name,&nbsp;expire_time);//&nbsp;重置过期时间\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.error(e);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;removeAttribute(String&nbsp;name)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.info(getClass()&nbsp;+&nbsp;&quot;removeAttribute(),name:&quot;&nbsp;+&nbsp;name);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(StringUtils.isNotEmpty(name))&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JedisExecutor.executeNR(jedis&nbsp;-&gt;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jedis.del(sid&nbsp;+&nbsp;&quot;:&quot;&nbsp;+&nbsp;name);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.error(e);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//......&nbsp;省略部分代码\n&nbsp;&nbsp;&nbsp;}SessionFilter.java&nbsp;&nbsp;&nbsp;import&nbsp;com.coderknock.wrapper.DefinedHttpServletRequestWrapper;\n&nbsp;&nbsp;&nbsp;import&nbsp;org.apache.commons.lang3.StringUtils;\n&nbsp;&nbsp;&nbsp;import&nbsp;org.apache.logging.log4j.LogManager;\n&nbsp;&nbsp;&nbsp;import&nbsp;org.apache.logging.log4j.Logger;\n&nbsp;&nbsp;import&nbsp;javax.servlet.*;\n&nbsp;&nbsp;&nbsp;import&nbsp;javax.servlet.http.Cookie;\n&nbsp;&nbsp;&nbsp;import&nbsp;javax.servlet.http.HttpServletRequest;\n&nbsp;&nbsp;&nbsp;import&nbsp;javax.servlet.http.HttpServletResponse;\n&nbsp;&nbsp;&nbsp;import&nbsp;java.io.IOException;\n&nbsp;&nbsp;&nbsp;import&nbsp;java.util.UUID;\n&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&lt;p&gt;&lt;/p&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;*\n&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@author&nbsp;三产\n&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@version&nbsp;1.0\n&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@date&nbsp;2017-08-26\n&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@QQGroup&nbsp;213732117\n&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@website&nbsp;http://www.coderknock.com\n&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@copyright&nbsp;Copyright&nbsp;2017&nbsp;拿客&nbsp;coderknock.com&nbsp;&nbsp;All&nbsp;rights&nbsp;reserved.\n&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@since&nbsp;JDK&nbsp;1.8\n&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;SessionFilter&nbsp;implements&nbsp;Filter&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;final&nbsp;Logger&nbsp;logger&nbsp;=&nbsp;LogManager.getLogger(getClass());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;String&nbsp;host&nbsp;=&nbsp;&quot;host&quot;;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;String&nbsp;port&nbsp;=&nbsp;&quot;port&quot;;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;String&nbsp;seconds&nbsp;=&nbsp;&quot;seconds&quot;;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;init(FilterConfig&nbsp;filterConfig)&nbsp;throws&nbsp;ServletException&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.debug(&quot;init&nbsp;filterConfig&nbsp;info&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;doFilter(ServletRequest&nbsp;request,&nbsp;ServletResponse&nbsp;response,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FilterChain&nbsp;chain)&nbsp;throws&nbsp;IOException,&nbsp;ServletException&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//从cookie中获取sessionId，如果此次请求没有sessionId，重写为这次请求设置一个sessionId\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpServletRequest&nbsp;httpRequest&nbsp;=&nbsp;(HttpServletRequest)&nbsp;request;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpServletResponse&nbsp;httpResponse&nbsp;=&nbsp;(HttpServletResponse)&nbsp;response;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;sid&nbsp;=&nbsp;null;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(httpRequest.getCookies()&nbsp;!=&nbsp;null)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Cookie&nbsp;cookie&nbsp;:&nbsp;httpRequest.getCookies())&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(cookie.getName().equals(&quot;JSESSIONID&quot;))&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sid&nbsp;=&nbsp;cookie.getValue();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(StringUtils.isEmpty(sid))&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cookie&nbsp;cookie&nbsp;=&nbsp;new&nbsp;Cookie(&quot;JSESSIONID&quot;,&nbsp;httpRequest.getLocalAddr()&nbsp;+&nbsp;&quot;:&quot;&nbsp;+&nbsp;request.getLocalPort()&nbsp;+&nbsp;&quot;:&quot;&nbsp;+&nbsp;UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&nbsp;&quot;&quot;));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;httpResponse.addCookie(cookie);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.info(&quot;JSESSIONID:&quot;&nbsp;+&nbsp;sid);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chain.doFilter(new&nbsp;DefinedHttpServletRequestWrapper(sid,&nbsp;httpRequest,&nbsp;httpResponse),&nbsp;response);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;destroy()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;}排行榜：原理：通过 Redis 有序集合可以很便捷的实现该功能关键命令：ZADD&nbsp;key&nbsp;[NX|XX][CH][INCR]&nbsp;score&nbsp;member&nbsp;[score&nbsp;member&nbsp;...]:&nbsp;初始化排行榜中成员及其分数。\nZINCRBY&nbsp;key&nbsp;increment&nbsp;member：为某个成员增加分数，如果该成员不存在则会添加该成员并设定分数为&nbsp;increment&nbsp;。\nZUNIONSTORE&nbsp;destination&nbsp;numkeys&nbsp;key&nbsp;[key&nbsp;...][WEIGHTS&nbsp;weight&nbsp;[weight&nbsp;...]][AGGREGATE&nbsp;SUM|MIN|MAX]:&nbsp;可以合并多个排行榜，该操作会将几个集合的并集存储到&nbsp;destination&nbsp;中，其中各个集合相同成员分数会叠加或者取最大、最小、平均值等(根据&nbsp;[AGGREGATE&nbsp;SUM|MIN|MAX]&nbsp;参数决定，默认是叠加)，从而可以实现根据多个分排行榜来计算总榜排行的功能。\nZREVRANGE&nbsp;key&nbsp;start&nbsp;stop&nbsp;[WITHSCORES]：该命令就是最关键的获取排行信息的命令，可以获取从高到低的成员。Redis 命令演示(“#”之后为说明)：&nbsp;&nbsp;&nbsp;#&nbsp;1、存储几个排行榜成员数据（这里可以理解为把自己系统已有数据加载到&nbsp;Redis&nbsp;中）\n&nbsp;&nbsp;&nbsp;ZADD&nbsp;testTop&nbsp;23&nbsp;member1&nbsp;25&nbsp;member2\n&nbsp;&nbsp;&nbsp;#&nbsp;2、增加某个人的分数（这里的分数就是排行的依据可以是浮点类型）\n&nbsp;&nbsp;&nbsp;ZINCRBY&nbsp;&nbsp;testTop&nbsp;20&nbsp;member1&nbsp;&nbsp;&nbsp;#&nbsp;此时&nbsp;testTop&nbsp;中&nbsp;member1&nbsp;的分数就编程了&nbsp;43\n&nbsp;&nbsp;&nbsp;ZINCRBY&nbsp;&nbsp;testTop&nbsp;-10&nbsp;member2&nbsp;&nbsp;#&nbsp;此时&nbsp;testTop&nbsp;中&nbsp;member2&nbsp;的分数就编程了&nbsp;15\n&nbsp;&nbsp;&nbsp;ZINCRBY&nbsp;&nbsp;testTop&nbsp;20&nbsp;member3&nbsp;&nbsp;&nbsp;#&nbsp;此时向&nbsp;testTop&nbsp;中添加了&nbsp;member3&nbsp;成员，分数为&nbsp;20\n&nbsp;&nbsp;&nbsp;#&nbsp;3、查询排行榜前两名，并且查询出其分数【WITHSCORES&nbsp;选项用于显示分数，不带该参数则只会查出成员名称】\n&nbsp;&nbsp;&nbsp;ZREVRANGE&nbsp;testTop&nbsp;0&nbsp;1&nbsp;WITHSCORES\n&nbsp;&nbsp;&nbsp;#结果：\n&nbsp;&nbsp;&nbsp;#&nbsp;1)&nbsp;&quot;member1&quot;\n&nbsp;&nbsp;&nbsp;#&nbsp;2)&nbsp;&quot;43&quot;\n&nbsp;&nbsp;&nbsp;#&nbsp;3)&nbsp;&quot;member3&quot;\n&nbsp;&nbsp;&nbsp;#&nbsp;4)&nbsp;&quot;20&quot;\n&nbsp;&nbsp;&nbsp;#&nbsp;假设此时还有一个&nbsp;排行榜\n&nbsp;&nbsp;&nbsp;ZADD&nbsp;testTop2&nbsp;&nbsp;100&nbsp;member2&nbsp;200&nbsp;member3&nbsp;123&nbsp;member4\n&nbsp;&nbsp;&nbsp;#&nbsp;将&nbsp;testTop&nbsp;testTop2&nbsp;合成一个总榜&nbsp;top\n&nbsp;&nbsp;&nbsp;ZUNIONSTORE&nbsp;&nbsp;top&nbsp;2&nbsp;testTop&nbsp;testTop2\n&nbsp;&nbsp;&nbsp;#&nbsp;查询总榜所有成员排行情况\n&nbsp;&nbsp;&nbsp;ZREVRANGE&nbsp;top&nbsp;0&nbsp;-1&nbsp;WITHSCORES\n&nbsp;&nbsp;&nbsp;1)&nbsp;&quot;member3&quot;\n&nbsp;&nbsp;&nbsp;2)&nbsp;&quot;220&quot;\n&nbsp;&nbsp;&nbsp;3)&nbsp;&quot;member4&quot;\n&nbsp;&nbsp;&nbsp;4)&nbsp;&quot;123&quot;\n&nbsp;&nbsp;&nbsp;5)&nbsp;&quot;member2&quot;\n&nbsp;&nbsp;&nbsp;6)&nbsp;&quot;115&quot;\n&nbsp;&nbsp;&nbsp;7)&nbsp;&quot;member1&quot;\n&nbsp;&nbsp;&nbsp;8)&nbsp;&quot;43&quot;Java 相关实现代码可以查看。https://gitee.com/coderknock/Redis-Top-And-Around/src/test/java/TopDemo.java 有具体测试用例Geo 相关功能Redis 的 Geo 功能提供了查询两个成员距离、某个成员附近范围成员等功能可以用其实现一个简单的附近的人Java 相关实现代码可以查看：https://gitee.com/coderknock/Redis-Top-And-Around/src/test/java/GeoDemo.java 有具体测试用例。缓存原理：将经常会访问的数据根据一定规则设置一个 Key 后存入 Redis，每次查询时先查询 Redis 中是否包含匹配数据，如果缓存不存在再查询数据库。注意点：对于不存在的数据应该存入一个自己设定的空值并设置过期时间，这样可以避免缓存击穿（由于数据不存在，所以设置 Key 对应的值为 null（Java中的表示形式），因为 Redis 会移除值为 null 的 key 这样会导致，每次查询还是会访问数据库）。Java 相关实现代码可以查看：https://gitee.com/coderknock/Redis-Cache结束语本文只是问了发散大家的思维，如对具体功能实现由兴趣可以在之后的交流中共同探讨。由于个人的局限性，文中可能存在错误表述，大家可以在评论区中提出共同探讨。",
    "postDate": "2019-01-30T23:40:45.336218+08:00",
    "email": "admin@masuit.com",
    "label": "高并发,大数据,分布式",
    "keyword": null,
    "id": 101,
    "indexId": "Post:101"
  },
  {
    "title": "冰点还原DeepFreeze 8.53.020.5458 破解版附注册机",
    "author": "懒得勤快",
    "content": "特色功能安装简单，易于使用：安装过程无需复杂操作，根据提示安装重启即可保护你的系统不受**感染：无论你对系统进行何种操作，重启之后还原至安全状态！提供密码保护的完整安全体系：你可以设定密码防止他人误操作支持FAT，FAT32的，NTFS的，基本和动态磁盘；支持多个磁盘和分区冰点还原教程(使用和删除冰点)一、冰点的安装&nbsp;1、只能安装在win2000和xp两个系统下，其它系统不支持。&nbsp;2、安装时注意选择保护的硬盘……&nbsp;3、进入系统后软件呼出热键为 ctrl+AIt+shift+F6 也可以按住shift的同时鼠标双击任务图标打开，打开后可设定密码，默认密码为空。&nbsp;4、主界面有三个选项：&nbsp;(1)第一个为保护状态,即每次启动恢复所保护的硬盘。&nbsp;(2)第二个为自由选项，比如系统正在被保护状态，我们选第二个选项，默认为1，这个1是指机器重新启动后的一次为不保护状态，当机器在次重起后，自动转到保护状态，那么在重起后我们所做的操作在第二次机器重起时就会被自动被保护起来。(3)第三个为不还原状态,重启后冰点图表会不停的闪动红X，就是放弃了所有保护的硬盘，这时候运行冰点安装程序可以删除冰点。&nbsp;二、冰点的删除&nbsp;1、按ctrl+AIt+shift+F6呼出界面，如果你没修改，密码为空，进入软件设置界面。&nbsp;2、选择第三项，即放弃保护，计算机重启。&nbsp;3、重启后冰点图标闪烁红x，说明冰点已经没有保护硬盘了。&nbsp;4、运行冰点原程序，会出现删除选项，点击删除......&nbsp;可以保护您的硬盘免受病毒侵害，重新恢复删除或覆盖的文件，彻底清除安装失败的程序，并避免由于系统死机带来的数据丢失等问题。只需简单的几步安装，即可安全地保护您的硬盘数据。还原精灵的安装不会影响硬盘分区和操作系统。轻松安装、动态保护、实时瞬间恢复适合网吧和个人用，直接安装就可以，卸载：ctrl+AIt+shift+F6然后输入安装密码就可以，卸载后重新启动生效，完全卸载就反安装一下下载后直接安装，默认提供的C、D、E三个盘为保护，可以根据自己的要求来设置，启动软件ctrl+AIt+shift+F6设置密码，三个选项，第一个为保护状态，第二个为自由选项，第三个为不还原状态，比如系统正在被保护状态，我们选第二个选项，默认为1，这个1是指机器重新启动后的一次为不保护状态，当机器在次重起后，自动转到保护状态，那么在重起后我们所做的操作在第二次机器重起时就会被自动被保护起来，第三个不保护状态选择后就不用介绍了吧：），当你看到冰点图表在不停的闪动红X的时候就是不在保护状态，这时要注意你的设置了！许可证密钥优势• 每次重启系统时保证100％恢复；• 保护主引导记录（MBR）；• 隐身模式可以隐藏Deep Freeze系统托盘图标；• 轻松部署选项，包括用于快速网络部署的静默安装，部署作为您的映像解决方案的一部分；• 提供密码保护和完整的安全性；• 防止勒索软件和恶意软件；• 保护多个硬盘驱动器和分区；• 支持多引导环境；• 支持SSD, SCSI, ATA, SATA和IDE硬盘；• 支持FAT, FAT32, NTFS, 标准和动态磁盘；下载地址附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!官方安装包：https://www.lanzous.com/b317626/产品注册机（生成的许可证密钥，可在线激活为永不过期版）：稀缺资源统一下载地址页此软件不是苏州思杰马克丁软件有限公司的，该软件安装包来自于官网，以上主程序下载链接为官网链接。",
    "postDate": "2019-01-30T23:40:45.3363226+08:00",
    "email": "admin@masuit.com",
    "label": "生产力工具",
    "keyword": "冰点还原,冰点还原DeepFreeze,DeepFreeze",
    "id": 148,
    "indexId": "Post:148"
  },
  {
    "title": "选错专业悔四年，选错城市毁一生",
    "author": "懒得勤快",
    "content": "填报志愿，是每个高三毕业生经历的最后一道坎。高考结束后，最重要的事情自然是填志愿。是选学校还是选专业，还是选地区，成了众多毕业生当下最头疼的问题。在填志愿时，除了需要考虑自身的兴趣，职业前景和未来发展也是左右专业选择的重要因素之一。如果你兴趣明确，有志于在某一领域发展，又考取了高分，那么填报志愿就很容易了，选择的余地非常大。但是对大多数人来说，上大学的主要目的是毕业后找到一份待遇不错的工作，至于学什么，能符合兴趣更好，不那么符合也没关系。数读菌利用爬虫，爬取了前程无忧网站中近一个月内发布的超过10万份有效招聘，并且统计了其中涉及到的专业、学历、工作经验要求，以及全国各个城市提供的工作数量，希望可以提供一些专业选择建议。哪些专业最吃香如果问到什么专业最有“钱”景，很多人首先会想起IT和金融。大型互联网公司已经是高薪的代言词，而投行、证券公司和银行，更是很多大学毕业生挤破头都想进去的地方。那么在招聘网站中，哪些专业更赚钱呢？通过统计，数读菌发现，投资专业以1.73万的平均月薪傲视群雄，房地产和城市规划专业紧随其后。而平均薪资在前十五名的专业，也多和经济、计算机、数学、房地产有关。而对一些专业的毕业生来说，江湖中一直流传着“毕业即失业”的传说。这些专业常年被国家称为“红牌专业”，即就业市场存在严重“产能过剩”，毕业生难以找到对应岗位的工作。即便找到了，工资可能也很低。在招聘网站中，平均薪资最低的是物流仓储专业，仅有4230元，而平均薪资倒数十五名的专业还有常见的行政管理、广告视觉、汉语言文学等，工资还不到金融和计算机专业的一半。所以，如果处于就业和挣钱的考虑，学习经济、计算机和房地产相关的专业，在未来会有更高的几率拿到较高的薪水。读大学，还是要去北上广专业很重要，但是城市往往更重要。因为大城市通常意味着更多的工作机会，尤其是和你所学专业对口的工作机会，还有更高的平均薪资。而在中小城市，你的专业可能连一份不错的实习都找不到。为了展现地区差异，数读菌还统计了不同地区的招聘数量。一线城市上海、深圳、广州、北京毫无疑问的以超过万份的招聘数量排在前4位。排在其后的二线城市杭州、成都、南京、武汉等地的职位数量均不到上海的一半。不过，可以看到在二线城市的人才争夺战中，杭州和成都以超过5000份招聘机会遥遥领先西安、武汉等地。明显可以看到的是，在北方地区，北京一地独大，工作机会非常多，但是其他地区明显落后，仅有部分省会还算有机会。长三角和珠三角则不同，多个城市共同繁荣，并且提供大量的工作机会。如果再计算不同城市的平均薪酬，依然是南方普遍较高，北方普遍偏低。其中，北京、上海、深圳以每月过万元平均薪资，牢牢占据前三。紧随其后的还是长三角与珠三角的大中城市，从杭州、温州、苏州到东莞、佛山，都以超过8千元每月的平均薪资领跑全国。相比之下中部城市就要逊色一些，中部的多数省会如武汉、郑州、合肥的平均值均在7千元左右。巨大的竞争压力与生活压力仍然阻挡不了年轻人奔向一线城市的脚步，而这一切最原始的动力还是钱与机会的问题。在数读菌统计的48个城市中，北上广深4座城市的招聘数量就占到了50%以上。越老越吃香？和一线城市一样重要的，大概就是工作经历了。如果高考成绩不太理想，还在焦虑自己没能考上985和211，没关系，工作经验在一定程度上可以帮你弥补高考时形成的差距。找工作时，简历上如果能有一段不错的工作经历，常常是重要的加分项，而三年的工作经验通常能带来较大的变化。数读菌统计了不同的工作经历要求的招聘给出的平均薪资，发现前2年的工作经历并不能显著提升一个人的报酬，无工作经历与1-2年的工作经历给出平均薪资都在7千元上下。但是一旦工作超过三年，从三年工作经验的1万元到五年工作经验的1.5万，再到八年工作经验的2.1万元，招聘者给出的平均薪资直线上升。也就是说，当你的第一份工作满三年以后，不满足于现状的你就可以考虑跳槽去找一份新的工作了，那时你会获得较高的薪资涨幅。当然，并不是说你读了好学校，选到了好专业就能找到一份好工作，虽然好学校和好专业可以大幅提高你未来高薪的机会。说到底，有真本事，才是职场的硬通货。",
    "postDate": "2019-01-30T23:40:45.3363882+08:00",
    "email": "admin@masuit.com",
    "label": "大学生活",
    "keyword": null,
    "id": 1234,
    "indexId": "Post:1234"
  },
  {
    "title": "亿图图示v9.3 官方中文版及破解激活补丁",
    "author": "懒得勤快",
    "content": "亿图图示是一款由深圳市亿图软件有限公司开发的全类型，综合图形图表设计软件，解决跨平台，多领域，全终端的图形设计，图文混排和工程制图等需求。亿图图示是一款简单易用的快速制图软件，适合任何人绘制任何类型的图表。使用这款智能的软件释放您的创造力，使用免费的模版轻松设计和创建惊艳的图表。作为一款新颖小巧，功能强大的矢量绘制软件，让你轻松且高效地绘制各种流程图，网络图和商业图表。亿图图示，即亿图图示专家(EDraw Max)，是款基于矢量的绘图工具，包含大量的事例库和模板库。通过它可以很方便的绘制各种专业的业务流程图、组织结构图、商业图表、程序流程图、数据流程图、工程管理图、软件设计图、网络拓扑图、商业图表、方向图、UML、线框图、信息图、思维导图、建筑设计等等。破解激活说明：&nbsp;1、安装 EdrawMax，安装完成后不要运行，替换BaseCore.dll和ObjectModule.dll。2、运行注册机 EdrawMax 9.0[Shadow Mask].exe，生成你自己的注册码。3、断开网络，运行 EdrawMax，点击菜单“帮助-&gt;激活”，输入许可码后点击激活，因为禁止了软件联网，会出现一个错误对话框，关掉这个对话框，用生成的激活码手动激活。注意：1、和谐补丁释放的DLL劫持模块因加了VMProtect壳，故若有安全防护软件误报请忽略或排除！2、和谐补丁是用 Baymax Patch Tools 生成的 DLL 劫持补丁，生成的劫持 DLL模块加了 VMProtect 壳，若有杀毒软件报警可以选择忽略！3、如注册后启动还是试用版，可能是未能正常劫持，请把安装目录下的 msimg32.dll，version.dll，winmm.dll，uxtheme.dll，PYG.dll 这样名字的文件删除，重新运行 EdrawMax 和谐补丁.exe，勾选“选择释放”，一般 win7 X64 选中 msimg32.dll 和 PYG.dll 释放即可（msimg32.dll，version.dll，winmm.dll，uxtheme.dll 可任选一个，PYG.dll 必选）。下载地址：官方简体中文版下载地址http://www.edrawsoft.cn/2download/edrawmax-cn-9.3.exe破解补丁https://www.lanzous.com/i2ap86b",
    "postDate": "2019-01-30T23:40:45.3364498+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "亿图图示,亿图图示破解激活补丁,亿图,图示,思维导图,流程图",
    "id": 1221,
    "indexId": "Post:1221"
  },
  {
    "title": "当代大学生应该如何学习计算机科学",
    "author": "懒得勤快",
    "content": "我相信，看到这个标题并且愿意阅读往下阅读的你，一定是正在学习计算机，而自己感到迷茫，或者你还真在考虑要不要学习计算机科学，再或者你是想学计算机而不知道到底该怎么去学的，好，既然你是榜上有名的，那么久跟着小编我一起往下读吧。小编我只是一个曾经高考失败的学生，目前还在上大学，但是以我九年来对计算机的研究经验，我知道计算机这东西到底怎么学，这或许是我自己个人的看法，你们也许会有更好的学习方法，这我只是自学的而已，在大学学习计算机其实也差不多，对我所讲的，如果你信呢，请看下文，如果你不信我，随你吧！固然，我们之中必定有那么一些人，对计算机这个行业充满了喜爱和向往，我们这类人，虽然从事的是社会的底层工作，但以后必定是这个世界上的佼佼者，不管别人怎样看待我们，我们有属于我们自己的生活策略，我们是优秀的！首先，我要提出这样一个问题：学计算机的人非常多，全国上下三千多所高校，保守一点说，每个学校有500个学计算机的，还不包括其他的人，算一算其实计算机这方面的人还真不少，但为什么，目前这方面的人才仍然很稀缺？反思和吐槽：为什么，学计算机的人非常多，但目前这方面的人才仍然很稀缺？看到这个问题，我想问一下，你们都想过吗？我想你们都听过这样的一句话：大学毕业就等于失业。究其原因是什么？专业太烂？人才已经饱和？大学四年是混过来的？好，先排除那些大学四年混过来的说法，因为这一点，确实是，自己不学无术，肯定找不到工作的，就不说废话了；专业太烂了吗？其他的专业我不好说，因为我不太了解，但至少计算机这个专业小编我是知根知底的，有谁敢说这个专业不好，计算机是什么？是新时代的产物啊，是科技的象征啊，是未来的发展趋势啊，是我们每个人都离不开的啊。目前最有发展前景之一的行业就数计算机现在来说人才的问题，就打每年全国上下有300万人在一起学习计算机，那么你再看看每年这个行业的人才需求，学生毕业找不到工作，公司又招不到人，我呢，大学生活也快过了一半了，仔细想想，根源在于传统的IT教育和公司的人才需求是不对口的，公司需要的是什么？创新型人才，全面型人才，能够跟上时代发展的人才；而学校教的又是什么，大一一年都在学计算机基础，大二一年都在学C语言，到大三了还在学网页，大四就不说了，然而大学里的生活又是怎样一种情况，我想上过大学和正在上大学的也应该清楚：大一的时候看上去大家都差不多，都有兴趣就大家都学点，大二的时候开始出现两极分化现象了，觉得枯燥了，一半是不学的，一半是在学的，到了大三的时候，基本上就是一边倒了，还在学的也只有几个人了，到了大四，最终还有几个在坚持？在好大学是如此，在三流学校更是如此！先让小编来带着大家回顾下咱们的大学课程，几乎所有的计算机基础基本上都有教授，广度够了，但是深度远远不够，大学生能掌握的真正记住掌握有多少？不信随便抓几个学计算机的大学生来问，或许连html5是什么鬼都不知道！真正的大学课程，我觉得应该是这样的：博主曾经上大学的时候，老师各种照着PPT或者书本念，而小编我也是在下面插科打诨，老师说考的地方就拿出手机拍个照片，连笔记都懒得抄，碰到考试的时候，就拿出老师的PPT或照片背下就行了，而项目的考试几乎都能在网上找到下载，小编周围的同学也是在这样的模式下过大学四年。作为小编分析到最后都有些愧疚，最终选择退学。但是不得不说，大学计算机专业的课程几乎全部都是理论课程，老师照本宣科的读，而且有的课程好几年都没有升级，同时作为学生的我们也是各种浑水摸鱼，理论知识背下就应付考试，动手实战的编程学了四年却几乎为零。 当然“师傅请进门，修行在个人”，那既然小编在大学课程里学不到编程基础，还会另寻一条出路： 在网上看视频自学。在这里小编敢肯定很多人跟小编一样，但是小编学了一段时间也没能掌握编程基础！ 先说，小编以前也没有一条完整的学习流程，什么都想学，但是不知道从哪里来的下手，而且经常遇到一些连度娘都没有办法解答的技术问题。当然小编在自学的时候经常逛技术贴吧和论坛，跟小编一样很多自学的人数不胜数：“现在从零基础学Java了，有没有好的学习路线推荐”、“我是初学者，XXX问题求大神帮忙解决下”……在小编看来，虽然网上的资料多但是也很杂，如果没有一条完整的学习流程和路线，自学就像是“病急乱投医”，不仅不能“医病”，反而会“误病”。而且即使找到了一条符合自己的自学基础路线，但是在学习中遇到了编程基础难点的时候，在网上根本没有办法找到答案，没有老师给予一定的帮助，遇到某些问题时 花费更多的时间来寻找答案，大大降低了学习效果和效率。对于Java这样的技术性课程，没有专业的老师辅导和引导，自学是很难掌握编程所需要的所有基础。接下来说一下用人单位，用人单位招人很难！有同学看到“用人单位招人很难”这句话会感觉很困惑：全国这么多所大学，这么多学计算机专业的大学生，为什么用人单位还缺人？这就是因为企业的需求和大学的培养之间存在的巨大的鸿沟！&nbsp;&nbsp;&nbsp; 很多公司在招聘的过程中就经常遇到这样的奇葩事件：收到了十封一摸一样的简历，一看就是同班同学，内容就是“姓名、性别、毕业院校、电话、主干课程、自我评价”，最后一句“给我一个机会，我会给您一个惊喜”，凭什么呀！凭什么你大学是计算机专业的就要招聘你？用人单位的要求你要有扎实的专业技能：不能说学过java就敢说自己“精通java”，就大言不惭的去应聘java工程师，大学里学的离用人单位要求的还差很多。以下的两条招聘信息，你看一下你们在大学里都学的什么，而人家企业需要的又是什么。 到此，我想大家都明白这是为什么了吧。安排好自己的时间，多学一点东西在高中的时候，人人都梦想大学生活，然而，上大学却实现了你的这个梦想，很多人就抱着这样的一个心态：说高中的时候吧，时间太紧了，都没好好地放松放松一下自己，上大学一定要好好地玩过去，谈恋爱、玩游戏、周游世界…...完蛋了，四年过去了，啥都没学到！大学里的闲时固然很多，但是你都干了些什么？你以为就学点Office、学点C语言、学点html…毕业就能有好工作？做梦吧！就算你没基础，你就拿一年的时间出来专门打基础嘛，也不至于到毕业连一句System.out.println();是什么也看不懂啊。编程不是看出来的，不是背出来的，是一句句写出来的；看得懂是没用的，能照着抄是没用的，用自己的想法写出来才是真正掌握的！全力专攻专业知识，做一个纯技术的人才大学生活，大家都有目共睹，不少人为了不挂科，而花了大把的时间在与自己专业无关的学科上，其实我觉得这大可不必，像思修、高数、大学物理等这些课，没必要去学，应付应付就好了，如果你说思修学了有用，那我还不如推荐你学习程序员的自我修养，高数学了有用？那我还不如推荐你学习算法大全……，很多人就是还没有意识到自己上的是大学，还在以高中的那套学习方法在学习大学知识，为了这些与自己专业无关的课程死去活来的，如果你怕挂科，那既如此，你就应该更加努力的学习计算机专业知识了，你想，既然都是搞计算机的，好好钻研，学点攻防技术，就区区一个学校的教务系统，还怕黑不了？！呵呵，低调！还有，很多人说上大学后要参加什么什么协会、学生会之类的，这个有没有用呢？不能说绝对没用，至少说对计算机这个行业没什么卵用，协会和学生会之类的那是管理人员的天地，不是技术人员的地盘，你以后是搞技术的，不是搞管理的，即使你想成为管理层，那你也得先从技术做起，你得明确你的最终目的，切勿本末倒置！所以，多花点时间，学好计算机科学技术，才是王道。花了太多的时间在无关的课程上，何不把这些时间利用到自己的专业上，要懂得取舍，大学的生活才没有白过，不然，到最后，才真正的是大学上了你！时刻告诉自己：做一个纯技术的人才！我该如何选择世间自有公道，付出总有回报，说到不如做到，要做就做最好！这么多编程语言我到底应该学哪一个？现在流行的有很多编程语言：C#、Java、PHP、C++等，有同学会疑惑“这么多编程语言，到底哪个有发展前途，我到底应该学哪一个呢？”我的回答是“随便学一个就可以，但是不能今天学这个明天学那个，而是选择一门语言，深入学习下去，学完了一门再学下一门！”。我刚学也曾经迷茫过，学两个月的ASP、学一个月的VB、学两个月的PHP、又学了一个学期的VC++……什么语言都学了一遍，但是到最后发现什么语言都会，但是什么语言都不精通。我那时候的状态就像一个想学武功绝学的人，今天学降龙十八掌，明天学轩辕剑，后天又学九阴真经，最后发现自己走火入魔了。而如果能认认真真的把一门武功学会了，不要说学习降龙十八掌，就算我用十年时间把一锤砸死一个人的功夫练好了，我也是武林高手！2016年编程语言排行榜 TOP 20 榜单从上面可以看出，C、VB等语言仍然很靠前，但不建议大家学C和VB，靠前的原因是很多大学生要学，而不是真正开发的时候会用到，除非你有特殊要求，比如做嵌入式开发，驱动开发之类的底层的东西，否则不建议学习C语言。个人觉得，值得学习的语言：C#：最优美的语言Php：最好的语言Java：最健壮的语言Javascript：跑在浏览器里的跨平台语言Python：被公认为最简单的语言记住：就业需要什么，我才学什么！相信很多童鞋都是，老师教什么就学什么的，毫无自己的观念，前面也说了在大学里，确实学不了什么有用的东西，所以，我们应当实时的关注当今的社会发展情况，就业需要什么，我才学什么，如今网络这么发达，想了解一件事情还不简单吗？如何知道就业需要什么，当然就看各大公司的招聘信息，人家需要的人才应具备哪些技能，从这些信息中你就应该知道了就业需要什么，所以，学习过程中，你只需要牢记这一点：就业需要什么，我才学什么！上大学？or去培训机构？关于这个问题，我想很多人都想到了文凭这个点，那到底是上大学好呢，还是去培训机构好，这个就看你各人的抉择了，如果你在的大学是一所好大学，并且能学到真正实用的东西，那么你就在大学里好好学习；如果你在的大学实在太烂，学不了东西，那么我建议你可以放弃你的学历，去培训机构学习都比你混一个文凭强很多，如果你是名牌大学的，那么应该还是可以学点实用的东西的，如果是一般的学校，我相信是学不了什么东西的，计算机专业是如此，其他专业也是如此。如今国内的IT培训机构也算是比较强的，比如传智播客、潭州学院之类的都是比较牛逼的，当然，我这不是做广告啊，所以，上大学，还是去培训机构，就看你的大学怎么样了，我也只是建议，不代表权威。如何选培训机构：为了能更好更快的适应现代社会的竞争，人们越来越重视起自身教育技能学习与时代的同步发展。于是各种培训机构如雨后春笋般出现在我们的生活中。但是目前市场上各种培训机构鱼龙混杂，如何为我们事业的第二次起跑选择好培训机构就显得至关重要。当下，因为IT技术异常火热。这些培训机构先不谈讲师如何、师资怎样、学员成就，但是其广告却做的铺天盖地。而这也正是让众多想要进入这一行的人头疼的原因，那么这么多广告，到底哪家培训机构比较好？如何选择既适合自己又能花钱学到真知识的培训班呢？其实广告再多，再好，和我们选择又有什么关系呢？广告宣传的再好有啥用？结合本人的实际经验，给广大有意参加培训的朋友们一些建议，希望能帮助到大家解决选择培训机构时心中的疑惑。选择靠谱的培训机构得看五点：机构品牌、师资阵容、课程设置、实训项目、就业保障。机构品牌：名牌效应想必大家都有所耳闻，牌子响当当，质量才有保证，但是在选择培训机构时却不是这样的，鱼龙混杂的机构太多了，不是培训机构的牌子越响亮，就会有越好的资源供学员使用，要在看牌子的同时，多注意他们的口碑效应。师资阵容：古语曰，名师出高徒，此话不假。雄厚的师资力量才能更好的提升你的设计理念，提高你的技术能力，有些培训机构的老师不光是名师还是有名的严师。课程设置：现在互联网技术更新速度如此之快，学习老旧的设计课程完全跟不上时代的步伐，正如现在交互动效设计很潮流，但是部分培训机构的课程一丁点儿都没涉及其相关知识。实训项目：好的培训机构的项目全是企业级的，经过几个月的练习培训，是能达到相当于拥有1-2年工作经验的技术水平。就业保障：机构吹的再好都不如学员的高薪就业来的实在。参加培训说白了，就是为了找个好工作，学员就业不好就证明这个培训机构不够好，所以一定要擦亮眼睛。要学习计算机专业如何选大学：至于选学校，我想大家心里或多或少也是有一定的数的，一般的学校，你想学到东西那基本上不可能，当然，你有实力上一所好的学校学计算机专业，那应该可能还算是比较靠谱的，大学的这个问题，这个在前面也提到了不少，大家自己看着办吧。呵呵了。假学习？or真学习？什么叫做假学习？一、看书买一堆书，有空看看。看书，这是典型的假学习。看书看不懂还在看，就是假学习，欺骗自己，安慰自己正在学习而已。专业书都写得很好，但大都是写给已经懂的人看的。看书的最大作用就是证明自己看书是学不到东西的，然后只有寻找其他途径。建议：把书合上，想一想，你想学的东西到底是要干什么用的，要掌握到什么程度才够用。实在不行，快速看完，也好过慢慢磨着看完，当你觉得什么时候去看，可以看懂了再去看，还是那句话，不是不看，看的时机对不对而已。二、听课听课，记笔记。很常见的假学习，听课听不懂，要听来干甚，难道就是为了听课而听课。真正的课程是要用来发现疑问，表达疑问，表达理解的，而不是用来听的。别人讲的内容很细致，而且都是对的，可以说是经验的精华，但是别人无法代替你大脑的运转过程，无法代替你大脑逻辑的形成的过程，听得越多学得越慢，IP地址怎么配还不清楚，就在听OSPF的内容有用吗？听课的最大作用就是证明听课是学不到什么东西的，然后寻找其他的途径。建议：大概可以这么说，你如果在听课前没有带着足够多的问题，去听基本没什么意义，先有框架出来再说，讲的人可以给你总结、点拨的作用，加深理解。起码要把听课的内容先自己动手操作过1-2遍。三、实验单纯敲实验，和打字是没什么区别的，操作手册可以告诉我们结果和机理，敲1遍只是练习了命令输入，只有第2遍，才会有一些些思考。敲实验最大的作用，就是证明，敲完了还是不懂，所以必须寻找其他的途径。建议：做到不看操作指南，能总结出全部配置步骤和调试步骤。而且能够自己设计扩展实验调试内容。四、看贴每个帖子可能都是经过很多时间研究的心得，写得再好，只看的话，也还不是自己写的。看贴不回帖，只懂顶，都是假学习。建议：只有自己写贴，写不出来，才发现思路不够严谨；写得不好，才会发现理解得不够透彻。看贴要发别自己的心得，参与讨论。什么叫做“真学习”？一、攻击先问你一个问题，你懂什么，“什么都不懂”，好，你懂IP地址怎么写吗？OK，写出来，请问“为什么要用IP地址?”。连自己懂什么都不知道，知道哪些是真正要懂的。二、思考收到一个报文后，怎么解封装？发送一个报文，如何封装？记住一堆概念是没有用的，你必须把数字的信息转换成抽象的信息存储在大脑里，并且逻辑和系统同步，不断训练思考才能做到。三、忘却真正学会了，就可以开始忘却了，任何一个问题，你都可以不懂。专家回答问题时，经常会说：“这个问题我没遇到过、这个问题我不清楚、这个问题我不懂。”，但是后面半句话，专家从来不说出来，“只要我想去了解和解决，只需要5-10分钟就能找到答案。”专家的大脑里只保存思路和方法，而不是细节，可以迅速解决任何问题，而问问题的人，只记住很多具体的解决方法，超出这个范围就不会了。学习一个东西，分2个步骤：1、学懂；2、忘记。真正的忘却不是因为记忆的衰退，而是放下来，问题本身已经完全被粉碎于无形之中。四、表达自认为学会了不是真正的学会，真正的学会，在于能够讲出来，使一个初学者也能够听得明白，才能算是学会了，不会表达，永远学不会。懂了，却举不出例子来，怎么能够叫做懂了呢？这么多技术我该怎么学经常有同学问“这么多技术我该怎么学，某某和某某两个技术哪个更有前途”。因此我写了这个小节，也算是和大家的一个交流常见总结吧。一、这多东西啥时候能学完？现在IT新技术日新月异。就常用编程语言而言,有c/c++、汇编、java，c#、Python等；操作系统平台有unix/linux，windows系列；开发工具有VC、VisualStudio、Eclipse、NetBeans等；每个大平台下，还有很多的的方向：如网络、数据库、脚本、HTML、动态网站、游戏开发等；有人还在学Dreamweaver做网页、Flash做动画、Photoshop做美工、3DMax做三维动画…………是的，我们什么都想学。恨不得把所有的知识统统都塞到肚子里去。看到什么，想学什么！今天看这VC的书，明天又看Java，后天又看C#，东搞西搞！看到别人做网页。自己兴趣了来了。好，学html语言，我也做网页，听说做网页要会“网页三剑客”，所以又想学Dreamweaver、Flash。后来开始知道有JSP、PHP、ASP.NET做动态网站这玩意儿。也想去学，学学学……这是几乎所有在校大学生的通病。但是，这不是坏事，甚至可以说是好事。说明了你“求知欲”高！总比那些，生活没有激情，整天知道泡妞、上网、打游戏、混日子的强。但是如果你今天想学这个，明天又想学那个。这样你就能永远徘徊在技术的门外。很多人都有过或者正在经历这样的苦闷日子：总觉得有“太多东西”要学了，然而人的精力是有限的，总有永远学不完的感觉，所以心理特别急，整天惶惶不可终日，不知道先要学哪个，一会儿拿起这本书，一会拿起那本书，折腾了几个月，突然发现自己什么都没有学到……每一个大方向如果没有上几年的学习，很难能学习出什么来。但程序设计的最根本的东西是相同的。所以我们学习要抓根本。俗话说：通一理，融百里。学程序设计就像习武一样，如果内功学的好，其他功夫就很容易上手。君不见《倚天屠龙记》中的张无忌练了“九阳神功”8年，练“乾坤大挪移”只需12个时辰吗?习武之人，谁不想在“江湖”上扬名立万，谁不想成为万人敬仰的大侠？大侠之所以能成为“大侠”，当然有他们的看家本领。狄云的“神照神功”，金世遗的正邪融合的“乔北冥内功心法”，张无忌的“九阳神功”，段誉的“六脉神剑”，令狐冲的“独孤九剑”，哇，太多了...古人历经千辛万苦才能找到这些“武功秘籍”。我们现在这些后辈，比起古人来说：简直太幸运了。去书店，各种各样的心功心法，剑法，拳法，应有尽有，看得你眼花缭乱...你选什么呢？今天练“六脉神剑”几式，明天去学“降龙十八掌”几招，后天又去练“发暗器”，这样何时才有个尽头呢？你说，你什么武功都会，但是“形似而神不似”，不得要领，不够火候。一上擂台，就被别人一掌打趴了。试问哪个软件公司敢要一个号称任何编程语言都会，而是每种语言只能写出个“hello world！”的程序员，你不被人家扫地出门才怪。二、学**还是学**更有前途？看了上面的话，有的同学已经开始烦了，“知道了知道了，不止一个像你这样的所谓的‘老前辈’跟我说过‘学什么都一样，思想才是最重要’的大道理，可是你们站着说话不嫌腰疼呀，现实是有很多技术需要学，比如做Web开发就有JSP、PHP、ASP.NET等好多方向，我总得选一个吧！到底学哪个有前途呢？我必须要选择一个有前途的，选错了就麻烦了。”其实像“学**还是学**更有前途”的话没意义，因为“选择JSP还是选择PHP”的前途的差别不像“选择英语还是选择日语”的前途差别那样大，不存在“选错方向”的问题，因为都是相通的，你也不能保证你毕业以后搞的就是你学的那个方向，更不能保证你靠你学的这点东西就能吃一辈子。比如我上大学的时候一直在钻研是Delphi语言，可是毕业校园招聘的时候我照样在Java职位的考试取得了第一名，而且工作以后经过简单的学习就掌握了Java语言，并且后来还写了三本关于Java语言的书；再如我毕业后两年多的时间一直在用Java开发，后来公司要做一套基于.NET的产品，我只用了一个礼拜熟悉了.NET体系以及C#的语法，然后就开始进行开发。不过就像上边说的“做Web开发就有JSP、PHP、ASP.NET等好多方向，我总得选一个吧！”这个问题是非常实际的，因为只有先学一个才能深入这个方向，把这个方向学通了才能想以后“一通百通”。因此我的建议就是学校教过什么语言，你就继续深入学习这么语言，而不要去问“这么语言有没有前途”这样的傻问题。尽量不要去学一门所谓“有前途”的新语言，因为你去学一门新语言就要把很多精力耗费在语言、语法本身，而耽误了编程的实战，而以一个已经学过的语言来学习的话，起码语法本身不用再去学、开发工具本身不用再去熟悉，只要研究怎么使用这门语言开发有用的程序就ok了。比如大部分同学都学过C语言（有的学校直接开了C++的课，但是C++的面向过程编程部分还是C语言），所以咱们就开了用C语言写Windows程序、用C语言写网络程序、用C语言写游戏的课程，让同学们把精力放到学以致用上，而不是学“有前途”的新语言上，这也是这个思想的一个体现。总结一下，不要管“哪门语言好就业、有前途”，因为那些“好就业、有前途”都是纸老虎。尽量不要学新语言，从自己最熟悉的语言入手，深入研究，出山后你就是被用人单位争抢的红人。FAQ：什么年龄适合学电脑？这是一个看似简单、其实很复杂的问题。所谓简单，即似乎只要用一个数字就可以回答：6岁、10岁或20岁。说它复杂，是因为这个“学“字可以有不同的理解和不同的层次。是学习电脑的技术还是学习专业知识？是学习操作还是学习应用？是仅仅和电脑交朋友还是要熟练地掌握？不同的层次、不同的要求就有不同的回答。对于绝大多数人来说，学习电脑不是为了成为一名计算机专家，而是为了应用。因此，我仅在这一学习层次内谈谈自己的看法。学好编程一定要有数学和英语功底吗？对于这个问题，我觉得编程跟英语和数学没任何联系，只要你会加减乘除、认识26个英文字母，那就具备了学编程的功底了，只要你有恒心，有兴趣学习编程，那就一定能学会编程，小编我也是英语盲和数学盲，但并没有对我编程产生任何影响啊，只是在阅读一些英文的API文档会有些困难，但也没关系啊，有翻译工具啊，而且有很多单词见多也就潜移默化了，至于数学，如果不是玩图形学神马的，完全不用学数学。所以，编程对于任何人都是没任何门槛的。要学编程，一定要先学C语言吗？C语言算是元老级的语言，但由于其特殊的应用场景，语法上也没有C#、java等看上去那么舒服，并且不易学，很多人说学编程一定要有C语言基础那是因为填鸭式教育的孽根，是很多大学生为了应付二级考试才学C语言的，但其并不好学，所以如果是专门要从事软件行业的话不建议大家学习C语言，要学的话，等以后软件开发基本精通了之后，再回过头来学习C语言，因为以后玩架构和设计模式之类的会用到C语言的思想。拒绝纸上谈兵，会玩才会学很多童鞋在学习的时候都有一个通病和怪病，那就是听老师讲的时候啥都懂了，但自己敲代码的时候就完全不会了，究其原因，还是因为自己还在用中国式教育思想在学习编程，学编程这东西，一定要注重实际，一定要动手，听老师讲听懂了，只证明你学懂了10%，你如果跟着老师动手敲代码，那你就学懂30%了，在课后你如果能跟着老师的思路，对照着笔记敲出代码，那你就学懂50%了，如果能完全按自己所记得的思路，敲出代码实现相应的功能，那你就学懂70%了，那怎样的程度才算是100%学懂了呢，相同的功能，你如果能熟练的写出代码，并且能对代码进行优化改造或者能够以不同的途径实现相同的结果，那你就真正学懂这个知识点了！真正学懂的过程：听老师讲懂(10%)→跟着敲代码(30%)→看笔记写代码(50%)→按自己的思路写代码(70%)→以不同的思路实现代码(100%)听老师讲百遍，不如去动手实现一遍！所以，拒绝纸上谈兵，会玩才会学！计算机专业考什么证有用？有一些没有社会经验的同学经常问“程序员IT认证有用吗？软件工程师考证有必要吗？是否应该考几个认证？”等之类的问题。我个人的看法是，从事技术类的工作不要相信任何的证书，不要做考证一族，因为这些证书只是砸钱的，毫无任何价值，以后工作面试的时候，人家不会关心你有什么证，人家只需要有真本事的，看你能力怎么样，证书并不能证明什么，人家直接问你技术类的问题，你答得上来，那就OK，答不上来，拿出证书来显摆反而还丢自己的脸！编程到底有什么用初学者或许都会产生这样的一个问题：就是感觉一直在敲代码，一直看教学视频，感觉是还没发现编程到底有什么用？成天就只能写黑底白字的程序，感觉没什么用。对于这样的问题，我的看法是：编程的意义就在于用技术解决实际的问题。比如有人编程写出了浏览器，所以我们每个人都可以坐在电脑前浏览世界；有人编程写出了游戏，所以我们可以用它来kill time；有人编程写出了会计软件，所以我们就可以轻松的管理我们的账务；有人编程写出了word，我们就可以轻松的实现排版，而不用浪费大量的纸张进行打印测试。 &nbsp;你发现编程没用是因为你现在学的都是零件，就像一个刚学武术的人师傅让他蹲马步，他肯定会说“让我蹲马步有什么用？还是教我必杀技吧”，可是连马步都蹲不稳，怎么能发必杀技呢？也可以类比学机械的人学齿轮的原理，估计也会问“整天学齿轮的力学原理，什么时候能设计一辆汽车出来呀”，也是那个道理，连一个齿轮都设计不出来，何谈设计汽车呢？ &nbsp;现在的主要问题还是“零件”学的太少，多学一些零件，有了拼装的基础，自然就可以写出有实用价值的软件了。所以先踏实的“积攒零件”吧，厚积薄发。切务浮沙筑高台,练从难处练,用从易处用！无速成，唯有坚持！总结没有一蹴而就的成功，也没有无地基的大楼。只有过硬的技术才能在同等竞争中立于不败的地位，才能在程序员走这条路上越走越好，越走越远！坚持就是胜利学习是一个很漫长和复杂的过程，如果你决定要进入计算机这个行业学习和发展，那么你一定要坚持下来，切忌三分钟热度、半途而废，因为小编我也是知情人，很多人刚开始对计算机很有兴趣，但是过一段时间之后，可能会觉得这东西很费脑，不是那么好玩的，便会出现放弃的念头，坚持就是胜利！既然你当初做出了你的选择，那么你就一定要让结果对得起你的选择，告诉自己：人生无悔！成功其实也不难，只要树立一个目标，不需要你是一个很强的人，不需要你很高智商，不需要你是千里马，你只要像老黄牛一样，每天哪怕做一点点，往目标前进一点点，你就会成功。可是成功又很难，因为在通往成功的路上，很少人能够坚持下来，在坚持的过程中，很多人都选择了放弃。一定要记住：不管在什么地方，工作不养闲人，团队不养懒人。赚不到钱就赚知识，赚不到知识就赚经历，赚不到经历就赚阅历！只有改变自己的态度，才能改变人生的高度。让人迷茫的原因只有一个，那就是本该拼搏的年纪，却想得太多，做得太少。毕竟一份耕耘一份收获！在计算机的世界里，还有着很多的人生哲理可以发现，从计算机科学中感悟人生，享受计算机的浪漫，悟生存之道，学会怎样做一个人，在快乐中学习，以后你也是一个顶尖级的计算机专家！各位小伙伴们，努力、拼搏、加油！世界属于我们，我们是世界的创造者！",
    "postDate": "2019-01-30T23:40:45.3365114+08:00",
    "email": "admin@masuit.com",
    "label": "大学生活",
    "keyword": null,
    "id": 175,
    "indexId": "Post:175"
  },
  {
    "title": "MathType数学公式编辑器（7.3.1.438）汉化破解版",
    "author": "懒得勤快",
    "content": "博主在网站后台看到大家也经常搜索这软件，所以博主也把这软件给大家扒来了。MathType作为一款数学公式编辑器，自从发行以来就备受理工科人们喜爱。受助它在编辑公式方面的强大功能，MathType也在不断更新以满足人们的需要。目前发行的新版本中，新增了一些功能。软件介绍* MathType适用人群MathType使用人群主要集中在学生、教师以及理科专业工作者，可应用于教育教学、科研机构、工程学、论文写作、期刊排版、编辑理科试卷等。* 兼容各版本OfficeMathType与Office有很好的兼容性，支持各版本的Office软件，如Microsoft Office 2016、Softmaker Office、WPS Office等。* 多平台支持MathType可适用于800+软件应用程序和网站，支持在任何文字处理软件、演示程序、页面程序、HTML编辑工具及其它类型的软件，用来建立公式。* 支持手写MathType&quot;编辑&quot;菜单中的“打开输入数学面板”支持手写输入公式，智能识别手写内容，轻触鼠标编写即可完成。* 所见即所得添加公式时，点击MathType界面中的模板，模板的样式就直接显示在MathType编辑框内，对此模板进行适当的修改就完成公式的编辑任务。* 自动化处理MathType中的Translator支持一键转换为Latex、Amslatex等代码，并提供常用数学公式和物理公式模板，只需单击一次，这个公式便跃然纸上。破解方法* 将Crack文件夹内的MathType.exe替换程序安装目录的同名文件，即可。*&nbsp;如果安装时报错Office插件不能用，请在C:\\Program Files\\Microsoft Office\\Office16\\下创建Startup文件夹，等安装完毕后将crack文件夹里的对应Office位数的MathType Commands 2016.dotm复制到Startup文件夹里即可。下载地址软件安装包来自于MathType国外官网，与思杰马克丁没有任何关系。看样子确实是挂了，推荐大家用AxMath来代替吧。https://masuit.com/1280官方安装包：https://store.wiris.com/zh/products/downloads/mathtype/installer/windows/zh7.3.1.438破解补丁：稀缺资源统一下载地址页7.3.1.438激活码：1B3NV-J59Y5-WZ7TM-JE222-JLZ3U早期版本:稀缺资源统一下载地址页",
    "postDate": "2019-01-30T23:40:45.3365873+08:00",
    "email": "admin@masuit.com",
    "label": "Math,公式编辑器",
    "keyword": "MathType,Math Type,MathType数学公式编辑器,数学公式编辑器,公式编辑器",
    "id": 1230,
    "indexId": "Post:1230"
  },
  {
    "title": "Adobe CC Family 2019 v9.2#1 全家桶大师直装破解版下载",
    "author": "懒得勤快",
    "content": "PhotoshopCC官网宣传视频您的浏览器不支持 video 标签。目前破解已知问题：1、主页问题（详见后文）2、Lightroom Classic CC安装后，启动并随便登陆一个有效的ID，登陆成功后（在抱歉，出现错误。界面）点击忽略即可。&nbsp; &nbsp; &nbsp;本破解不受试用时间限制，启动时短暂的登录框不影响使用（本阶段需联网）。=====================================================================更新日志2018.11.20 v9.2 #1更新LR破解补丁版本2018.11.20 v9.1 #2修正Bridge初始化缓存错误循坏更新 Adobe InDesign CC 2019.0.1 (14.0.1.209)2018.11.17 v9.1 #1移除 Adobe Muse CC 2018.1集成 Adobe XD CC 13.1.12更新 Adobe Acrobat DC 2018 连续版 2019.008.20081更新 CCXP 版本 2.5.2现在所有APP的离线主页均可正常工作。2018.11.15 v9.0 #11更新 Adobe Acrobat DC 2018 连续版 2019.008.20081现在所有APP的离线主页均可正常工作。2018.11.13 v9.0 #10更新Br破解补丁版本2018.11.11 v9.0 #9更新LR破解补丁版本细节完善2018.11.8 v9.0 #8更新 Adobe Photoshop CC 2019.0.1 (20.0.1.17836)2018.11.6 v9.0 #7更新 AE、AME、PR破解补丁版本2018.11.2 v9.0 #6更新 Adobe Bridge CC 2019.0.1 (9.0.1.216)更新 Adobe InDesign CC 2019.0.1 (14.0.1.202)更新 Adobe Media Encoder CC 2019.0.1 (13.0.1.12)更新 Adobe Premiere Pro CC 2019.0.1 (13.0.1.13)2018.10.29 v9.0 #5更新 Adobe Illustrator CC 2019.0.1 (23.0.1.540)集成 Adobe Dimension CC 2.0更新破解补丁版本，PS修复授权现在大师版和SP版不再需要断网或改HOST，直接跳过登录ID2018.10.28 v9.0 #4更新破解补丁版本，AE修复HEVC，BR修复CameraRaw2018.10.26 v9.0 #3更新破解补丁版本，AME、PR修复HEVC2018.10.20 v9.0 #2更新破解补丁版本，AE、AME、PR、LTRM、BR暂需补丁更新2018.10.15 v9.0 #1更新 Adobe Creative Cloud，版本 4.7.0.400更新 Adobe Acrobat DC 2018 连续版 2019.008.20080更新 Adobe After Effects CC 2019 (16.0.0.235)更新 Adobe Animate CC 2019 (19.0.0.326)更新 Adobe Audition CC 2019 (12.0.0.241)更新 Adobe Bridge CC 2019 (9.0.0.204)更新 Adobe Character Animator CC 2019 (2.0.0.257)更新 Adobe Dreamweaver CC 2019 (19.0.0.11193)更新 Adobe Illustrator CC 2019 (23.0.1.540)更新 Adobe InCopy CC 2019 (14.0.0.130)更新 Adobe InDesign CC 2019 (14.0.0.130)更新 Adobe Lightroom Classic CC (8.0.0.10)更新 Adobe Media Encoder CC 2019 (13.0.0.203)更新 Adobe Photoshop CC 2019 (20.0.0.13785)更新 Adobe Prelude CC 2019 (8.0.0.129)更新 Adobe Premiere Pro CC 2019 (13.0.0.225)更新 Adobe Photoshop Camera Raw (11.0.0.78)移除 Adobe Encore CS6移除 Adobe ExtendScript Toolkit CC移除 Adobe Extension Manager CC移除 Adobe Fireworks CS6移除 Adobe Photoshop Elements移除 Adobe Premiere Elements移除 Adobe SpeedGrade更新大师版、SP独立版为ACC HD架构。仍然一键安装，无需登录ID，无需断网改HOST，可以选择安装语言，自定义安装路径。所有版本默认不安装ACC，如需要可安装ACC。=====================================================================【赢政天下 Adobe CC Family (CC 2018) 大师版】本版语言：简体中文、正體中文、日本語、English注：部分内置多国语言=====================================================================本版集成的版本：本版集成的版本：Adobe Acrobat DC 20192019.008.20081Adobe After Effects CC 201916.0.0.235Adobe Animate CC 201919.0.0.326Adobe Audition CC 201912.0.0.241Adobe Bridge CC 2019.0.19.0.1.216Adobe Character Animator CC 20192.0.0.257Adobe Dimension CC2.0Adobe Dreamweaver CC 201919.0.0.11193Adobe Illustrator CC 2019.0.123.0.1.540Adobe InCopy CC 201914.0.0.130Adobe InDesign CC 2019.0.114.0.1.209Adobe Lightroom Classic CC8.0.0.10Adobe Media Encoder CC 2019.0.113.0.1.12Adobe Photoshop CC 2019.0.120.0.1.17836Adobe Prelude CC 20198.0.0.129Adobe Premiere Pro CC 2019.0.113.0.1.13Adobe XD CC13.1.12Adobe Photoshop Camera Raw11.0.0.78注：1：系统需求：64位 Windows 10 最新版本。不推荐安装在Win7x64或旧版Win10x64上，会有功能缺失和BUG。2：硬件需求：简单地说，Adobe CC 2019 必须要较新的各类软硬件支持。系统需要Windows 10 最新版本（1809/17763）。CPU核心数至少4核，建议6核或以上。内存至少12G，建议16G或以上。独立显卡至少在2014年以后发布的，支持DirectX 12、OpenGL 4.x，安装了最新的、完整的驱动程序。不建议集成显卡，驱动程序版本至少2015年或更晚发布的。配置高性能硬盘，保持足够的剩余空间。（建议三星或Intel最新的NVME硬盘，系统盘剩余容量在100G以上）具体的系统需求请见：Adobe After Effects CC 2019https://helpx.adobe.com/cn/after-effects/using/memory-storage1.htmlhttps://helpx.adobe.com/cn/after-effects/using/rendering-opengl.htmlhttps://helpx.adobe.com/cn/after-effects/using/improve-performance.htmlAdobe Illustrator CC 2019https://helpx.adobe.com/tw/illustrator/system-requirements.htmlhttps://helpx.adobe.com/cn/illustrator/kb/optimize-illustrator-performance-windows.htmlhttps://helpx.adobe.com/cn/illustrator/kb/gpu-performance-preview-improvements.htmlhttps://helpx.adobe.com/illustrator/kb/gpu-performance-errors-troubleshooting-workarounds.htmlAdobe Lightroom Classic CChttps://helpx.adobe.com/cn/lightroom/kb/optimize-performance-lightroom.htmlhttps://helpx.adobe.com/cn/lightroom/kb/lightroom-gpu-faq.htmlAdobe Photoshop CC 2019https://helpx.adobe.com/cn/photoshop/kb/optimize-photoshop-cc-performance.htmlhttps://helpx.adobe.com/cn/photoshop/kb/photoshop-cc-gpu-card-faq.htmlAdobe Media Encoder CC 2019https://helpx.adobe.com/cn/media-encoder/system-requirements.htmlAdobe Premiere Pro CC 2019https://helpx.adobe.com/cn/premiere-pro/system-requirements.html以上文档会随版本更新而更新。3: 本版集成 Adobe Acrobat DC 特别版，&nbsp; &nbsp;集成新版AMTLIB模拟破解(v0.9.2)。&nbsp; &nbsp;集成最新版AAMv10(CS10)/ACCC SP。&nbsp; &nbsp;移除试用提示。&nbsp; &nbsp;移除自动更新，移除菜单更新。&nbsp; &nbsp;打开、保存文件时不显示在线存储。&nbsp; &nbsp;启动欢迎页不显示资讯。&nbsp; &nbsp;最近使用列表中的最大文档数量默认为零。=====================================================================安装流程：&nbsp; 百度云下载大文件非常容易出现坏档，下载压缩包后注意校验。&nbsp; 压缩包包含5%的恢复记录(rr%5)，请尝试使用 WinRAR 修复损坏的分卷、改回原名后重新解压。&nbsp; WinRAR 5.0以上版本解压；用虚拟光驱加载ISO，不要解压ISO。&nbsp; 解包而不使用镜像安装请务必注意不要将安装程序放置在过长的路径下导致的安装失败！&nbsp; 本版分为大师版和独立版，可根据个人需要安装。&nbsp; 大师版、独立版均为一键安装，一般无需任何操作。---------------------------------------------------------------------关于VC运行库问题：&nbsp; ACC HD封装的安装程序会自动安装所有最新版本的VC运行库，无需手动安装。&nbsp; 如遇到与VC运行库有关的错误，请自行搜索修复VC运行库教程，并排除第三方软件干扰可能。---------------------------------------------------------------------清理残留的安装、激活信息问题：&nbsp; 因新版本不存在离线激活，无需清理激活信息。&nbsp; 如需要清除单独的App或ACC、强制清理ADOBE ID信息，可使用官方清理工具清理。然后手动删除残留文件夹和文件。&nbsp; Adobe 公共文件夹目录：&nbsp; C:\\Program Files (x86)\\Common Files\\Adobe---------------------------------------------------------------------关于 Lightroom Classic CC 的破解&nbsp; &nbsp;由于目前的破解无法直接使用Develop模块（修改照片），故本版破解改用登录ID解决这个问题。&nbsp; &nbsp;Lightroom Classic CC安装后，启动并随便登陆一个有效的ID，登陆成功后（在抱歉，出现错误。界面）点击忽略即可。本破解不受试用时间限制，启动时短暂的登录框不影响使用。关于部分程序的首页一直正在载入、显示剩余天数等问题&nbsp; &nbsp;CC 2019的首页是需要登录ID由CCXP验证并下载额外数据后由软件获取显示，破解后默认无ID登录当然不会有主页信息了。&nbsp; &nbsp;After Effects CC 2019、Adobe Premiere Pro CC 2019的主页无需登录即可正常显示主页，若登录ID、主页可能会显示剩余天数或试用结束，请无视之，不影响使用。&nbsp; &nbsp;登录ID后，主页就可以正常显示。若不登录ID，则Adobe Illustrator CC 2019、Adobe Photoshop CC 2019、Adobe InDesign CC 2019等主页会无限正在加载（CCXP会卡在登录ID阶段）。&nbsp; &nbsp;Adobe Illustrator CC 2019 关闭主页&nbsp; &nbsp;首选项-&gt;常规-&gt;未打开任何文档时显示主屏幕&nbsp; &nbsp;Adobe Photoshop CC 2019 关闭主页&nbsp; &nbsp;首选项-&gt;常规-&gt;停用“主页”屏幕&nbsp; &nbsp;Dreamweaver CC 2019 关闭主页&nbsp; &nbsp;首选项-&gt;常规-&gt;显示开始屏幕&nbsp; &nbsp;Adobe InDesign CC 2019暂无法关闭主页，不影响使用。&nbsp; #注意登陆过ID然后退出而CCXP未停止的，首页是不变的。关于库功能&nbsp; 目前部分APP无法使用&nbsp; 现阶段破解暂时只能如此。配合登录ID可取得较好的使用效果。---------------------------------------------------------------------&nbsp; 本版使用的是EXE/DLL PATCH + EMU 混合破解处理。&nbsp; 除Acrobat，任何App自动更新均需ACC操作，未安装ACC或默认下不会自动更新。&nbsp; ##注意## 任何App经过ACC自动更新后均需要重新破解！&nbsp; 手动更新：等待本特别版的更新，覆盖安装新版即可。---------------------------------------------------------------------&nbsp; 除非熟悉破解的原理和细节，否则不要随便重复或自行更换破解，以免出现未知问题。=====================================================================&nbsp; 对部分App有语言切换需要的说明（仅限本版及以上，部分为多国语言）&nbsp; Adobe 现有App均为系统语言自适应，需要直接切换语言时操作如下：&nbsp; After Effects CC 2019&nbsp; 通过application.xml文件修改启动语言(.\\Support Files\\AMT\\application.xml)&nbsp; 第171行&lt;Data key=&quot;installedLanguages&quot;&gt;*****&lt;/Data&gt;修改为所需语言&nbsp; 可用语言：de_DE|en_US|es_ES|fr_FR|it_IT|ja_JP|ko_KR|pt_BR|ru_RU|zh_CN&nbsp; Animate CC 2019&nbsp; 重新安装，选择需要的语言安装后（仅限SP版）&nbsp; 通过application.xml文件修改启动语言(.\\AMT\\application.xml)&nbsp; 第173行&lt;Data key=&quot;installedLanguages&quot;&gt;*****&lt;/Data&gt;修改为所需语言&nbsp; 可用语言：cs_CZ|de_DE|en_US|es_ES|fr_FR|it_IT|ja_JP|ko_KR|mul|nl_NL|pl_PL|pt_BR|ru_RU|sv_SE|tr_TR|zh_CN|zh_TW&nbsp; Audition CC 2019&nbsp; 通过application.xml文件修改启动语言(.\\AMT\\application.xml)&nbsp; 第167行&lt;Data key=&quot;installedLanguages&quot;&gt;*****&lt;/Data&gt;修改为所需语言&nbsp; 可用语言：de_DE|en_US|es_ES|fr_FR|it_IT|ja_JP|ko_KR|pt_BR|zh_CN&nbsp; Bridge CC 2019&nbsp; 首选项-&gt;高级-&gt;国际-&gt;语言&nbsp; Dreamweaver CC 2019&nbsp; 重新安装，选择需要的语言安装后（仅限SP版）&nbsp; 通过application.xml文件修改启动语言(.\\AMT\\application.xml)&nbsp; 第27行&lt;Data key=&quot;installedLanguages&quot;&gt;*****&lt;/Data&gt;修改为所需语言&nbsp; 可用语言：cs_CZ|da_DK|de_DE|en_AE|en_GB|en_IL|en_US|en_XM|es_ES|es_MX|fi_FI|fr_CA|fr_FR|fr_MA|fr_XM|hu_HU|it_IT|ja_JP|ko_KR|nl_NL|pl_PL|pt_BR|ru_RU|sv_SE|tr_TR|uk_UA|zh_CN|zh_TW&nbsp; Illustrator CC 2019&nbsp; 重新安装，选择需要的语言安装后（仅限SP版）&nbsp; 通过application.xml文件修改启动语言(.\\Support Files\\Contents\\Windows\\AMT\\application.xml)&nbsp; 第5行结尾&lt;Data key=&quot;installedLanguages&quot;&gt;*****&lt;/Data&gt;修改为所需语言&nbsp; 可用语言：fr_FR|it_IT|uk_UA|nl_NL|en_US|hu_HU|ja_JP|fr_MA|en_IL|es_ES|en_GB|en_AE|ru_RU|zh_TW|pt_BR|da_DK|ko_KR|cs_CZ|tr_TR|de_DE|es_MX|fr_CA|zh_CN|sv_SE|pl_PL&nbsp; InCopy CC 2019&nbsp; 重新安装，选择需要的语言安装后（仅限SP版）&nbsp; 通过application.xml文件修改启动语言(.\\AMT\\application.xml)&nbsp; 第172行&lt;Data key=&quot;installedLanguages&quot;&gt;*****&lt;/Data&gt;修改为所需语言&nbsp; 可用语言：cs_CZ|da_DK|de_DE|en_AE|en_GB|en_IL|en_US|es_ES|es_MX|fi_FI|fr_CA|fr_FR|fr_MA|hu_HU|it_IT|ja_JP|ko_KR|nb_NO|nl_NL|pl_PL|pt_BR|ru_RU|sv_SE|tr_TR|uk_UA|zh_CN|zh_TW&nbsp; InDesign CC 2019&nbsp; 重新安装，选择需要的语言安装后（仅限SP版）&nbsp; 通过application.xml文件修改启动语言(.\\AMT\\application.xml)&nbsp; 第4行结尾&lt;Data key=&quot;installedLanguages&quot;&gt;*****&lt;/Data&gt;修改为所需语言&nbsp; 可用语言：cs_CZ|da_DK|de_DE|en_AE|en_GB|en_IL|en_US|es_ES|es_MX|fi_FI|fr_CA|fr_FR|fr_MA|hu_HU|it_IT|ja_JP|ko_KR|nb_NO|nl_NL|pl_PL|pt_BR|ru_RU|sv_SE|tr_TR|uk_UA|zh_CN|zh_TW&nbsp; Lightroom Classic CC 8.0&nbsp; 首选项-&gt;常规-&gt;语言&nbsp; Media Encoder CC 2019&nbsp; 首选项-&gt;外观-&gt;语言&nbsp; Muse CC 2018&nbsp; 首选项-&gt;常规-&gt;语言&nbsp; Photoshop CC 2019&nbsp; 重新安装，选择需要的语言安装后（仅限SP版）&nbsp; 首选项-&gt;界面-&gt;文本（用户界面语言）&nbsp; Prelude CC 2019&nbsp; 通过application.xml文件修改启动语言(.\\AMT\\application.xml)&nbsp; 第169行&lt;Data key=&quot;installedLanguages&quot;&gt;*****&lt;/Data&gt;修改为所需语言&nbsp; 可用语言：en_US|en_GB|en_AE|en_IL|de_DE|es_ES|es_MX|fr_FR|fr_CA|fr_MA|it_IT|ja_JP|ko_KR|zh_CN|pt_BR|ru_RU&nbsp; Premiere CC 2019&nbsp; 通过application.xml文件修改启动语言(.\\AMT\\application.xml)&nbsp; 第4行结尾&lt;Data key=&quot;installedLanguages&quot;&gt;*****&lt;/Data&gt;修改为所需语言&nbsp; 可用语言：en_US|en_GB|en_AE|en_IL|de_DE|es_ES|es_MX|fr_FR|fr_CA|fr_MA|it_IT|ja_JP|ko_KR|zh_CN|pt_BR|ru_RU=====================================================================下载地址：https://pan.baidu.com/s/1smgyHwL",
    "postDate": "2019-01-30T23:40:45.3366501+08:00",
    "email": "admin@masuit.com",
    "label": "Adobe,Photoshop",
    "keyword": "Adobe,Adobe全家桶,Adobe大师版,Photoshop,马克丁死全家,大师版",
    "id": 22,
    "indexId": "Post:22"
  },
  {
    "title": "练耳大师 EarMaster Pro v6.1.626 简体中文破解版",
    "author": "懒得勤快",
    "content": "EarMaster 是一款来自丹麦皇家音乐学院的多媒体音乐教育软件，是世界著名的听音练耳软件，它以问答的交互形式，寓教于乐的视听方法，这个软件可以灵活的设置难度和级别，无论你是刚学音乐的儿童，还是一个音乐高手，都可以使用这个软件来增强你的听音能力。适用音乐学生，爱好者和音乐专业人员。因为这个软件可以灵活的设置难度了级别。 EarMaster提供了相当多的练习项目，共分为音程比较、音程识辨、和弦识辨、和弦转位、和弦序进、音阶识辨、节奏视奏、节奏模仿、节奏纠错、旋律听写等十大类别。获得音乐家般的耳朵，通过专业视唱练耳培训考试， 并成为更好的音乐家。完美的AP音乐理论，ABRSM，RCM和类似的考试标准。EarMaster 7包括14种教学活动：音程比较、音程辨认、音程歌唱、和弦转位、和弦进行、辨认音阶、节奏视唱、 节奏模仿、节奏默写、节奏错误检查、旋律视唱、旋律模仿、旋律听写等。超过2000个练习和课程将帮助您更好地识别、 录制、播放和视听。 EarMaster 6的大部分活动可以使用麦克风或MIDI键盘来唱歌、拍手或播放您的答案。软件特点激发兴趣经常使用 EarMaster 能够快速壮大 你的听音、练耳、模唱以及对节奏 与和声的驾驭能力。全面训练超过2500种音乐理论练习，涵盖耳部训练 视唱练习，节奏训练，爵士和声 摇摆等等统计与自定义详细的统计数据来监视你的进度 ，自定义练习练习你想要的方式14种教学活动音程比较、辨认、歌唱、和弦与音阶 ，节奏视唱、模仿、默写、旋律视唱 旋律模仿、旋律听写等爵士课程拥有摇摆节奏的爵士乐课程 ，你爵士乐和弦以及爵士乐标准的视觉演唱MIDI键盘与音源实时播放中使用麦克风或MIDI键盘播放 ，从真实乐器中采样超一百种乐器声音下载地址附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!官方安装包：https://pan.baidu.com/s/19S0xZwloGQ2eo6agKxV-NAhttps://www.earmaster.com/downloads/previous-versions.html破解补丁：稀缺资源统一下载地址页",
    "postDate": "2019-01-30T23:40:45.3367129+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "EarMaster",
    "id": 1369,
    "indexId": "Post:1369"
  },
  {
    "title": "如何从程序的角度看朋友圈刷屏的：给我一个圣诞帽！@微信官方？",
    "author": "懒得勤快",
    "content": "今天圣诞节，前两天朋友圈被“给我一个圣诞帽！并@微信官方”所刷屏。这事儿还得从朋友圈刷屏的@微信官方要圣诞帽事件说起。点开朋友圈 ，很多网友都会发一条消息“给我一个圣诞帽！并@微信官方”。&nbsp; &nbsp; &nbsp;然而画风渐渐跑偏了那么，身为程序员，从技术的角度思考一下，这事儿到底能不能成呢首先看一下网上某猿的分析：这体现了腾讯强大的人工智能实力，首先微信收到用户发送的朋友圈后，便获取用户头像上传至服务器云端，然后借助云计算和人脸识别，猪脸识别（来自友商京东的技术）和物体识别，根据头像角度、人脸大小，不断调整圣诞帽的尺寸和位置，最后生成圣诞帽头像。还有研究社交网络的专家分析，发这段话的用户大部分为女性，体现了女性是社交网络的主力！微信不愧是社交的王者。还有来自微信竞品团队的负责人分析，佩服微信强大的产品迭代能力，去年还只是在圣诞节推出了文字版的自定义表情包，今年居然到直接用人工智能换头像！可以说是非常到位了网友 @IT大智（https://www.wukong.com/question/6502590845793861902/）表示，这个功能目前几乎是不可能实现的。首先要明确一点，所有 APP 或者网站都是由代码程序实现的。假设微信想给用户添加圣诞帽，必须要再引用一次圣诞帽的图片地址，直接添加的话肯定要覆盖用户原来的头像，退一步腾讯可以做到图片叠加，那么也一定要定义图片的大小和位置，所以微信最多做到在固定位置添加一个大小一定的帽子，大家想象一下微信用户的头像千差万别，人头位置也很不确定，圣诞帽怎么会正好加在头像头顶呢？所以这是个谣言，类似于“明天是马化腾生日，转发本条信息到三个群会得到200Q币”等等。不少好友都发布了请求添加圣诞帽的朋友圈并@了微信官方，但实际上微信只能@自己的好友，微信并没有推出自己的官方号，所以你在朋友圈@微信官方，微信的人能收到你的@信息吗？当然不能。然而还有更厉害的：大致来说，当用户在朋友圈发布这样的文字消息：请给我头像一顶圣诞帽@微信官方微信官方会收到这个艾特，并通过该用户的openid（微信用户的唯一标志ID）获取到该用户的微信头像文件，将该图片和文本传至后台AI。所谓“自然语言”，就是我们人类平常说的话，一般情况下，计算机只能理解编程语言，不能理解人类说的话。但是，腾讯AI可以进行“自然语言处理”，将“请给我头像一顶圣诞帽”这句话进行分解，并解读其中的意思。至此，腾讯AI理解了该段文本的内容，通过智能图像处理技术，识别到人脸及头部，选择好合适的大小及方向，将提前准备好的圣诞帽图片与头像叠加，这样就生成了一张带圣诞帽的新头像，并将头像传至前端。微信官方收到图片后，还是通过读取openid找到该用户，将该图片应用到该用户的头像，并提醒到该用户，整个过程不到五分钟。当然，有些情形会难倒AI比如你的头像图片中有很多人，AI就没法判断你到底要给哪个人添加圣诞帽，只能给所有人头上都添加一顶圣诞帽。所以，大家还是不要调戏AI，用一张美美的图片@微信官方就好！当然啦，这只是对@微信官方求帽子的调侃但是还真的有人站出来说，这事儿能成阅文集团首席架构师徐海峰老师就表示，使用大数据分析+AI+图片动态处理实现能够实现，架构图如下",
    "postDate": "2019-01-30T23:40:45.3367744+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": null,
    "id": 167,
    "indexId": "Post:167"
  },
  {
    "title": "西虹市首富1080p种子下载",
    "author": "懒得勤快",
    "content": "《西虹市首富》的故事发生在《夏洛特烦恼》中的“特烦恼”之城“西虹市”。混迹于丙级业余足球队的守门员王多鱼（沈腾饰演），因比赛失利被开除离队。正处于人生最低谷的他接受了神秘台湾财团“一个月花光十亿资金”的挑战。本以为快乐生活就此开始，王多鱼却第一次感到“花钱特烦恼”！想要人生反转走上巅峰，真的没有那么简单。网友点评又名《当王思聪是怎样一种体验》，表面上是喜剧片，其实内在无比黑暗。有钱可以让最高傲强势的经理俯首帖耳，可以让最思想崇高的教育家唯命是从，可以让股神陪你吃饭，可以让王力宏去你家开演唱会。但有钱同样也可以让你实现最不可能实现的梦想，可以让你追到最不可能追到的女生，可以让你和高不可攀的球队踢球，可以让你在朋友有生命危险的时候有能力救Ta。钱是王八蛋，钱也是救命药。 有钱之后瞎几把投的股票都可以增值，瞎几把投的项目都可以爆赚，钱像有繁殖能力一样越用越多。但这又怎样呢？那些告诉你“钱不重要”“平平淡淡才是真”的电影只是毒鸡汤，这种提倡“钱很重要、有钱可以做想做的事、有钱可以提高实现梦想的几率”、号召大家认真工作努力赚钱的电影不才是正确的价值观吗？电影只是说了人人都知道，但人人都不愿意接受的事。下载地址迅雷被和谐了，推荐用百度云或其他种子下载工具。https://masuit.com/download?path=/file/西红市首富.torrent",
    "postDate": "2019-01-30T23:40:45.3368347+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "西虹市首富,torrent,种子",
    "id": 1257,
    "indexId": "Post:1257"
  },
  {
    "title": "[补档]bat/cmd批处理程序设计教程",
    "author": "懒得勤快",
    "content": "很多年以前写的一本书，今天同事偶然问到我有没有这方面的资料，然后发现这个新博客上还没分享，特意补上。序言部分：这是一篇技术教程，我真心诚意会用很简单的文字表达清楚自己的意思，只要你识字就能看懂，就能学到知识。我写这篇教程的目的，是让每一个看过这些文字的朋友记住一句话：如果爱可以让事情变的更简单，那么就让它简单吧！看这篇教程的方法，就是慢！慢慢的，如同品一杯茗茶，你会发现很多以前就在眼前的东西突然变的很遥远，而有些很遥远的东西却又突然回到了眼前。先概述一下批处理是个什么东东。批处理的定义，至今我也没能给出一个合适的----众多高手们也都没给出----反正我不知道----看了我也不一定信服----我是个菜鸟，当然就更不用说了；但我想总结出一个“比较合适的”，而且我也相信自己可以把它解释的很清楚，让更多的菜鸟都知道这是个什么东东，你用这个东东可以干什么事情。或许你会因为这篇文章而&quot;无条件爱上批处理&quot;，那么我的目的就达到了----我就是要让你爱上它，我就这么拽，你能怎么着？？真的，爱有时候就这么拽，就是这么没理由，就是这么不要脸！真的！按照我的理解，批处理的本质，是一堆DOS命令按一定顺序排列而形成的集合。批处理文件是无格式的文本文件，它包含一条或多条命令。它的文件扩展名为 .bat 或 .cmd。在命令提示下键入批处理文件的名称，或者双击该批处理文件，系统就会调用Cmd.exe按照该文件中各个命令出现的顺序来逐个运行它们。使用批处理文件（也被称为批处理程序或脚本），可以简化日常或重复性任务。当然我们的这个版本的主要内容是介绍批处理在入侵中一些实际运用，例如我们后面要提到的用批处理文件来给系统打补丁、批量植入后门程序等。OK,never claver and get to business（闲话少说言归正传）。批处理，也称为批处理脚本，英文译为BATCH，批处理文件后缀BAT就取的前三个字母。它的构成没有固定格式，只要遵守以下这条就ok了：每一行可视为一个命令，每个命令里可以含多条子命令，从第一行开始执行，直到最后一行结束，它运行的平台是DOS。批处理有一个很鲜明的特点：使用方便、灵活，功能强大，自动化程度高。我不想让自己写的教程枯燥无味，因为牵缠到代码（批处理的内容算是代码吧？）的问题本来就是枯燥的，很少有人能面对满屏幕的代码而静下心来。所以我会用很多简单实用的例子让读这篇教程的朋友去体会批处理的那四射的魅力，感受它那古灵精怪的性格，不知不觉中爱上批处理（晕，怎么又是爱？到底批处理和爱有什么关系？答案：没有！）。再说句&quot;闲话&quot;：要学好批处理，DOS基础一定要牢！当然脑子灵活也是很重要的一方面。例一、先给出一个最easy的批处理脚本让大家和它混个脸熟，将下面的几行命令保存为name.bat然后执行（以后文中只给出代码，保存和执行方式类似）：ping&nbsp;sz.tencent.com&nbsp;&gt;a.txt\nping&nbsp;sz1.tencent.com&nbsp;&gt;&gt;a.txt\nping&nbsp;sz2.tencent.com&nbsp;&gt;&gt;a.txt\nping&nbsp;sz3.tencent.com&nbsp;&gt;&gt;a.txt\nping&nbsp;sz4.tencent.com&nbsp;&gt;&gt;a.txt\nping&nbsp;sz5.tencent.com&nbsp;&gt;&gt;a.txt\nping&nbsp;sz6.tencent.com&nbsp;&gt;&gt;a.txt\nping&nbsp;sz7.tencent.com&nbsp;&gt;&gt;a.txt\nexit是不是都能看的懂？是不是很easy？但它的作用却是很实用的，执行这个批处理后，可以在你的当前盘建立一个名为a.txt的文件，它里面记录的信息可以帮助你迅速找到速度最快的QQ服务器，从而远离&quot;从服务器中转&quot;那一痛苦的过程。这里&gt;的意思，是把前面命令得到的东西放到后面所给的地方，&gt;&gt;的作用，和&gt;的相同，区别是把结果追加到前一行得出的结果的后面，具体的说是下一行，而前面一行命令得出的结果将保留，这样可以使这个a.txt文件越来越大（想到如何搞破坏了？？）。By the way，这个批处理还可以和其他命令结合，搞成完全自动化判断服务器速度的东东，执行后直接显示速度最快的服务器IP，是不是很爽？后面还将详细介绍。&nbsp;例二、再给出一个已经过时的例子（a.bat）：@echo&nbsp;off\nif&nbsp;exist&nbsp;C:\\Progra~1\\Tencent\\AD\\*.gif\ndel&nbsp;C:\\Progra~1\\Tencent\\AD\\*.gif为什么说这是个过时的例子呢？很简单，因为现在已经几乎没有人用带广告的QQ了，所以它几乎用不上了。但曾经它的作用是不可小窥的：删除QQ的广告，让对话框干干净净。这里用的地址是QQ的默认安装地址，默认批处理文件名为a.bat，你当然可以根据情况自行修改。在这个脚本中使用了if命令，使得它可以达到适时判断和删除广告图片的效果，你只需要不关闭命令执行后的DOS窗口，不按CTRL+C强行终止命令，它就一直监视是否有广告图片（QQ也再不断查看自己的广告是否被删除）。当然这个脚本占用你一点点内存，呵呵。&nbsp;例三，使用批处理脚本查是否中冰河。脚本内容如下：@echo&nbsp;off\nNetstat&nbsp;-a&nbsp;-n&nbsp;&gt;a.txt\ntype&nbsp;a.txt&nbsp;|&nbsp;find&nbsp;&quot;7626&quot;&nbsp;&amp;&amp;&nbsp;echo&nbsp;&quot;恭喜你，你中了冰河病毒！&quot;\ndel&nbsp;a.txt\nPause&nbsp;&amp;&nbsp;exit这里利用了netstat命令，检查所有的网络端口状态，只需要你清楚常见木马所使用的端口，就能很easy的判断出来是否被人种了冰河。然这不是确定的，因为冰河默认的端口7626，完全可以被人修改。这里介绍的只是方法和思路。这里介绍的是方法和思路稍做改动，就变成可以检查其他木马的脚本了，再改动一下，加进去参数和端口及信息列表文件后，就变成自动检测所有木马的脚本了。呵呵，是不是很过瘾？脚本中还利用了组合命令&amp;&amp;和管道命令，后面将详细介绍。&nbsp;例四，借批处理自动清除系统垃圾，脚本如下：@echo&nbsp;off\nif&nbsp;exist&nbsp;c:\\windows\\temp\\*.*&nbsp;del&nbsp;c:\\windows\\temp\\*.*\nif&nbsp;exist&nbsp;c:\\windows\\Tempor~1\\*.*&nbsp;del&nbsp;c:\\windows\\Tempor~1\\*.*\nif&nbsp;exist&nbsp;c:\\windows\\History\\*.*&nbsp;del&nbsp;c:\\windows\\History\\*.*\nif&nbsp;exist&nbsp;c:\\windows\\recent\\*.*&nbsp;del&nbsp;c:\\windows\\recent\\*.*当然，这只是一个小方法而已，其实产生垃圾垃圾的地方远不止其上的几个位置，这只能抛砖引玉。这里需要注意两点：一、DOS不支持长文件名，所以就出现了Tempor~1这个东东；二、可根据自己的实际情况进行改动，使其符合自己的要求。怎么样，看到这里，你对批处理脚本是不是已经有点兴趣了？是不是发现自己已经慢慢爱上了这个东东？别高兴的太早，爱不是一件简单的事，它也许能带给你快乐和幸福，当然也能让你痛苦的想去跳楼。如果你知道很难还敢继续的话，I服了YOU！继续努力吧，也许到最后你不一定得到真爱（真的有这可能，爱过的人都知道），但你可以体会到整个爱的过程，就是如此。酸、苦和辣，有没有甜天知道。为什么会把批处理和爱情扯上关系？不是我无聊，也不是因为这样写有趣多少，原因有二：其一，批处理和爱情有很多相同的地方，有些地方我用&quot;专业&quot;的行话解释不清（我不怀疑自己的表达能力，而是事情本身就不好说清楚），说了=没说，但用地球人都知道的爱情一比喻（爱情是什么？我TM怎么知道！！），没准你心里一下就亮堂了，事半功倍，何乐而不为？其二，我这段时间状态不是很好，感冒发烧头疼鼻塞，但主要还是感情上精神摧残，搞的人烦透了，借写教程之际感慨几句，大家就全当买狗皮膏药了，完全可以省略不看（也许还真有点效果---不至于让你看着看着就睡着了，把头磕了来找我报销医药费）。说不定下次的教程中大家还会看到杨过、张无忌等金老前辈笔下的英雄们。看过第一章的朋友，一定对批处理有了初步的印象，知道它到底是用来干什么的了。但你知道运用批处理的精髓在哪里吗？其实很简单：思路要灵活！没有做不到的，只有想不到的。这和爱情就有点不同了，因为爱情的世界是两个人的世界，一厢情愿不叫爱情（补充：那叫单恋。）而批处理却是一个人的天堂，你可以为所欲为，没有达不到的境界！批处理看起来杂乱无章，但它的逻辑性之强，绝对不比其他程序语言（如汇编）低，如果你写的脚本是一堆乱麻，虽然每一行命令都正确，但从头执行到尾后，不一定得到你想要的结果，也许是一屏幕的Bad cmd or fail name。这又和爱情有了共同点：按步骤来经营，缺少或增多的步骤都可能导致不想看见的结果。陷入爱河的朋友，相信没有不肯定这句话的。我的爱情批处理，输出的结果不是Bad cmd or failname，屏幕是这么显示的：‘你的爱情&#39;不是内部或外部命令，也不是可运行的程序或批处理文件。然后就是光标不停闪动，等待这下一次错误的输入。从第一章开始，将由浅入深的介绍批处理中常用的命令，很多常见DOS命令在批处理脚本中有这广泛的应用，它们是批处理脚本的BODY部分，但批处理比DOS更灵活多样，更具备自动化。要学好批处理，DOS一定要有比较扎实的基础。这里只讲述一些比较少用（相对来说）的DOS命令，常用命令如COPY、DIR等就不做介绍了（这些看似简单的命令实际复杂的很，我怕自己都说不清楚！）。下面就开始我们批处理学习之旅吧。&nbsp;下载地址https://www.lanzous.com/i2hky7a",
    "postDate": "2019-01-30T23:40:45.3368962+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "批处理,脚本语言",
    "id": 1385,
    "indexId": "Post:1385"
  },
  {
    "title": "Mind Mapper 17 Arena破解版",
    "author": "懒得勤快",
    "content": "大家久等了，mind&nbsp;mapper终于给大家找来了。mind mapper是一款十分出色的电脑端概念图设计制作软件。mindmapper能够给用户提供完善而全面的图形方案，多样化的工具内容让你轻松制作出自己需要的图表文件，整体操作十分高效便捷，是思维导图的最佳助手。&nbsp;mindmapper特色介绍：软件采用了经过增强的个人和工作组通信程序，您可以清楚发现使用该软件所带来的效率和速度优势。首次打开 MindMapper 17 Arena，你肯定会被一个“别开生面”的帮助文档所吸引，因为这个帮助文档就是用 MindMapper 创建的，这个帮助文档以直观的方式向用户展现了 MindMapper 的基本功能，同时又以清晰的逻辑让用户能够按照一定的顺序快速掌握软件的使用方法。MindMapper 17 Arena 在使用上也比较容易上手，只要把你脑子里面的想法一个一个按照层级关系列举出来即可，MindMapper 就会自动为它们创建分支关系，列举完所有的想法，一棵完整的“思维树”就出现在你的眼前了。除了手工一个事件一个事件地创建之外，MindMapper 还有一个非常重要的特性：从 MS Office 程序中读入事件，这个功能与 Outlook 配合使用特别有效，它可以读入 Outlook 中的事项并且按照时间顺序为事件编号，最重要的是，它可以将每个事项对应的时间、备注信息一并读入，用户可以在 MindMapper 中直观管理自己的 Outlook 日程。和以往版本相比，最新的 MindMapper 启动速度更快、最终文件体积更小，软件图标更加漂亮，并且对中文的兼容性更好。功能方面，MindMapper 新增了多种事件管理模式，用该版本将文件导出为 Excel 表格时，各事件的层级关系也能够在 Excel 中得到明确体现。从上面的描述中可以看到，和大多数“头脑风暴”软件相比，MindMapper 最大的特色不仅在于可以用于整理思路，它完全可以作为非常实用的日程管理软件来使用。虽然想要掌握 MindMapper 的高级功能要稍微复杂一些，但是一旦你熟悉了它的使用方法，相信你会发现自己的组织、思维能力都会因此而踏上新的台阶。mindmapper功能说明：1、头脑风暴头脑风暴法又称智力激励法、BS法、自由思考法，是由美国创造学家A·F·奥斯本于1939年首次提出、1953年正式发表的一种激发性思维的方法。此法经各国创造学研究者的实践和发展，至今已经形成了一个发明技法群，深受众多企业和组织的青睐。头脑风暴法又可分为直接头脑风暴法(通常简称为头脑风暴法)和质疑头脑风暴法(也称反头脑风暴法)。前者是在专家群体决策尽可能激发创造性，产生尽可能多的设想的方法，后者则是对前者提出的设想、方案逐一质疑，分析其现实可行性的方法。2、发散联想材料发散法——以某个物品尽可能多的“材料”，以其为发散点，设想它的多种用途。功能发散法——从某事物的功能出发，构想出获得该功能的各种可能性。结构发散法——以某事物的结构为发散点，设想出利用该结构的各种可能性。形态发散法——以事物的形态为发散点，设想出利用某种形态的各种可能性。组合发散法——以某事物为发散点，尽可能多地把它与别的事物进行组合成新事物。方法发散法——以某种方法为发散点，设想出利用方法的各种可能性。因果发散法——以某个事物发展的结果为发散点，推测出造成该结果的各种原因，或者由原因推测出可能产生的各种结果。3、属性列表指利用现有系统内的模块进行流程再造，从其关联属性着手，改造或创新之前流程中的问题，从而提出并解决问题。4、过程规划指对一个事件或者项目进行规划控制，将所有的步骤细化为点，从而进行精细化控制，防止出现偏差。5、前因后果(鱼骨图)鱼骨图是由日本管理大师石川馨先生所发明出来的，故又名石川图。鱼骨图是一种发现问题“根本原因”的方法，它也可以称之为“Ishikawa”或者“因果图”。鱼骨图也称为因果分析图或石川图(根据最先提出这一工具的石川熏(Kaoru Ishikawa译名)的名字命名)。它看上去有些象鱼骨，问题或缺陷(即后果)标在”鱼头”外。在鱼骨上长出鱼刺，上面按出现机会多寡列出产生生产问题的可能原因。鱼骨图有助于说明各个原因之间如何相互影响。它也能表现出各个可能的原因是如何随时间而依次出现的。这有助于着手解决问题。6、逆向思维就是实现定出结果， 采用逆向推理法进行排列工作内容或者进行的项目内容顺序目标。进而进一步区分每一个目标的具体执行任务。7、SWOT分析写下优势、劣势、机遇、挑战内容，进行分析评估个人或者公司或者项目。8、强行连接开始一个强制连接会话。下载地址感谢网友 @暗δ 月考不比zc高不改名&nbsp;分享官方安装包：http://www.mindmapper.com/download-product/模板大全，感谢 @红叔 分享：链接：https://pan.baidu.com/s/1s6lJMI495aOHPe0or86deQ&nbsp;提取码：sv58破解补丁：稀缺资源统一下载地址页",
    "postDate": "2019-01-30T23:40:45.3369568+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "mind,脑图",
    "id": 1312,
    "indexId": "Post:1312"
  },
  {
    "title": "音乐制谱软件 – Avid Sibelius Ultimate 2018.7 Build 2009 中文多语言破解版",
    "author": "懒得勤快",
    "content": "Sibelius（以前称为 Sibelius | First—了解更多）采用直观的基于任务的界面，可引导您完成整个乐谱创建流程，因此您可以快速进入界面来立即开始作曲。可以从屏幕乐谱、键盘、指板窗口或者您的 MIDI 或计算机键盘输入音符。Sibelius 将负责处理所有音符布局、方向和休止符细节。软件特点增强您的乐曲支持多达 16 个乐器分谱（五线谱），您可以创作丰富的多层乐曲。但是，它不只是音符。通过在 MIDI 设备上弹奏和弦或键入后缀元素可以增加和弦符号和吉他和弦图。将吉他谱转成乐谱，然后再转回。并轻松添加歌词、标题、文字和图形来完善乐谱。快速创作精美的乐谱更多时间可以花在作曲（而非修改）上。在您作曲时，磁性布局 (Magnetic Layout) 能自动为乐谱中每个音符分配适当的间隙并避免出现拥挤，从而制作出美观的乐谱，可将作曲的时间缩短一半。而且无论什么时候您更改总谱，动态分谱 (Dynamic Parts) 都能自动创建并更新单独的乐器分谱。将音乐转换为乐谱Sibelius 随附有两个伴奏应用，允许您将录制、演奏、打印和手写的音乐转换为乐谱。利用 AudioScore Lite，对着麦克风演唱或单音乐器演奏，就可以输入音符。利用 PhotoScore &amp; NotateMe Lite，可将打印的、PDF 和 JPEG 活页乐谱转换为可编辑的乐谱，即便是手写的乐谱也能做到。清晰地听到您音乐的每一个细节利用附带的 10 GB 高品质采样乐器音色库，您可以回放乐曲，以聆听使用全套乐器演奏时的音色。Espressivo 功能增添了更人性化的感觉，因此您的乐谱听起来会与预期一样。您也可以使用 VST 和 AU 虚拟乐器及音效。获得灵感遇到作曲障碍？不必发愁。查看乐谱入门 (Score Starter) 和灵感中心 (Ideas Hub) 来快速启迪您的创造力。使用 40 个特定流派的乐谱入门模板开始作曲。然后在灵感中心 (Ideas Hub) 找到更多灵感，那里提供了 300 种音色库想法任您选择，可以加快您的创作流程。您甚至可以捕捉自己的灵感，留待将来使用。分享您的作品使用 Sibelius | Cloud Sharing 轻松在线分享多达 20 个乐谱，以及邀请他人查看和弹奏您的音乐。想要分享更多乐谱？通过 Avid 云高级计划扩展您的存储空间。您也可以通过 MusicXML 协作，打印乐谱，以及将您的音乐导出为 MIDI 或 PDF 文件。通过 iPad 排练和演奏已经拥有 iPad？导出您的乐谱用于 Avid Scorch，它是一个 iOS 应用，可将您的 iPad 转变为交互式乐谱架和乐谱库，供排练和演奏。iPad 上有了 Avid Scorch 之后，通过对乐谱移调、更改乐器，甚至与吉他谱之间相互转换，能够查看乐谱并按照您的乐器进行改编。根据需要获取更新和帮助Sibelius 可通过低成本的按月或按年订阅来获取，也可以购买永久授权来获取软件的永久使用权。在您的有效订阅期或可续订的“1 年期软件更新 + 支持计划”（购买永久授权时附带）内，上述两种形式都可获取所有最新的 Sibelius 版本和标准支持。深入了解 Sibelius | Ultimate需要更多先进的制谱和布局功能？Sibelius | Ultimate 非常适合专业作曲家、编曲家、抄谱员、制版师和教育工作者，提供了更多的制谱工具、乐器声音、无限的五线谱、排印工具，以及定制乐谱的每一个元素的功能。六月更完美地处理装饰音节省重要的乐谱准备时间，并在同一员工的多种语音之间使装饰音完美保持一致，且无需手动修复间距和冲突。由于对 Sibelius 处理装饰音的方式进行了改进，您现在可以将任意值的装饰音添加到任意语音中的任意节奏，实现完美一致，从而使您可以更快创建更美观的乐谱。四月同时进行多个文本更改需要在乐谱的多个分谱中添加或更新表达式文本？选择多个分谱或音符，并一次性向所有乐器添加或编辑表达式文本。您可以按照相同的方法添加或编辑技巧文本和其他文本类型。更快对乐谱制版对于制版师来说，现在可以花更少的时间来修复音符间距，花更多的时间来完善出色乐谱。由于对自动调整多种语音中重叠音符的间距的方式进行了改进，现在作曲时，Sibelius 可生成更易于辨识和更准确的音符，因此您可以更快地创作更精美的乐谱。直接在乐谱上添加注释利用“批注”功能，可以直接在乐谱上绘图，以及向他人传达编辑、说明和反馈，从而简化协作和审核流程。所有批注会智能分组，并始终保持附加到您将它们所添加到的小节。一月增强您的工作流程Sibelius 提供了诸多新的增强功能以提升您作曲、编曲和音乐录制的效率。它是抄谱员快速标记乐谱，雕刻师获得所需布局的理想选择。将您的作品分享和推广至社区面向 Avid 艺术家社区中广大富有创造性的艺术家和媒体专业人士分享乐谱，获取反馈，寻找协作者或展示技能。您甚至可以将 Sibelius | Cloud Sharing 乐谱同步到您的社区作品集。扩展您的 Cloud Sharing 存储空间利用 Sibelius 的高级云存储计划获得更多空间，分享和存储更多音乐—打破 20 支乐谱的上限。而且如果您是 Pro Tools 用户，您还可以在同一个空间中开展云协作项目。下载地址附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!官方安装包：链接：https://pan.baidu.com/s/1g0kj6A36NrqTIrsuQaUMXw&nbsp;提取码：jr5t破解补丁：稀缺资源统一下载地址页",
    "postDate": "2019-01-30T23:40:45.3370179+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "音乐制谱软件",
    "id": 1368,
    "indexId": "Post:1368"
  },
  {
    "title": "为什么你应该尝试全栈",
    "author": "懒得勤快",
    "content": "谨以此文献给想跳槽或是想进入互联网行业的小伙伴们！技术在过去的几十年里进步很快，也将在未来的几十年里发展得更快。今天技术的门槛下降得越来越快，原本需要一个团队做出来的Web应用，现在只需要一两个人就可以了。同时，由于公司组织结构的变迁，也决定了赋予每个人的职责将会越来越多。尽管我们看到工厂化生产带来的优势，但是我们也看到了精益思想带来的变革。正是这种变革让越来越多的专家走向全栈，让组织内部有更好的交流。你还将看到专家和全栈的两种不同的学习模式，以及全栈工程师的未来。　　当时这种网站的URL类似于： https://mail.qq.com/cgi-bin/frame_html　　用户访问上面的网页的时候就会访问，cgi-bin的路径下对应的frame_html脚本。你可以用Shell返回这个网页：#!/bin/shecho Content-type: text/plainecho hello,world 　　Blabla，各种代码混乱地夹杂在一起。不得不说一句：这样的代码在2012年，我也看了有一些。简单地来说，这个时代的代码结构就是这样的：　　相似大家也已经对这样的架构很熟悉了，我们就不多解释了。如果你还不是非常了解的话，可以看看这本书后面的部分。后台服务化与前端一致化架构　　在今天看来，我们可以看到如下图所示的架构：　　在这其中的每一个过程实质上都是为了解决沟通的问题。从瀑布到敏捷是为了解决组织内沟通的问题，从敏捷到精益不仅仅优化了组织内的沟通问题，还强化了与外部的关系。换句话说，精益结合了一部分的互联网思维。瀑布式　　在最开始的时候，我们预先设计好我们的功能，然后编码，在适当的时候发布我们的软件：　　当人们意识到这个问题的时候，开始改进工作流程。出现了敏捷软件开发，这可以解释为什么产品经理会经常改需求。如果一个功能本身是没必要出现的话，那么为什么要花功夫去开发。但是如果一个功能在设计的初期就没有好好设计，那么改需求也是必然的。敏捷式　　现有的互联网公司的工作流程和敏捷软件开发在很多部分上是相似的，都有迭代、分析等等的过程：　　在整个过程中都不断地强调沟通问题，然而这时还存在一个问题：组织结构本身的问题。这样的组织结构，如下图所示：　　那么在研发、上线的过程中仍然会遇到各种的沟通问题。　　现在，让我们回过头来看看大公司的专家与小公司的全栈。大公司的专家与小公司的全栈　　如果你经常看一些关于全栈和专家的技术文章的时候，你就会发现不同的人在强调不同的方向。大公司的文章喜欢强调成为某个领域的专家，小公司喜欢小而美的团队——全栈工程师。　　如我们所见的：大公司和小公司都在解决不同类型的问题。大公司要解决性能问题，小公司都活下去需要依赖于近乎全能的人。并且，大公司和小公司都在加班。如果从这种意义上来说，我们可以发现其实大公司是在剥削劳动力。专家　　我们所见到的那些关于技术人员应该成为专家的文章，多数是已经成为某个技术领域里的专家写的文章。并且我们可以发现很有意思的一点是：他们都是管理者。管理者出于招聘的动机，因此更需要细分领域的专家来帮助他们解决问题。全栈　　相似的，我们所看到的那些关于成为全栈工程师的文章，多数是初创公司的CTO写的。而这些初创公司的CTO也多数是全栈工程师，他们需要招聘全栈工程师来帮助他们解决问题。两种不同的学习模型　　而不知你是否也注意到一点：专家们也在强调“一专多长”。因为单纯依靠于一个领域的技术而存在的专家已经很少了，技术专家们不得不依据于公司的需求去开拓不同的领域。毕竟“公司是指全部资本由股东出资构成，以营利为目的而依法设立的一种企业组织形式；”，管理人们假设技术本身是相通的，既然你在技术领域里有相当高的长板，那么进入一个新的技术也不是一件难的事。　　作为一个技术人员，我们是这个领域中的某个子领域专家。而作为这样一个专家，我们要扩展向另外一个领域的学习也不是一件很难的事。借鉴于我们先前的学习经验，我们可以很快的掌握这个新子域的知识。如我们所见，我们可以很快地补齐图中的短板：　　尽管理论上是如此，但是专家存在跨领域的学习障碍——套用现有模式。而全栈也存在学习障碍——如何成为专家，但是懂得如何学习新的领域。解决问题的思路：不同的方式　　有意思的是——成为专家还是成为全栈，取决于人的天性，这也是两种不同的性格决定的。成为管理者还是技术人员看上去就像一种简单的划分，而在技术人员里成为专家还是全栈就是另外一种划分。这取决于人们对于一个问题的思考方式：这件事情是借由外部来解决，还是由内部解决。下面这张图刚好可以表达我的想法：　　而这就是全栈学习带来的优势，学过的东西多，学习能力就变强。学习能力往上提的同时，你就更容易进入一个新的领域。",
    "postDate": "2019-01-30T23:40:45.3370808+08:00",
    "email": "admin@masuit.com",
    "label": "互联网",
    "keyword": null,
    "id": 80,
    "indexId": "Post:80"
  },
  {
    "title": "最近被刷屏的这道小学数学题，你怎么看？",
    "author": "懒得勤快",
    "content": "来自网络看着孩子的作业题，有多少爸爸妈妈感叹，幸亏自己毕业得早，要不然小学都不能毕业！这不，最近一道小学数学题，又刷爆了家长们的朋友圈。一起往下看，算一算图中的这道小学数学题，看看你的答案跟正确答案一样不。家长们开动脑筋都来一试身手，却算出了四种截然不同的答案。不是答案不唯一，而是前三种都是错的。问题就出在家长们大多没留意题干中的多处“陷阱”有网友吐槽：给小学生出题，弄这么多小心机和套路，有必要吗？现在孩子可真累！同一道题家长们做出四种答案这道在朋友圈和微信群里热转的题目是一张图片，里边有四个算式，等号左边没有数字而是一些具体的物品，等号右边除最后一个算式外都有具体的得数，题的意思就是让学生通过分析和运算前三个算式，从而得出最后一个算式等号后边的数。这道题表面上看起来很简单，不少人不假思索就开始算起来。“答案为19。”又有人算出了“30”的答案。俩人一对算法，前者恍然大悟，原来是自己不细心。前边一连串的都是加号，没看清最后一个加号斜着放的，变成了乘号。这边好像刚明白点儿，又有人冒出了“20”的答案。前两种答案的人赶紧向第三种答案的人求教，再次恍然大悟，原来代表某个数的红色哨子图案在不同算式中是不一样的。在第三个算式中，红色哨子是两个叠加放置的，第四个算式中却只有一个哨子，把数量看清楚后，算出来的结果自然就不同了。正当朋友圈中纷纷感慨这题出的得有水平时，有人又提出了新答案：“结果应该是16吧。”这下大家都有点蒙了，难道还有“小陷阱”没注意到？给出第四种答案的人提醒到，算式中的小动物图案有的脖子上挂了红哨子，有的没挂。众人仔细一看，果然是这样，但脖子上的小哨子十分不明显，不经过提醒还真是轻易看不出来。这样，把脖子上的哨子也算在内的话，这道题的结果就是16了。数学题中满是套路这有必要吗？面对这种到处是“坑”的小学数学题，不少早已经脱离校园的成年人直呼：“太可怕了，幸亏毕业得早！”“想到可怜的孩子们要常年面对这类刁钻题就心酸，孩子们太可怜了。教育应该多培养孩子解决实际问题的能力，在题干上设计这么多小心机和小套路等着孩子往坑里跳有意义吗？”一位妈妈说。另一位妈妈的孩子正在上幼儿园，看了这题之后不无感慨地说：“现在幼儿园经常让家长带着孩子练习‘找不同’的游戏，还真是不白练呀，以后上小学做题还真能用得上呢。”有孩子上初中的家长感同身受地说：“考题的类型就那么多，一般大考还不能出跟以前一样的题，那出题老师只能在题干设计上下文章了。拿中考来说，题的难易程度都是有要求的，不能出偏难怪题，所以有一些出题老师会在学生审题这个环节上设置考查点，题可能孩子们都会，但只有细心的孩子才能拿高分，这是孩子老师经常说的话。”还有网友看了这道题后不禁自我反思起来：“是我们变笨了，还是我们终于变得正常了。当年我也是高考数学接近满分的人，怎么如今连这么简单的题都做不对呢？这样的题考查的到底是什么，练习这样的题又有什么用，考出来的分数又能代表什么？”专家声音：锻炼学生细致观察的能力对于这样一些疑问，沈阳市一位资深的数学老师表示，上面提到的是一道很典型的数学题，答案确实是“16”。在数创大赛等比赛中就有这样的类型。很多大人比较关注这道题，是因为其中“带哨子的小动物”和“没带哨子的小动物”这个细节考倒了不少人。从数学角度去看这个细节，是整体和局部不同的问题，数学思维中很重视整体和局部的关系。很多人一开始把这道题看得简单了，不是很认真，没注意到整体和局部的细微差异，才造成了错误。不能因为没有观察到细微的差别，就错认为客观事实不存在，就说这个题出得不好。这道题其实是告诉大家：不要轻易地下结论，要认真地观察。观察细致也是一种重要的能力，通过细致的观察最终能转化为分析问题和解决问题的能力，这是一个有机的结合与升级。所以此类题对锻炼提升青少年思维品质是十分必要的。脑袋是不是烧醒了，精神了？来来来，继续出题！让小学题与太阳肩并肩！前一阵很多家长都被这道题虐哭了……看完根本没别的想法，满脑子都是：现在的小学生都这么厉害了？！？！但是更厉害的，是这位前来解题的网友↓989+109＝1098“要”是进位的，肯定是1，“好”+“要”进位了，那么好只可能8或9，做只可能是0或1，“好”+“好”不是18就是16，那么“事”是6或者8，“事”是6的话+做0或1都不可能满足条件，那么“事”就是8，“事”是8，那么“好”就是9，这样也就得出“做”是0，最后验算989+109＝1098——微博网友@Tinman一种听起来很有道理，但是没怎么听懂的感觉油然而生……但是不得不说，现在的小学生题目真是越来越让人“崩溃”了，感觉每道题都是对智商的无情碾压。1题目：一个正方形被两条线段分成了4个长方形，这4个长方形周长的和是18分米，请问原正方形的周长是多少分米？说真的，这可能是最正常的一道题了……2？？？你问谁？？？我也很想知道到底有几个！3你想解决什么问题？先把眼前这道题解决了不可以吗？4总觉得这是一道音乐题是怎么回事？5题目：我在排队，我前面有5个人，我后面的人比前面少2个人，请问，队里一共有几个人？我不排了还不行吗？！6就当它们是一样的吧！7还有这种操作：200、300、400，各自赚100？！好像……没有哪里不对啊！",
    "postDate": "2019-01-30T23:40:45.3371496+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": null,
    "id": 166,
    "indexId": "Post:166"
  },
  {
    "title": "Windows10数字许可激活C#版 3.1.0 Windows10 永久激活工具",
    "author": "懒得勤快",
    "content": "W10数字许可激活C#版，最近可谓是流行Win10永久激活，其实都是从HWIDGen&nbsp;这款数字激活工具援变而来的，基本原理还是国外大神研究的只不过是换了个壳子，这款是C#版，还有一块自动批处理版的激活工具，参考国外工具编写的Windows 10数字权利激活工具，能自动获取Windows 10 数字许可证激活，永久授权激活系统。支持版本Cloud &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sku=178CloudN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sku=179CoreN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sku=98CoreCountrySpecific &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sku=99CoreSingleLanguage &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sku=100Core &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sku=101Education &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sku=121EducationN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sku=122Enterprise &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sku=4EnterpriseN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sku=27EnterpriseS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sku=125EnterpriseSN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sku=126Professional &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sku=48ProfessionalN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sku=49ProfessionalEducation &nbsp; &nbsp; &nbsp; &nbsp; sku=164ProfessionalEducationN &nbsp; &nbsp; &nbsp;sku=165ProfessionalWorkstation &nbsp; &nbsp; sku=161ProfessionalWorkstationN &nbsp;sku=162更新日志v3.1.0KMS 19年方法独立为一个选择框的形式，理论上支持所有系统激活19年。添加Server 2019支持(KMS通道，激活19年)。新增2个参数 /KMS 和 /C，加上以前的/Q参数，一共三个参数，可任意组合：DigitalLicense.exe /Q —静默执行以获取数字权利。DigitalLicense.exe /Q /KMS /C —以KMS方式静默获取19年宽限期，整个过程中会清除Tokens参数(如180天的KMS)。DigitalLicense.exe /C —有GUI界面，在点击了【激活】按钮后的过程中会清除Tokens参数。v2.8.0添加LTSC 2019支持(KMS通道，激活19年)v2.8.0修改程序图标。删除es-ec语言，所有西班牙语使用es-es。UI界面大小可以自由调整。v2.7.9添加保存门票功能，添加德语。由Rambin精简slshim.c源代码，重编译slc.dll（大小仅6.5KB）。修复专业教育版(N)检测的SKU值不正确的问题。v2.7.8为语言选择下拉菜单添加滚动条。添加罗马尼亚语、荷兰语、阿尔巴尼亚语；修正阿拉伯语言。v2.7.7更新系统检测代码，加快检测速度。添加捷克语；修正繁体中文和希腊语翻译。v2.7.6所有过程都修改为异步执行，程序将实现秒开。添加繁体中文、波斯尼亚语；修正意大利语翻译错误的地方。软件说明1.点击[激活]按钮，即可自动激活数字授权。2.点击[安装密钥]按钮，仅安装密钥。3.点击[检测]按钮，检测系统信息和SKU值，如果密钥文本框留空，检测后会自动显示对应你系统版本的内置密钥。4.静默执行参数 /Q，静默执行完成后，会生成日志文件 C:\\激活日志.log5.添加选择产品密钥的右键菜单。6.保存的门票在 C:\\GenuineTicket.xml下载地址https://www.lanzous.com/i21f4fc",
    "postDate": "2019-01-30T23:40:45.3372337+08:00",
    "email": "admin@masuit.com",
    "label": "windows,激活工具",
    "keyword": "Windows10,激活工具",
    "id": 1299,
    "indexId": "Post:1299"
  },
  {
    "title": "远程桌面管理器：Remote Desktop Manager 14.0.9多语言破解版",
    "author": "懒得勤快",
    "content": "Remote Desktop Manager 是一个远程桌面管理工具，当然，小编也给大家分享过TeamViewer Enterprise 等等。Remote Desktop Manager 中文版能否保存编辑删除你的远程桌面连接，带登陆的终端功能。支持 VPN 连接，双显示器，该软件兼容兼容 Microsoft Remote Desktop，终端服务，VNC，LogMeIn，Team Viewer，FTP，SSH，Telnet，Dameware，X Window，VMware，Virtual PC，PC Anywhere, Hyper-V, Citrix, Radmin, Microsoft Remote Assistance, Oracle Virtual Box 等等。Remote Desktop Manager 远程连接连接任何会话类型，如：RDP，SSH，网页，VNC，远程登录，ICA / HDX，网络，的TeamViewer，LogMeIn的和多提高生产力和工作效率超过60的附加组件安全地连接到25个以上的VPN类型Remote Desktop Manager 密码管理保存和管理所有的密码输入凭据，并自动登录无处不在导入或整合现有的密码管理器，如KeePass的，还有更多Remote Desktop Manager 文件及资料保护敏感数据，如信用卡号，序列号和银行帐户存储，共享和链接的文档和联系人创建模板来简化管理Remote Desktop Manager 团队解决方案分享与组织内集中所有的连接和密码访问你的数据在离线时管理和限制用户访问查看连接日志和跟踪所有远程访问细节Remote Desktop Manager 安全通过最好的加密算法，确保组织生成强密码，并确定弱口令美国联邦政府认可的加密Remote Desktop Manager 管理工具集成的控制台，思杰的XenServer，VMware，微软终端服务器和Hyper-V许多工具，如远程关机，局域网唤醒和库存报告执行宏或脚本文件，如PowerShell中，VBScript中，SQL脚本和更多Remote Desktop Manager 用户界面与组织直观的界面为所有类型的用户易于部署和在企业环境中使用无需大量培训Remote Desktop Manager 其它特点从安装程序或zip文件部署便携式设备的操作模式支持扩展我们的SDK中的应用切换中文界面file &gt;&gt;&gt; options &gt;&gt;&gt; user interface &gt;&gt;&gt; language&nbsp;会弹出General设置界面，找到Chinese（Simplified）Legacy，然后ok，重启软件，就可以看到中文界面。下载地址：醉了，这软件一天一更新。主程序：https://u18891439.ctfile.com/fs/18891439-321708946破解补丁：https://www.lanzous.com/i2ggznc",
    "postDate": "2019-01-30T23:40:45.3373018+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "远程桌面管理器,Remote Desktop Manager,rdm,rdp",
    "id": 59,
    "indexId": "Post:59"
  },
  {
    "title": "绕开北京等4城市，带毒激活工具感染近60万用户",
    "author": "懒得勤快",
    "content": "一、&nbsp;概述&nbsp; &nbsp; 近日，火绒安全团队发现，用户在知名下载站“系统之家”下载安装“小马激活”及“OFFICE2016”两款激活工具时，会被植入病毒“Justler”，该病毒会劫持用户浏览器首页。病毒“Justler”作者极为谨慎，会刻意避开北京、厦门、深圳、泉州四个网络安全监察严格的地区的IP。除这几个地区以外的用户，下载到的软件均可能带毒。据“火绒威胁情报系统”监测和评估，截至目前，该病毒感染量已近60万。&nbsp; &nbsp; &nbsp;病毒“Justler”通过知名下载站“系统之家”（xitongzhijia.net）传播。当用户试图下载“小马激活”及“OFFICE2016”两款激活工具时，“系统之家”会识别访问IP，当用户IP地址不属于北京、厦门、深圳、泉州四个地区时，则会跳转到被植入病毒代码的软件下载链接。&nbsp; &nbsp; 另外根据跳转链接域名，我们进一步发现了一个站点名同为“系统之家”（win.100ea.com）的网站。而 &nbsp;该网站中提供的系统盘也同样携带病毒“Justler”。&nbsp; &nbsp; 一旦运行“小马激活工具”、“OFFICE2016激活工具”安装包，病毒“Justler”也随之被激活。之后，该病毒将篡改被感染电脑的浏览器首页，劫持流量。&nbsp; &nbsp; 火绒安全团队发现，利用激活工具和系统盘进行传播病毒和流氓软件的现象有逐渐增多趋势。由于激活工具通常是装机后首先安装的软件，因此此类病毒和流氓软件利用介入时机更早的优势与安全软件进行对抗。&nbsp; &nbsp; “火绒安全软件”最新版可拦截并查杀病毒“Justler”。对于已经感染该病毒的非火绒用户，可以下载使用“火绒专杀工具”(http://down5.huorong.cn/hrkill.exe)彻底查杀该病毒。二、&nbsp;样本分析&nbsp; &nbsp; 本次火绒所截获的病毒样本将自己伪装成了小马激活工具，在运行原版小马激活工具的同时，还会释放加载恶意驱动进行流量劫持。样本来源为名叫“系统之家”的软件站（www.xitongzhijia.net），该站点在百度搜索“系统之家”后的搜索结果排名中居于首位，且被标注有“官网”标志。百度搜索“系统之家”后的搜索结果，如下图所示：百度搜索结果&nbsp; &nbsp; 该站点主页页面，如下图所示：站点页面&nbsp; &nbsp; 病毒将自己伪装成小马激活工具，病毒在运行首先会释放运行原始的小马激活工具，之后会释放加载病毒驱动进行流量劫持。病毒的下载页面（hxxp://www.xitongzhijia.net/soft/28841.html）会根据访问者IP的不同而变化，例如当访问用户的IP对应区域为北京时，下载地址链接，如下图红框所示：病毒下载页面（北京IP访问）&nbsp; &nbsp; 但在我们使用HTTP代理访问后，下载地址链接出现了变化，变为了百度云盘下载。通过一段时间的测试我们发现，在使用HTTP代理的情况下，下载页面并不是每次都会显示百度云盘下载链接，病毒作者可能利用这种方式对抗安全厂商的样本收集。下载页面，如下图所示：病毒下载页面（HTTP代理访问）&nbsp; &nbsp; 点击上图中的“百度云盘下载”链接后，页面会跳转至hxxp://go.100ea.com/oem9/down.html。该页面中包含的JavaScrIPt脚本可以根据用户的当前IP地址所属地域，跳转至不同的百度云盘地址。如果通过IP地域查询，获取到当前所属城市为北京、厦门、深圳或泉州，则会跳转到无毒版本小马激活工具的百度云盘下载页面；如果当前所属地为其他城市，则会跳转到带毒小马激活工具的下载地址。&nbsp; &nbsp; 脚本内容，如下图所示：跳转脚本内容&nbsp; &nbsp; 带毒小马激活样本由三层释放器构成，病毒整体结构如下图所示：病毒整体结构&nbsp; &nbsp; 三层释放器中都带有检测安全软件的代码逻辑，如果检测到安全软件则会弹出提示“为了顺利激活系统，请先退出杀毒软件”，最后退出执行。提示弹窗，如下图所示：提示弹窗&nbsp; &nbsp; 相关代码，如下图所示：相关代码&nbsp; &nbsp; oem9.exe和uuu.exe代码逻辑大致相同，均是对原始PE映像解密后进行释放。以oem9.exe为例相关代码，如下图所示：释放器代码逻辑&nbsp; &nbsp; 前两层释放器释放结束后会释放执行xxx.exe，xxx.exe资源“RES”中包含被加密的压缩数据，该资源起始处可以看到RAR标记，但是其实起始位置数据是用来迷惑分析人员的。相关资源数据，如下图所示：RES资源其实位置内容&nbsp; &nbsp; 真正的压缩数据起始位置为该资源偏移为0x41BB0B(0x41BB0B= 0x41BF0B（传入参数） - 0x400)的位置，压缩数据被逐字节加0x62加密过，解密后可以得到原始7z压缩数据。相关代码，如下图所示：压缩数据解密代码&nbsp; &nbsp; 将数据解压后我们得到了恶意驱动压缩包（解压后驱动名为jus3310s.sys）和原始的小马激活工具（ActE.exe），如下图所示：解压后文件&nbsp; &nbsp; 在火绒虚拟行为沙盒中的运行情况，如下图所示：虚拟行为沙盒运行情况&nbsp; &nbsp; 恶意驱动jus3310s.sys加载后，会注册映像加载回调劫持浏览器启动参数。当映像文件名为浏览器文件名时，恶意驱动会将浏览器启动参数劫持为如下网址。劫持所使用的网址，如下图所示：劫持网址列表&nbsp; &nbsp; 受影响浏览器列表，如下图所示：受影响的浏览器列表&nbsp; &nbsp; 恶意驱动首先会对加载映像的文件名进行检测，检查是否为浏览器文件名，之后对其父进程进行检测查看父进程是否为桌面进程（包括系统explorer、360桌面助手和360安全桌面），如果父进程是桌面进程则会对启动参数进行劫持。过滤浏览器进程相关代码，如下图所示：过滤浏览器进程代码&nbsp; &nbsp; 检测父进程是否为桌面进程相关代码，如下图所示：进程父进程代码三、溯源分析&nbsp; &nbsp; 通过我们对下载到病毒的系统之家网站内容进行排查，我们发现类似的带毒激活工具并不只有一个。在该网站的软件总排行列表中，我们暂时发现带毒的激活工具共有两个，且通过百度云盘链接最终下载到的病毒程序也在不断更新，病毒行为也可能不断进行变化。网站软件总排行列表，如下图所示：软件总排行列表&nbsp; &nbsp; 如上图，红框所示即为带毒的激活工具，两款激活工具排名非常靠前，排名分别在第五位和第六位，以此来诱骗用户进行下载执行。另一款带毒的激活工具最终所释放的恶意驱动（bus3310s.sys）与前文中所述恶意驱动（jus3310s.sys）具有很高的相似性，显然两个病毒样本出自同一病毒作者之手。同源代码，如下图所示：同源代码&nbsp; &nbsp; 除此之外，通过搜索前文中提到包含跳转脚本的网址域名（hxxp://100ea.com）,我们发现该域名还存在一个名为hxxp://win.100ea.com的子域名，该站点名同为“系统之家”。我们在该网站中下载的（hxxp://win.100ea.com/dngs64win10.html）系统盘镜像中也同样发现了同样的病毒样本，而且系统盘中的恶意驱动（yhxmabc.sys）样本哈希与前文中所述样本jus3310s.sys（x64）哈希相同，即该站点中的系统盘也同样包含有相同病毒。该网址页面，如下图所示：win.100ea.com网站页面&nbsp; &nbsp; 带毒的系统盘下载页面，如下图所示：带毒系统盘下载页面&nbsp; &nbsp; 样本哈希对比，如下图所示：样本哈希对比四、&nbsp;延伸样本分析&nbsp; &nbsp; 火绒近期发现，利用激活工具和系统盘进行传播的病毒和流氓软件有逐渐增多趋势，此类病毒和流氓软件利用介入时机更早的优势与安全软件进行对抗。此前在火绒发布的报告《“小马激活”病毒新变种分析报告》和《盗版用户面临的“APT攻击”风险》中，也对利用这两种方式进行传播的病毒样本进行过详细分析。除了上述样本外，火绒近期还截获了另一款利用系统盘途径进行传播流氓软件，该流氓软件会利用一键装机工具下载带有流氓软件系统镜像的方式进行传播。现象&nbsp; &nbsp; 本次火绒截获到的流氓软件名为“主页守护神”，会通过一款名为“云骑士装机大师”的一键装机工具下载带有流氓软件系统镜像，之后在本地对系统镜像进行安装从而达到传播目的。流氓软件运行后，除了首页锁定功能外还具有软件推送的功能，将来可能用于进行软件推广或者广告程序推广。经过火绒对“云骑士装机大师”软件的溯源分析，我们发现传播该流氓软件的一键装机工具数量众多。如下图所示：传播该流氓软件的装机工具及官网网址&nbsp; &nbsp; 上述一键装机工具官网页面，如下图所示：云骑士装机大师官网&nbsp; &nbsp; 上述装机工具在下载系统镜像时，会在同一服务器地址（hxxp://hsds.ruanjiandown.com）下载相同的gho文件至本地进行安装。在该系统镜像中，除了会预装流氓软件外，还会预装安全软件（360安全套装和QQ管家安全套装），由于这两款安全软件并不会检测该流氓软件，所以通过该装机工具安装系统的用户通常并不会知道系统已经被植入了流氓软件。“安全套装”选择窗口，如下图所示：“安全套装”选择窗口&nbsp; &nbsp; 系统安装完成后，“主页守护神”会被安装到系统中的Program Files\\PageGuard目录下。该流氓软件表面上的软件功能为主页保护，但在其软件代码中还包含有软件推送的相关代码逻辑。但截至到报告发布前，软件推送的相关配置暂时尚未设置软件推送数据，但不排除该流氓软件将来借助软件推送功能进行软件静默推广或广告程序推送的可能性。在双击运行该软件的主程序时，会弹出首页及默认浏览器的设置界面，但是该软件的自启动项中被设置了隐藏执行参数，自启运行时不会显示软件界面。软件界面，如下图所示：“主页守护神”软件界面&nbsp; &nbsp; 该软件的启动项注册表，如下图所示：启动项&nbsp; &nbsp; 该软件被安装后不会创建桌面快捷方式，在系统控制面板中也无法找到该软件的卸载项。该软件以隐藏方式启动后，如果运行软件推送逻辑，用户将很难对其软件推送行为有所察觉。详细分析&nbsp; &nbsp; 在该软件安装目录中，存放有首页锁定功能的相关配置。配置信息，如下图所示：劫持配置&nbsp; &nbsp; 首页锁定功能是通过PGFltMgr.sys（包含劫持与自保功能）和PGFltMgrLib.dll（与驱动进行通讯）来实现的，PGFltMgrLib.dll为ring3层调用PGFltMgr.sys驱动的唯一接口。在调用PGFltMgrLib.dll导出函数SetHomePageLockerW后，PGFltMgr.sys驱动的会在映像加载时，将BrowserInjectDll.dll注入到指定进程中。BrowserInjectDll.dll镜像内容可以通过远程服务器进行下载，现阶段其中代码会Hook GetCommandLineA和GetCommandLineW，最后通过篡改命令行参数达到首页锁定目的。PageGuard.exe中的首页锁定功能相关代码，如下图所示：劫持功能相关代码&nbsp; &nbsp; BrowserInjectDll.dll中的Hook代码，如下图所示：Hook代码&nbsp; &nbsp; 除了首页锁定功能外，还会根据配置调用Downloader.exe利用迅雷的下载组件下载推送其他程序，但是相关功能配置暂时为空，暂时不会进行软件推送。软件推送配置文件内容，如下图所示：软件推广配置信息&nbsp; &nbsp; 软件推送相关代码逻辑，如下图所示：执行推送程序代码软件推送下载代码&nbsp; &nbsp; 该流氓软件除了上述功能外，还有具有一定的自保能力，可以对与自身软件相关的启动项进行保护。被保护的键值包括：PageGuard主程序启动项、PageGuard服务启动项和IE首页项。相关代码，如下图所示：注册表保护代码逻辑五、附录&nbsp; &nbsp; 文中涉及样本SHA256：六、激活工具推荐http://masuit.com/157",
    "postDate": "2019-01-30T23:40:45.3373638+08:00",
    "email": "admin@masuit.com",
    "label": "网络安全",
    "keyword": null,
    "id": 1210,
    "indexId": "Post:1210"
  },
  {
    "title": "web前端知识体系大全",
    "author": "懒得勤快",
    "content": "1. 前言　　大约在几个月之前，让我看完了《webkit技术内幕》这本书的时候，突然有了一个想法。想把整个web前端开发所需要的知识都之中在一个视图中，形成一个完整的web前端知识体系，目的是想要颠覆人们对于前端只有三大块（html、css、js）的认识——做web前端需要的比这三大块要多得多。　　拖了好几个月了，但是由于近期将要参加的某一个活动，我不得不这两天把这个东西整出来。说干就干。趁工作忙里偷闲画草图，乱七八糟的在那儿理思路。　　大家不要害怕，其实下文中的这个知识框架要比草图中的好看的多，草图大家权当没看见。　　好了，废话不扯。下面请跟随我本文的内容，来看看web前端开发除了html、css和js之外，还有哪些东西需要你一步一步去掌握。　　　　在看内容之前，先看一下这个知识框架的预览图。图太大不好展示，看不清楚，可在此下载清晰版：http://pan.baidu.com/s/1eSFpt8A（内有整个知识体系的图片和xmind文件）2. 分类　　所有知识框架，那肯定是一个结构型的展现，就是一棵树。web前端的知识点非常多，也非常散，需要好几层结构来组织这个体系，否则就会显得很乱。那么如何组织、把谁和谁放在一块儿？这是真正值得我们去思考的，你也可以自己来思考一下这个问题。　　在我总结的这个知识框架中，首先第一层我划分为：理论知识，类库框架，编码开发，运行环境。如下图：　　接下来给大家解释一下：　　这个图要从下往上看，为何？——因为下面是上面的基础；首先，我们需要一定的理论知识，不管是你听别人讲授、自己看书还是网上淘资料，你都需要一定的理论知识，每一种程序开发，都避免不了。第二，有了这些理论知识我们就可以编码了——不错——but，没有人能抵挡住第三方框架和类库的诱惑，例如jquery；第三，有了这些理论知识和协助我们的类库框架，我们就可真正的编码了。大家可能以为编码开发不就是写代码吗，还有啥？——这里面道道多着呢；最后，开发程序的目的，最终是为了能高效、稳定的运行在相应的环境中，这其中又有哪些事情需要我们去做？请期待；3. 理论知识 包括“软知识”和“硬知识”　　“软知识”和“硬知识”大家可能觉得词陌生，其实我一说大家就能明白。所谓“软”的就是能在各个程序开发中都用到的，算是基本功、内功，例如数据结构、算法、设计模式、面向对象等等；所谓“硬”的就是能直接用于本程序开发的。用C#语言你就得学C#语法，此时学java没用。我们web前端开发所需要的硬知识其实都包含在三个标准里面：http标准、W3C标准和ECMAScript标准；4. 聊一聊web前端开发中的“硬知识”　　“软知识”的内容非常多，我们本次主要讨论的是web前端这一个方向，因此就点到为止，让大家知道这些知识也在知识体系中扮演重要角色。　　刚才说道，硬知识有三个标准：http标准、W3C标准和ECMAScript标准，那咱们就挨个聊聊这三个标准。　　4.1 http标准　　为什么做web前端要了解http标准？——因为浏览器要从服务端获取网页，网页也可能将信息再提交给服务器，这其中都有http的连接。web系统既然和http链接有瓜葛，你就必须去了解它。　　我的意见是：你不必去非常了解http的详细内容，但是你要了解web前端开发常用的一些http的知识——就是上图中我列出来的那些。当然，我知识列了一个纲，详细内容还得靠你自己去查阅（本文章讲的是知识框架，不会涉及任何知识点的详细内容）　　关于这方面的知识，建议去查阅《图解http》这本书，浅显易懂的讲述了这些内容，我曾经也看过。　　4.2 W3C标准　　如果说你只知道web前端的一个标准，估计肯定是W3C标准了（据我了解，貌似大部分人真的都只知道这一个标准）。它的内容非常多，看看www.w3.org/TR/这个页面。　　写到这里让我想起了一句话：2/8原则——20%的功能满足80%的需求。我觉得这句话用到这里非常合适，我们在平时开发过程中根本用不到这么多东西。反而，你要把平时用的多的东西搞懂了。　　下图的这些知识，我想不用再过多解释了，这就是我文章开发说的“三大块”（html、css、js）。现在你要知道，它们只不多是W3C标准的一部分，而W3C标准也只是web前端开发知识体系中的一部分而已。　　（下图没有完全展开，想看权展开的图，可下载本文一开始提供的附件）　　4.3 ECMAScript　　　　简称ES，写全称太麻烦了。　　有些人可能只知道javascript，而不知道ES——其实，js是在ES的基础上，为web浏览器做了一部分封装（增加了DOM操作、BOM操作等）。　　如上图中的这些概念，大家可能平时都在javascript中看到，其实他们是ES的内容。只不过javascript继承了ES的这些特性，并且javascript用的比较广泛，因此才会在js中讨论的多一些。　　还是那个“20/80原则”。其实ES中的内容也非常多，而且更新很快，现在都到ES6了。但是我上图中列出来的这些都是最重要的概念。如果你不懂原型、闭包和作用域，那就说明你还不完全了解ES，也就是不完全会用javascript。5. 框架和类库　　前面已经描述完了web前端开发所需要的理论知识。如何实践呢？——不能蛮干——还得绕世界去看看，有哪些大牛已经为我们做出了如此多的贡献。　　用下面的这些类库或者框架，能大大提高你的开发效率。首先，jquery一定是大部分web前端开发者不可或缺的工具。而我利用jquery不仅仅停留在只使用它的API和插件上，我还会自己去写jquery插件，我还会去读jquery的源码、了解jquery的设计思路。如果你也能那样做，请相信我，你会收获到意想不到的效果。如果有一个问题：怎样才能最最透彻的理解javascript的事件系统？最佳答案之一：读几遍（一遍可能读不懂）jquery关于事件处理部分的源码！bootstrap不用再过多解释了吧，从github上的排名也能看出道道来。甚至连我们公司的UI设计师，都从bootstrap上截图作为素材。fontAwesome是全世界最强大的图标系统。相比于css制作图标来说，这个要好很多倍，不管是开发、效率还是维护上。icomoon.io能让我自定义选择自己的图标文件。requirejs和seajs这种模块定义系统，也一定是你系统中不可或缺的。我曾经看过一个教程，讲师就说：requirejs带来了既jquery之后的第二次前端技术变革。其他的，backbone、angular、react这些也慢慢的开始发挥了他们的价值，此处精力有限就不再赘述了——但是，他们很重要——你至少要试着去了解它们。6. 编码开发　　要问编码IDE哪家强，当然要属微软的visual studio！但是即便是微软的VS最新版本，它也代替不了下面要说的这套开发环境。　　如果你专门做web前端，就不要在用vs了，当然要选择sublime。写html语句还用手动一条一条写吗？你得需要zencoding的协助，否则效率太差了。　　另外，针对html、css、js的压缩、合并、语法检查，文件的清除、复制这些操作，你还要手动去做吗？——你需要grunt或者gulp的帮助。　　如果你的系统中有比较多的js代码或者文件，请选择一个合适的模块定义规范——CMD / AMD　　请用git来帮助你做文件版本管理，最简单的就是使用github。　　调试、测试，也都有专门的工具，都是需要学的……　　——我的天哪……这些字写到现在写的我的手都酸了，别说要学习这些知识了——再也别说我们web前端是“三大块”了！7. 运行环境　　当系统真正到了运行环境中，当你觉得终于完事儿的时候，其实还有好几个知识点需要你掌握。看下图：　　首先，你要知道web系统虽然大部分是在浏览器下运行，但是js可能会被运行在node环境。　　在浏览器环境下，最重要的两点是：web安全和性能优化。需要注意的纲要我都列出来了，如果想了解推荐两本书《白帽子将web安全》《高性能网站建设指南》8. 其他　　以上这些是全部的知识体系。如果你想成为一名合格的、让leader喜欢的程序猿，你除了知道这些知识之外，我觉得还需要以下几点：要了解敏捷软件开发流程（如SCRUM）和项目管理知识（如考取PMP），这也属于一种“软”知识吧；要学会在网上和别人交流（博客、qq群、开源项目），交流能让自己看到自己的不足；要学会自我反省和自我学习。就像我现在一样，试着自己总结一下属于自己的东西，随时反省随时进步。9.&nbsp;赠送一张前端学习路线图10.&nbsp;赠送前端学习视频http://masuit.com/cat/25",
    "postDate": "2019-01-30T23:40:45.3374252+08:00",
    "email": "admin@masuit.com",
    "label": "web前端",
    "keyword": null,
    "id": 98,
    "indexId": "Post:98"
  },
  {
    "title": "有道词典（8.3）绿色去广告版",
    "author": "懒得勤快",
    "content": "网易有道词典是一款免费的全能翻译软件。有道词典PC版结合了互联网在线词典和桌面词典的优势，&nbsp; 支持41种语言翻译，海量词汇，在线翻译，权威词典、汉语词典、强大的本地词典，“权威词典+网络释义”组合将各类新兴词汇和翻译收录其中，新增的全文翻译、百科全书及网络单词本让英文正式迈入互联网时代。新版变化有道词典7.0版新增◎&nbsp;全新用户界面，导航更清晰；◎&nbsp;查词支持语种扩充到英日韩法德俄西葡8种语言；◎&nbsp;查词结果收录《朗文当代高级英语辞典》，解释更权威！◎&nbsp;翻译支持到41种语言与汉语的互译，各种翻译，轻松拿下！◎&nbsp;取词划词更强大，轻松识别中英日韩法德俄葡西 9种语言！有道词典6.0版新增功能：◎&nbsp;全新用户界面，更加清新；◎&nbsp;新增看天下版块，提供丰富的全新资讯，包括文字、视频形式；◎&nbsp;新增口语练习功能，每个单词和例句都添加有口语练习的按钮，用户对着PC麦克风说出相应的◎&nbsp;单词或句子，系统就会自动识别语音，给出百分制的评分，并告知具体发错的读音，帮助用户改善自己的发音；◎&nbsp;新增图解词典，采用全新的图片关联记忆法，通过专门设计的图片，帮助用户进行联想式单词记忆。有道词典5.0版新增功能：◎ 完整收录《柯林斯高级英汉双解词典》内容，汇集62000余条例句，覆盖多领域，权威专业；◎ 全新词根查询、图片词典，方便词根记忆、图片识词，轻松背单词；◎ 有道学堂同步上线，提供更科学的英语学习平台。此版特点基于网易有道词典官方版本制作，版本特色：1、纯净无广告：安装不弹窗、使用无广告、卸载不留痕2、功能无损失：完美保留软件所有功能，优化软件设置3、词库更全面：集成多部英汉语词典，离线使用更方便主要进行了如下修改和定制：1、去除主窗口底部横幅广告2、去除取词窗口及查询结果中的广告内容3、去除翻译页面及结果「人工翻译」按钮4、去除主窗口左侧「人工翻译」、「精品课」、「满意度调查」等标签5、优化程序设置：默认关闭开机启动、自动更新、每日推荐、网易精选等选项6、安装程序采用官方界面风格，并具备程序运行检测、现有版本检测及卸载等功能下载地址https://www.lanzous.com/i1lczrg",
    "postDate": "2019-01-30T23:40:45.3374861+08:00",
    "email": "admin@masuit.com",
    "label": "翻译",
    "keyword": "有道词典,有道翻译",
    "id": 28,
    "indexId": "Post:28"
  },
  {
    "title": "为了你现在及以后良好的职场和社交人际关系，建议你还是少发语音的好！",
    "author": "懒得勤快",
    "content": "说实话博主重来没发过关于职场方面的文章，但现在确实忍不住了，因为博主一直以来也深受其苦，所以写下此文。博主今天在办公室也正好发生了这一幕：中午的时候，我正在吃饭，办公桌对面的行政小姐姐，突然拍桌子说：“最讨厌哪个在说正事的时候发一大堆语言过来，有事就直接打电话嘛！”，我想应该就是某个小伙伴托她办什么事情，我也顺便接了句：“我也最讨厌哪个给我发语音，看到发的语音根本不想点开听”。微信和QQ，可以说是手机里的必备聊天软件~然而，聊天的时候，你有米有也遇到过这样的情况：……………………一言不合就发你一整页的语音！条条还长达三四十秒！听还是不听呢？可我在开会啊…听还是不听呢？可我还没下课啊…听还是不听呢？可我没带耳机啊…听还是不听呢？万一打开了他的话匣子，继续语音轰炸怎么办…我每次看到这满屏的未读语音，心里除了有种“想让对方闭嘴”的绝望之外，就只剩一种想法了：求求你，别再给我发语音了，好吗？从某种程度上讲，语音消息是个错误的发明！博主网聊从来不会给任何人发语音消息，这也是对别人最起码的尊重。随着微信功能的不断强大，从最初的文字到现在的语音、视频等。但是也有一些困扰时常发生。不知你是否遇到朋友发来的消息，一连串好几段语音。这给正在忙碌的你，或者处在嘈杂环境中一种很无奈的感觉。接下来我们就来谈谈为什么有的人不喜欢接收微信语音?如果你看过 Discovery 的纪录片《微信改变中国》，应该对其中介绍语音功能的镜头有印象。有时在外面赶公交或地铁的时候，我真的“没时间听”！坐过公交或地铁的童鞋都知道，周围很多杂音，就算打电话都很费劲，更不用说是发的语音，还要中途下车听你的语音？！如果你闲聊，那还好…可如果是酱紫滴~↓↓↓没！啥！重！要！的！事！你给我发了4段语音！5秒就能看完的21个字，你一共说了1分多钟！“嗯”，“啊”，“哦”这种抒情词，就占了4段…提到重点的那句话，在第2段…不听完所有的语音，我根本不知道你说了辣么多废话…听完所有的语音，我只想把你屏蔽…求你了，我只想安心上班工作，别再给我发语音了好么？开会的时候，我真的“没法听”！真的不是博主我傲娇高冷，我就问你，如果你在公司开会的时候，收到几条长语音，你该怎么办？“现在听，还是开完会再听？”“他一连发了辣么多条，会不会有急事？”“那我要不躲到桌子底下去听？”“还是假装去个厕所？”“我真的好想知道他说了啥啊！”………………那一刻，我的内心几乎是崩溃的…求你了，我不想被老板炒鱿鱼，别再给我发语音了好么？环境嘈杂的时候，我真的“听不清”！有的时候，有些人，明明自己身处一个吵得完全听不到人声的地方，他还一定要给你发语音！点开语音的那一瞬间，我还以为自己的手机炸了！我说我听不清楚，他又发了一条一样的轰炸般的语音！你要是再说听不清楚的话，他还要怪你“耳聋”…求你了，我不想让我的耳朵受到摧残，别再给我发语音了好么？不想造成误会的时候，我真的“不敢听”如果你在跟你的同事确定行程，他发了一大段语音给你，↓↓↓对方口齿清晰的情况下，你可能要反复地听上7、8遍，才能准确地get到他说的内容…不然，你会听语音听到怀疑人生：“湖南路” or “沪南路”…“莲西路” or “莲新路”…“桃林路” or “桃李路”…“Rose Street” or “Roy Street”…“Lang Rd” or “Lane Rd”…哦…你说微信语音有转文字的功能…好呀，我可以转文字啊…但你可不可以不要说方言啊…还有那些语音里说英文的…这都是什么鬼？！求你了，我不想逼疯寄几，别再给我发语音了好么？语音停不下来的时候，我真的“不想听”！文字的东西，你想读的时候可以读；你不想读的时候，随时都能暂停；巴特wuli微信语音，可木有“暂定”、“快进”这种功能哦！超过20秒的长语音，你一旦点开了就必须从头到尾的听一遍！更惨的是，长语音如果听到一半，你的大脸不小心碰到了手机屏幕！语音断了！怎么办？重新听一遍！求你了，我只想安安静静地做个美男子，别再给我发语音了好么？微信语音还有这些“BUG”！当然啦，语音让人抓狂的事，远不止上面说的那些…还有这些~你在听音乐，突然手机里来了一条语音，为了听清对方说了啥，你把耳机音量调大；等语音结束后，你的耳朵，炸了…　你在听语音的时候，本来想用听筒听的，可是莫名地没有听到声音，等你拿开准备重新设置的时候，尼玛外放了！%￥%…！@##￥当你给别人发语音，却一直没有收到回复，有可能是对方正在忙，没法回…也有可能是忘了回…还有一种可能是，人家一看是语音，根本不！想！听！也不！想！回！所以，如果你真的要发语音的话，请你先问一句：方便语音吗？如果碰上这种执着的狂徒~▲▲▲你还可以这么做~▼▼▼总之就是要让他知道~最后，总结一下1.你浪费了对方的宝贵时间比方说，同样的100个字，看完只需要9秒，但听完（请另一个人用正常语速读出来给我听）需要22秒，不包含大家在正常语音中会出现的“嗯”“哼”语气词和其他停顿，或许一遍两遍还听不清楚。结果显而易见，视觉分辨速度要远快于语音分辨速度。更何况你消耗这多余精力听完的东西还有可能一点意义都没有，或者只用几个字就能表达清楚，有时还可能被打断或者没听清，重复听了几遍才搞清楚对方说的是什么，效率再降低几十倍。中文文字输入缓慢，但表达效率极高，正如中英文的图书，中译本总是更薄一些一样。同样的一段微信信息，你输入文字的时间较长，但对方理解的速度更快；你录入语音的时间较短，但对方的理解时间大幅增加——于是你为了自己的便利，浪费了对方宝贵的时间。“方便自己麻烦别人”是语音消息的事实，无论你的上级还是同事，都不太会喜欢和这样自私的人共事。其次，现在办公室里，很多人使用微信桌面版工作。要知道大多数公司里的标配电脑并不设置功放，在电脑中收到微信消息后，语音无法点击收听。其实哪怕有功放功能，职场人也不愿意点击功放，因为语音内容无法预判，直接播放这既干扰他人又暴露隐私。于是理所当然，我必须拿出手机→解锁屏幕→等待微信加载完新的对话→找到你的对话框→点击语音→拿起手机收听……可见这会给他人带来多大的麻烦。2.语音消息的正式性不足当你张嘴时，你总有一些口语习惯会不假思索地带入。你或许明明在谈论一件重要的公事，需要简洁高效地传达，但是口语往往会导致同样的内容用更长的时间才能说完。而且使用语音，就不如文字输入有足够的时间推敲，一些措辞的失误或者表达的不畅甚至可能造成误解。虽然微信拥有撤回的功能，但是“撤回”在工作交流尤其面对客户时，恐怕是一项更没有礼貌的操作。▲像上图这样，明明一句话就能说明白，为什么要发一大堆 2、30 秒的语音呢？有重要内容需要对方批示时，请简明扼要说明缘由并附上需要其回复的内容，方便领导的同时也可作为 &quot; 呈堂证供 &quot;， 比如：领导您好，本月共需发放 6 名实习生补贴，合计 xx 元。因财务部门报销需要核对批示意见，烦请回复是否同意，谢谢！两句话，汇报了工作，解释了原因，还可以让领导迅速了解他需要回复的内容。3.语音消息不方便复制转发语音消息是无法被转发的，因为微信认为语音属于私人而非工作范畴，不应让第二个人阅读。但是在职场上，首先很多微信消息可能需要在本地备份。比如他人交代给我的一些重要工作，我最好能原封不动地复制黏贴到文档中，之后再做整理避免遗漏。那么尤其在电脑版微信上，我们可以直接用鼠标复制到文字信息，大大提升工作效率。其次，很多微信交流内容并不一定只和两人有关，就像大多数工作邮件都会牵涉到抄送一样。有时候我们需要把文字内容转达给第二个人，而有时我们需要把两人直接对话作为某种佐证。那么无论是逐条转发还是长按后的合并转发，都需要以文字内容为前提。语音消息在这种情况下就造成了无法回避的严重障碍。4.语音消息难以回溯查找如果有人给你发了连续一屏幕的语音工作内容，当你想回溯收听加强印象时候你就懵了。这些语音紧紧排列在一起，你无法搞清你需要的某一段信息在哪里，它们已经无法自动连续播放了，无论哪一段你都得从头开始听，并且以后想通过微信搜索这些信息你根本找不到。5.语音消息播放机制有缺陷虽然语音可以做到未读红点连续播放，但是在连续播放时，如果一条新语音收到它却无法继续播放。于是你不得不把手机从耳边移开，重新点击。倘若职场上大量发送语音消息，这种操作就会反复牵涉，令人心生不快。加之语音消息极易中断，无论是电话接入还是临时切换其他窗口。甚至它无法像音乐那样，在退出聊天窗口回到好友列表时继续播放。6.如果真的很重要，打电话有的人也许会说，我真的有急事，我这边打字太慢，语音又方便又快，所以就发语音了。姑且不论对方听你的语音花不花时间，就算不花时间，难道重要的事情不应该打电话吗？又或者还有一种情况，你确实有重要的事情，而且你不知道对方的电话号码，所以必须语音说，因为节省时间。如果真的是这样，那么也请你在发完微信语音以后，重新打字向对方说明事情的概要。为什么呢？第一，他可以在看到你微信的时候迅速掌握你要说的大致内容，方便应对你的急事；第二，方便你们两个之后的反馈和再次确认。如果真的要再次确认内容的话，你们两个都要把语音再次从头听一遍，想想就是噩梦啊。这点在与老板汇报工作时尤其重要！！有时候你可能会觉得文字很难表达清楚全部意思，想通过语音来解释。但请在你的十几条长达50秒的语音前先简明扼要、分点列出汇报提纲，一来方便老板迅速知悉，二来也能更好的理解你解释的内容。而且微信可以按照文字关键词来查找历史内容，语音？就只能凭印象了吧……7.爱发语音的人，可能真的没想到这些：a. 当对方在听音乐的时候，来了一条语音，如果想听清楚的话，那么回到音乐的时候，他的耳朵就会炸了；b. 当他在公共场合听语音，没有带耳机，听筒声音又不大的话，如果外放了，可能别人也会听到；c. 当他在安静环境听语音，用听筒，发现音量太大没调节好，于是不得不调音量再听一遍；d. 当他听语音的时候，想用听筒，结果没听到声音，一拿开，外放了，被一群人听到，这时候@#*&amp;…%￥；e. 当对方收到你的语音却没有回复的时候，有可能是一时不能听，就忘了，还有可能是，一看到是语音，就根本不，想，回。8.那些年因为语音的抓狂故事比如文章一开始提到的：再比如：这些回答可以比较委婉地告诉对方：&quot; 你该发文字了 &quot;，这样子大家面子上都过得去，但是如果还是执迷不悟得发来语音就会……再比如：@吴惠惠：最无语的就是，跟对方说了现在不方便听语音，然后他接着又回了一条语音过来 [ 再见 ]@好名字可以让你的……：一同学永远都是发语音，一次七八条连续发算少的，每次都是 3，40 秒真的听得耳朵疼。提醒过打字打字打字，还是执迷不悟。只好选择不听，不回复 [ 微笑 ]@时寒：充分认识到一分钟有多长 ~@-：一连串语音发过来都不知道它的中心思想在哪里 [ 微笑 ]@行者小月每次看到对方发一堆语音过来，真是脑袋要炸了，点开听好几遍调大音量听清楚之后，发现也没多少重要信息，还要在调高音量 - 听语音 - 炸耳朵 - 调低音量 - 换音乐 - 调高音量 - 听语音这样的循环中折磨@适度天蓝 :发几十上百条语音交代事情，最后听中断了或是忘记了什么信息，都得从头再来，心里真的是千万个次奥尼玛@melo:我舍友连个哦字都要用语音讲以上，表示同抓狂！！！！9.送上回复语音神器（使用后果概不负责）",
    "postDate": "2019-01-30T23:40:45.3375469+08:00",
    "email": "admin@masuit.com",
    "label": "职场,人际关系",
    "keyword": null,
    "id": 130,
    "indexId": "Post:130"
  },
  {
    "title": "Java并发编程高阶技术-高性能并发框架源码解析与实战",
    "author": "懒得勤快",
    "content": "课程目录第1章 课程介绍（Java并发编程进阶课程）什么是Disruptor？它一个高性能的异步处理框架，号称“单线程每秒可处理600W个订单”的神器，本课程目标：彻底精通一个如此优秀的开源框架，面试秒杀面试官。本章会带领小伙伴们先了解课程大纲与重点，然后模拟千万，亿级数据进行压力测试。让大家感性认知到Disruptor的强大。...1-1 课程导学1-2 并发编程框架Disruptor与BlockingQueue压力测试性能对比第2章 并发编程框架核心讲解本章带大家学习并发编程框架的基本使用与API，并介绍其内部各种组件的原理和运行机制。从而为后面的深入学习打下坚实的基础。2-1 本章导航2-2 并发编程框架-QuickStart-基础元素工厂类2-3 并发编程框架-QuickStart-消费端事件处理器2-4 并发编程框架-QuickStart-构建Disruptor实例2-5 并发编程框架-QuickStart-生产者组件投递数据2-6 并发编程框架Disruptor-核心机制-生产消费模型2-7 并发编程框架Disruptor-仍芝麻与捡芝麻小故事2-8 并发编程框架Disruptor-核心-RingBuffer2-9 并发编程框架Disruptor-核心-Sequence、Sequencer、SequenceBarrier2-10 并发编程框架Disruptor-核心-WaitStrategy消费者等待策略2-11 并发编程框架Disruptor-核心-EventProcessor，WorkProcessor等2-12 并发编程框架Disruptor-核心概念整体图解2-13 本章小结第3章 并发编程框架高级特性讲解本章首先带大家分析互联网大厂核心链路的难点和复杂业务逻辑，以及中台服务等概念，然后带大家掌握并发编程框架disruptor的高级特性，包括串并行化操作，菱形操作，多边形操作与底层代码深度解析，多生产者多消费者模型实战应用等。让大家有更加深入的理解。 ...3-1 本章导航3-2 互联网大厂核心链路方案详解-13-3 互联网大厂核心链路方案详解-23-4 串、并行操作实战应用-13-5 串、并行操作实战应用-23-6 菱形操作3-7 多边形操作与底层代码深度解析3-8 多生产者多消费者实战应用-13-9 多生产者多消费者实战应用-23-10 多生产者多消费者实战应用-33-11 多生产者多消费者实战应用-43-12 本章小结第4章 并发编程深入学习与面试精讲本章会为大家讲解并发编程核心技术点，面试考点，分析AQS架构，并对底层代码深度讲解与剖析，让小伙伴们掌握并发编程核心，从容应对实际工作与面试，同时也是为了下一章无锁并行计算框架源码分析做好铺垫。4-1 本章导航4-2 并发编程面试-并发类容器核心4-3 并发编程面试-Volatile与内存分析4-4 并发编程面试-Atomic系列类与UnSafe4-5 并发编程面试-J.U.C常用工具类4-6 并发编程面试-AQS各种锁4-7 并发编程面试-线程池最佳使用指南4-8 并发编程面试-AQS架构核心4-9 并发编程面试-ReentrantLock底层原理分析4-10 并发编程面试-ReentrantLock底层源码深度解析-14-11 并发编程面试-ReentrantLock底层源码深度解析-24-12 并发编程面试-CountDownLatch底层原理分析4-13 本章小结第5章 并发编程框架底层源码深度分析本章是课程的重难点，通过本章的学习大家会深度掌握并发编程框架架构，学习其性能爆表的优化手段与底层源码&amp;机制，包括内存预加载，消除伪共享，算法核心与各种等待策略分析，最后为大家分享框架内核EventProcessor底层机制，让小伙伴们真正精通一个优秀的开源框架。...5-1 本章导航5-2 并发编程框架Disruptor-整体架构UML类图分析5-3 并发编程框架Disruptor-为何它的底层性能如此牛掰5-4 并发编程框架Disruptor-数据结构设计原理与底层源码深度分析5-5 并发编程框架Disruptor-单线程写核心架构思想5-6 并发编程框架Disruptor-系统级别内存屏障实现5-7 并发编程框架Disruptor-填充缓存行消除伪共享机制来提升性能5-8 并发编程框架Disruptor-序号栅栏机制底层代码深度分析-15-9 并发编程框架Disruptor-序号栅栏机制底层代码深度分析-25-10 并发编程框架Disruptor-序号栅栏机制底层代码深度分析-35-11 WaitStrategy等待策略底层源码深度分析5-12 EventProcessor核心架构设计与底层源码深度分析5-13 本章小结第6章 Netty整合并发编程框架Disruptor实战百万长链接服务构建并发编程框架与netty整合实战，实现承载百万级别长链接应用，并手把手一步步接触netty框架的最佳使用与TCP网络通信内部机制，封装并发编程框架disruptor基础组件，嵌入到netty中，进行最佳实战应用。第7章 分布式统一ID生成服务架构设计本章将对分布式统一ID生成服务的架构设计进行讲解，大家可以了解各种ID生成规则，在高并发下zookeeper与redis分布式锁的问题与弊端，主流ID生成方案，ntp时间回调问题。最后会进行分布式统一ID生成服务架构设计思路详解第8章 课程总结本章带大家回顾课程知识重点，最后祝小伙伴们都能获取高薪offer。我在课程问答区等着与大家进一步交流。有问题欢迎大家到课程问答区提问。下载地址链接: https://pan.baidu.com/s/1AoIjHmqjhspZhUnjHbxiqw&nbsp;提取码: oi5z",
    "postDate": "2019-01-30T23:40:45.3376082+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": null,
    "id": 1349,
    "indexId": "Post:1349"
  },
  {
    "title": "顶风作案——劝哲（劝学改编）",
    "author": "懒得勤快",
    "content": "原文　　哲♂者曰：哲♂不可以已。　　精，取之于♂睾，而白于♂睾；尻，腚♂为之，而厚于♂腚。茎♂直中绳，腐♂以为轮，其曲♂中规。虽有男♂魂，不复挺♂者，腐♂使之然也。故茎♂受哲则直，蕉♂就砺则利，哲♂者博学而日强♂身健♂体，则知♂哲而跤♂无敌矣。　　吾尝终日而哲♂矣，不如摔♂跤之所学也。吾尝观弱♂子摔跤，不如B♂站之博♂见也。B站哲♂学，视频非加♂长也，而畜♂者多;鬼♂畜而哲，魂♂非加疾也，而观♂者彰。搞比♂利者，非利♂肌也，而拍♂视频;食香♂蕉者，非有♂魂也，而比魔♂男。哲♂者生(xìng)非异也，善假于蕉♂也。　　积蕉♂成山，尻♂比兴焉;积精♂成渊，VAN♂生焉;积跤♂成德，而比♂利自得，男♂魂备焉。故不搞比♂利，无以摔♂千人;不食香♂蕉，无以长♂千尺。木♂吉一摔，不能十♂步;平♂家起义，功在♂不舍。哲♂而舍之，马凯♂不折;哲♂而不舍，比♂利可摔。VAN♂无爪牙之利，筋♂骨之强，上击魔♂男，下刑马♂凯，用心哲♂也。弱♂子量多而乱♂喷，非幻♂想之乡无可摔♂跤者，无专♂哲也。不搞比♂利，无以摔♂千人译♂文　　哲♂学家说：哲♂学是不可以停♂止的。　　精，从睾♂中取得，却比睾♂白；尻，是腚♂形成的，却比腚♂厚很多。一个直♂男，接受了腐♂文化后弯♂成了一个轮♂胎，曲♂率和圆♂规一样。即使再给他男♂魂，他也不再直♂的起来了，全是因为接受了腐♂文化导♂致的。所以男♂子接受了哲♂学的思想就能变成直♂男，香♂蕉接受了磨♂砺就会变得锋♂利，哲♂学家博览哲♂学每天进行身体锻♂炼使体♂魄强健，于是知道了哲♂学摔♂跤就无人能敌了。　　我曾经花一天的时间思考哲♂学，不如摔♂一场♂跤学到的道♂理多。我曾经观看弱♂子摔♂跤，不如在B♂站的见识广♂博。B♂站的哲♂学，原视♂频的时间并没有被加♂长，然而鬼♂畜它的哲♂学家很多；鬼♂畜了哲♂学，男♂魂并没有被加♂强，但是观♂看的人却很清♂楚。搞比♂利的人，并不一定有强♂健的肌♂肉，却能拍♂摄哲♂学视频；吃香♂蕉的人，不是有多么强大的男♂魂，却能和魔♂男相提并论。哲♂学家的本♂性与普通人并没有多大差♂异，只是善于借助香♂蕉罢了。　　堆积香♂蕉成了山，尻♂比(香蕉君)就从这里兴起了；精♂流汇集成为深♂渊，VAN♂就从这里诞♂生了；积累摔♂跤的经验从而形成高♂尚的哲♂德，精♂神就可以达到比♂利那样高的境♂界，哲♂者的男♂魂也就具♂备了。因此，不搞♂比♂利就没有办法和一千个人摔♂跤；不吃香♂蕉，就没有办法长到千♂尺长。木♂吉的一次过肩♂摔，不能把人摔♂出十步远；平♂家boy们起义的成功，在于坚持不♂懈的学习哲♂学。学习哲♂学半途而废，连马♂凯也打不败；能够坚持不懈♂地学习哲♂学，那么比♂利王也可以打♂败。VAN♂没有锋♂利的爪牙和强健的筋♂骨，却能向上击败魔♂男，向下行♂刑马♂凯，只是因为他专心于哲♂学啊。现在的弱♂子那么多而且爱乱♂喷，没有幻♂想乡他们就找不到摔♂跤的地方，这就是因为他们没有专♂心于哲♂学啊。VAN♂无爪牙之利，筋骨之强",
    "postDate": "2019-01-30T23:40:45.3376688+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "哲学,van,新日暮里艺术家,新日暮里",
    "id": 1295,
    "indexId": "Post:1295"
  },
  {
    "title": "互联网项目架构之安全的账号系统设计，即使被拖库撞库，也可以保证密码绝不泄露",
    "author": "懒得勤快",
    "content": "在前一篇文章《账号系统安全设计的正确姿势》中，主要提出了一些设计的方法和思路，并没有给出一个更加具体的，可以实施的安全加密方案。经过我仔细的思考并了解了目前一些方案后，我设计了一个自认为还比较安全的安全加密方案。本文主要就是讲述这个方案，非常欢迎和期待有读者一起来讨论。首先，我们明确一下安全加密方案的终极目标：即使在数据被拖库，代码被泄露，请求被劫持的情况下，也能保障用户的密码不被泄露。说具体一些，我们理想中的绝对安全的系统大概是这样的：首先保障数据很难被拖库。\n即使数据被拖库，攻击者也无法从中破解出用户的密码。\n即使数据被拖库，攻击者也无法伪造登录请求通过验证。\n即使数据被拖库，攻击者劫持了用户的请求数据，也无法破解出用户的密码。如何保障数据不被拖库，这里就不展开讲了。首先我们来说说密码加密。现在应该很少系统会直接保存用户的密码了吧，至少也是会计算密码的 md5 后保存。md5 这种不可逆的加密方法理论上已经很安全了，但是随着彩虹表的出现，使得大量长度不够的密码可以直接从彩虹表里反推出来。所以，只对密码进行 md5 加密是肯定不够的。聪明的程序员想出了个办法，即使用户的密码很短，只要我在他的短密码后面加上一段很长的字符，再计算 md5 ，那反推出原始密码就变得非常困难了。加上的这段长字符，我们称为盐（Salt），通过这种方式加密的结果，我们称为 加盐 Hash 。比如：上一篇我们讲过，常用的哈希函数中，SHA-256、SHA-512 会比 md5 更安全，更难破解，出于更高安全性的考虑，我的这个方案中，会使用 SHA-512 代替 md5 。通过上面的加盐哈希运算，即使攻击者拿到了最终结果，也很难反推出原始的密码。不能反推，但可以正着推，假设攻击者将 salt 值也拿到了，那么他可以枚举遍历所有 6 位数的简单密码，加盐哈希，计算出一个结果对照表，从而破解出简单的密码。这就是通常所说的暴力破解。为了应对暴力破解，我使用了加盐的慢哈希。慢哈希是指执行这个哈希函数非常慢，这样暴力破解需要枚举遍历所有可能结果时，就需要花上非常非常长的时间。比如：bcrypt 就是这样一个慢哈希函数：通过调整 cost 参数，可以调整该函数慢到什么程度。假设让 bcrypt 计算一次需要 0.5 秒，遍历 6 位的简单密码，需要的时间为：((26 * 2 + 10)^6) / 2 秒，约 900 年。好了，有了上面的基础，来看看我的最终解决方案：上图里有很多细节，我分阶段来讲：1. 协商密钥基于非对称加密的密钥协商算法，可以在通信内容完全被公开的情况下，双方协商出一个只有双方才知道的密钥，然后使用该密钥进行对称加密传输数据。比如图中所用的 ECDH 密钥协商。2. 请求 Salt双方协商出一个密钥 SharedKey 之后，就可以使用 SharedKey 作为 AES 对称加密的密钥进行通信，客户端传给服务端自己的公钥 A ，以及加密了的用户ID（uid）。服务端从数据库中查找到该 uid 对于的 Salt1 和 Salt2 ，然后再加密返回给客户端。注意，服务端保存的 Salt1 和 Salt2 最好和用户数据分开存储，存到其他服务器的数据库里，这样即使被 SQL 注入，想要获得 Salt1 和 Salt2 也会非常困难。3. 验证密码这是最重要的一步了。客户端拿到 Salt1 和 Salt2 之后，可以计算出两个加盐哈希：SaltHash1&nbsp;=&nbsp;bcrypt(SHA512(password),&nbsp;uid&nbsp;+&nbsp;salt1,&nbsp;10)\nSaltHash2&nbsp;=&nbsp;SHA512(SaltHash1&nbsp;+&nbsp;uid&nbsp;+&nbsp;salt2)使用 SaltHash2 做为 AES 密钥，加密包括 uid，time，SaltHash1，RandKey 等内容传输给服务端：Ticket&nbsp;=&nbsp;AES(SaltHash2,&nbsp;uid&nbsp;+&nbsp;time&nbsp;+&nbsp;SaltHash1&nbsp;+&nbsp;RandKey)\nAES(SharedKey,&nbsp;Ticket)服务端使用 SharedKey 解密出 Ticket 之后，再从数据库中找到该 uid 对应的 SaltHash2 ，解密 Ticket ，得到 SaltHash1 ，使用 SaltHash1 重新计算 SaltHash2 看是否和数据库中的 SaltHash2 一致，从而验证密码是否正确。校验两个哈希值是否相等时，使用时间恒定的比较函数，防止试探性攻击。time 用于记录数据包发送的时间，用来防止录制回放攻击。4. 加密传输密码验证通过后，服务端生成一个随机的临时密钥 TempKey（使用安全的随机函数），并使用 RandKey 做为密钥，传输给客户端。之后双方的数据交互都通过 TempKey 作为 AES 密钥进行加密。假设被拖库了以上就是整个加密传输、存储的全过程。我们来假设几种攻击场景：1.假设数据被拖库了，密码会泄露吗？数据库中的 Salt1 ，Salt2 ， SaltHash2 暴露了，想从 SaltHash2 直接反解出原始密码几乎是不可能的事情。2.假设数据被拖库了，攻击者能不能伪造登录请求通过验证？攻击者在生成 Ticket 时，需要 SaltHash1 ，但由于并不知道密码，所以无法计算出 SaltHash1 ，又无法从 SaltHash2 反推 SaltHash1 ，所以无法伪造登录请求通过验证。3.假设数据被拖库了，攻击者使用中间人攻击，劫持了用户的请求，密码会被泄露吗？中间人拥有真实服务器所有的数据，仿冒了真实的 Server ，因此，他可以解密出 Ticket 中的 SaltHash1 ，但是 SaltHash1 是无法解密出原始密码的。所以，密码也不会被泄露。但是，中间人攻击可以获取到最后的 TempKey ，从而能监听后续的所有通信过程。这是很难解决的问题，因为在服务端所有东西都暴露的情况下，中间人假设可以劫持用户数据，仿冒真实 Server , 是很难和真实的 Server 区分开的。解决的方法也许只有防止被中间人攻击，保证 Server 的公钥在客户端不被篡改。4.假设攻击已经进展到了这样的程度，还有办法补救吗？有。由于攻击者只能监听用户的登录过程，并不知道真实的密码。所以，只需要在服务端对 Salt2 进行升级，即可生成新的 SaltHash2 ，从而让攻击者所有攻击失效。具体是这样的：用户正常的登录，服务端验证通过后，生成新的 Salt2 ，然后根据传过来的 SaltHash1 重新计算了 SaltHash2 存入数据库。下次用户再次登录时，获取到的是新的 Salt2 ，密码没有变，同样能登录，攻击者之前拖库的那份数据也失效了。一些疑问1.使用 bcrypt 慢哈希函数，服务端应对大量的用户登录请求，性能承受的了吗？该方案中，细心一点会注意到， bcrypt 只是在客户端进行运算的，服务端是直接拿到客户端运算好的结果（ SaltHash1 ）后 SHA-512 计算结果进行验证的。所以，把性能压力分摊到了各个客户端。2.为什么要使用两个 Salt 值？使用两个 Salt 值，是为了防止拖库后，劫持了用户请求后将密码破解出来。只有拥有密码的用户，才能用第一个 Salt 值计算出 SaltHash1 ，并且不能反推回原始密码。第二个 Salt 值可以加大被拖库后直接解密出 SaltHash1 的难度。3.为什么要动态请求 Salt1 和 Salt2 ？Salt 值直接写在客户端肯定不好，而且写死了要修改还得升级客户端。动态请求 Salt 值，还可以实现不升级客户端的情况下，对密码进行动态升级：服务端可定期更换 Salt2 ，重新计算 SaltHash2 ，让攻击者即使拖了一次数据也很快处于失效状态。4.数据库都已经全被拖走了，密码不泄露还有什么意义呢？其实是有意义的，正如刚刚提到的升级 Salt2 的补救方案，用户可以在完全不知情的情况下，不需要修改密码就升级了账号体系。同时，保护好用户的密码，不被攻击者拿去撞别家网站的库，也是一份责任。欢迎大家针对本文的方案进行讨论，如有不实或者考虑不周的地方，请尽情指出。或者有更好的建议或意见，欢迎交流！一些反馈1.“应该从源头上禁止用户使用简单密码”非常同意！2.“获取 salt 并不需要啥验证，那么还有必要分开存储么，脱裤者直接根据uid调一遍接口不就拿到了？相当于就是公开的吧？”确实是这样。salt 相当于公开的了，没有必要分开存储了。如果你有更好的方法，请告诉我。3.“使用 HTTPS(SSL/TLS) 来保障传输的安全是不是就可以了？”理论上是足够了，而且推荐使用。 如果你的项目安全级别非常高，本着不信任绝对安全的角度可考虑再一层加固。4.“salt 使用密码学安全的随机数生成就够了，不需要使用 uid 。”同意，确实不是很必要。5.“服务器性能够强劲，bcrypt 放在服务端执行也没什么问题。”通过调整 bcrypt 参数让服务端执行在可接受的时间范围内确实可以。但是把这种耗时的操作放到客户端去做不是更好吗？6.“不知攻焉知防，还是使用现有的算法和协议比较好，不要自己发明。即使自己发明，也需要经过实践的检验不断迭代才行。”首先，文中用到的都是现有的成熟算法，如 bcrypt，SHA-512， AES ，包括 ECDH，并没有重新发明什么。文章重点是对密码的两次加盐哈希以及密码的验证方式。当然，方案需要在实践中不断迭代优化，我也是不能同意再多。有一位朋友说的非常好，很多互联网公司对安全不重视，近年来密码安全事故频繁发生，导致密码泄露后被拿去撞库，用户利益受损。应该去推动一下密码安全的业界标准，避免企业犯错用户买单。同时，互联网没有绝对的安全，强烈建议用户不要用同一个密码，密码定期改！最后，附上我当前这个博客系统的用户表数据，管理员用户名和密码就在这里，如果你是大神，欢迎尝试破解！",
    "postDate": "2019-01-30T23:40:45.3377295+08:00",
    "email": "admin@masuit.com",
    "label": "互联网,数据库,网络安全,云计算",
    "keyword": null,
    "id": 116,
    "indexId": "Post:116"
  },
  {
    "title": "这样也许能更直观地理解HTTPS为什么安全",
    "author": "懒得勤快",
    "content": "摘要：本文尝试一步步还原HTTPS的设计过程，以理解为什么HTTPS最终会是这副模样。但是这并不代表HTTPS的真实设计过程。在阅读本文时，你可以尝试放下已有的对HTTPS的理解，这样更利于“还原”过程。我们先不了聊HTTP，HTTPS，我们先从一个聊天软件说起，我们要实现A能发一个hello消息给B：如果我们要实现这个聊天软件，本文只考虑安全性问题，要实现A发给B的hello消息包，即使被中间人拦截到了，也无法得知消息的内容如何做到真正的安全？这个问题，很多人马上就想到了各种加密算法，什么对称加密、非对称加密、DES、RSA、XX、噼里啪啦~而我想说，加密算法只是解决方案，我们首先要做的是理解我们的问题域——什么是安全？我个人的理解是：A与B通信的内容，有且只有A和B有能力看到通信的真正内容好，问题域已经定义好了（现实中当然不止这一种定义）。对于解决方案，很容易就想到了对消息进行加密。题外话，但是只有这一种方法吗？我看未必，说不定在将来会出现一种物质打破当前世界的通信假设，实现真正意义上的保密。对于A与B这样的简单通信模型，我们很容易做出选择：这就是对称加密算法，其中图中的密钥S同时扮演加密和解密的角色。具体细节不是本文范畴。只要这个密钥S不公开给第三者，同时密钥S足够安全，我们就解决了我们一开始所定问题域了。因为世界上有且只有A与B知道如何加密和解密他们之间的消息。但是，在WWW环境下，我们的Web服务器的通信模型没有这么简单：如果服务器端对所有的客户端通信都使用同样的对称加密算法，无异于没有加密。那怎么办呢？即能使用对称加密算法，又不公开密钥？请读者思考21秒钟。😜答案是：Web服务器与每个客户端使用不同的对称加密算法：如何确定对称加密算法？慢着，另一个问题来了，我们的服务器端怎么告诉客户端该使用哪种对称加密算法？当然是通过协商。但是，你协商的过程是没有加密的，还是会被中间人拦截。那我们再对这个协商过程进行对称加密就好了，那你对协商过程加密的加密还是没有加密，怎么办？再加密不就好了……好吧，进行鸡生蛋蛋生鸡的问题了。如何对协商过程进行加密新问题来了，如何对协商过程进行加密？密码学领域中，有一种称为“非对称加密”的加密算法，特点是私钥加密后的密文，只要是公钥，都可以解密，但是公钥加密后的密文，只有私钥可以解密。私钥只有一个人有，而公钥可以发给所有的人。虽然服务器端向A、B……的方向还是不安全的，但是至少A、B向服务器端方向是安全的。好了，如何协商加密算法的问题，我们解决了：使用非对称加密算法进行对称加密算法协商过程。这下，你明白为什么HTTPS同时需要对称加密算法和非对称加密算法了吧？协商什么加密算法要达到Web服务器针对每个客户端使用不同的对称加密算法，同时，我们也不能让第三者知道这个对称加密算法是什么，怎么办？使用随机数，就是使用随机数来生成对称加密算法。这样就可以做到服务器和客户端每次交互都是新的加密算法、只有在交互的那一该才确定加密算法。这下，你明白为什么HTTPS协议握手阶段会有这么多的随机数了吧。如何得到公钥？细心的人可能已经注意到了如果使用非对称加密算法，我们的客户端A，B需要一开始就持有公钥，要不没法开展加密行为啊。这下，我们又遇到新问题了，如何让A、B客户端安全地得到公钥？我能想到的方案只有这些：方案1.&nbsp;服务器端将公钥发送给每一个客户端\n方案2.&nbsp;服务器端将公钥放到一个远程服务器，客户端可以请求得到我们选择方案1，因为方案2又多了一次请求，还要另外处理公钥的放置问题。公钥被调包了怎么办？又是一个鸡生蛋蛋生鸡问题？但是方案1有个问题：如果服务器端发送公钥给客户端时，被中间人调包了，怎么办？我画了张图方便理解：显然，让每个客户端的每个浏览器默认保存所有网站的公钥是不现实的。使用第三方机构的公钥解决鸡生蛋蛋生鸡问题公钥被调包的问题出现，是因为我们的客户端无法分辨返回公钥的人到底是中间人，还是真的服务器。这其实就是密码学中提的身份验证问题。如果让你来解决，你怎么解决？如果你了解过HTTPS，会知道使用数字证书来解决。但是你想过证书的本质是什么么？请放下你对HTTPS已有的知识，自己尝试找到解决方案。我是这样解决的。既然服务器需要将公钥传给客户端，这个过程本身是不安全，那么我们为什么不对这个过程本身再加密一次？可是，你是使用对称加密，还是非对称加密？这下好了，我感觉又进了鸡生蛋蛋生鸡问题了。问题的难点是如果我们选择直接将公钥传递给客户端的方案，我们始终无法解决公钥传递被中间人调包的问题。所以，我们不能直接将服务器的公钥传递给客户端，而是第三方机构使用它的私钥对我们的公钥进行加密后，再传给客户端。客户端再使用第三方机构的公钥进行解密。下图就是我们设计的第一版“数字证书”，证书中只有服务器交给第三方机构的公钥，而且这个公钥被第三方机构的私钥加密了：如果能解密，就说明这个公钥没有被中间人调包。因为如果中间人使用自己的私钥加密后的东西传给客户端，客户端是无法使用第三方的公钥进行解密的。话到此，我以为解决问题了。但是现实中HTTPS，还有一个数字签名的概念，我没法理解它的设计理由。原来，我漏掉了一个场景：第三方机构不可能只给你一家公司制作证书，它也可能会给中间人这样有坏心思的公司发放证书。这样的，中间人就有机会对你的证书进行调包，客户端在这种情况下是无法分辨出是接收的是你的证书，还是中间人的。因为不论中间人，还是你的证书，都能使用第三方机构的公钥进行解密。像下面这样：第三方机构向多家公司颁发证书的情况：客户端能解密同一家第三机构颁发的所有证书：最终导致其它持有同一家第三方机构证书的中间人可以进行调包：数字签名，解决同一机构颁发的不同证书被篡改问题要解决这个问题，我们首先要想清楚一个问题，辨别同一机构下不同证书的这个职责，我们应该放在哪？只能放到客户端了。意思是，客户端在拿到证书后，自己就有能力分辨证书是否被篡改了。如何才能有这个能力呢？我们从现实中找灵感。比如你是HR，你手上拿到候选人的学历证书，证书上写了持证人，颁发机构，颁发时间等等，同时证书上，还写有一个最重要的：证书编号！我们怎么鉴别这张证书是的真伪呢？只要拿着这个证书编号上相关机构去查，如果证书上的持证人与现实的这个候选人一致，同时证书编号也能对应上，那么就说明这个证书是真实的。我们的客户端能不能采用这个机制呢？像这样：可是，这个“第三方机构”到底是在哪呢？是一个远端服务？不可能吧？如果是个远端服务，整个交互都会慢了。所以，这个第三方机构的验证功能只能放在客户端的本地了。客户端本地怎么验证证书呢？客户端本地怎么验证证书呢？答案是证书本身就已经告诉客户端怎么验证证书的真伪。也就是证书上写着如何根据证书的内容生成证书编号。客户端拿到证书后根据证书上的方法自己生成一个证书编号，如果生成的证书编号与证书上的证书编号相同，那么说明这个证书是真实的。同时，为避免证书编号本身又被调包，所以使用第三方的私钥进行加密。这地方有些抽象，我们来个图帮助理解：证书的制作如图所示。证书中的“编号生成方法MD5”就是告诉客户端：你使用MD5对证书的内容求值就可以得到一个证书编号。当客户端拿到证书后，开始对证书中的内容进行验证，如果客户端计算出来的证书编号与证书中的证书编号相同，则验证通过：但是第三方机构的公钥怎么跑到了客户端的机器中呢？世界上这么多机器。其实呢，现实中，浏览器和操作系统都会维护一个权威的第三方机构列表（包括它们的公钥）。因为客户端接收到的证书中会写有颁发机构，客户端就根据这个颁发机构的值在本地找相应的公钥。题外话：如果浏览器和操作系统这道防线被破了，就没办法。想想当年自己装过的非常规XP系统，都害怕。说到这里，想必大家已经知道上文所说的，证书就是HTTPS中数字证书，证书编号就是数字签名，而第三方机构就是指数字证书签发机构（CA）。CA如何颁发数字证书给服务器端的？当我听到这个问题时，我误以为，我们的SERVER需要发网络请求到CA部门的服务器来拿这个证书。😭 到底是我理解能力问题，还是。。其实，问题应该是CA如何颁发给我们的网站管理员，而我们的管理员又如何将这个数字证书放到我们的服务器上。我们如何向CA申请呢？每个CA机构都大同小异，我在网上找了一个：拿到证书后，我们就可以将证书配置到自己的服务器上了。那么如何配置？这是具体细节了，留给大家google了。也许我们需要整理一下思路我们通过推算的方式尝试还原HTTPS的设计过程。这样，我们也就明白了为什么HTTPS比HTTP多那么多次的交互，为什么HTTPS的性能会差，以及找到HTTPS的性能优化点。而上面一大堆工作都是为了让客户端与服务器端安全地协商出一个对称加密算法。这就是HTTPS中的SSL/TLS协议主要干的活。剩下的就是通信时双方使用这个对称加密算法进行加密解密。以下是一张HTTPS协议的真实交互图：能不能用一句话总结HTTPS？答案是不能，因为HTTPS本身实在太复杂。但是我还是尝试使用一段话来总结HTTPS:HTTPS要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。好长的一段话。总结以上是个人为理解HTTPS而编造出来的自圆其说的看法。顶多只能算是HTTPS的科普文章。如有错误，请指出，万分感谢。那么，我为什么会觉得以这种方式理解HTTPS会更容易呢？我个人给出的答案是：当你自己为一家人做一次菜时，你就会理解妈妈天天做菜的不易了。学习资料：HTTPS为什么安全 &amp;分析 HTTPS 连接建立全过程数字证书的基础知识理解 HTTPSHTTPS 是如何保证安全的？图解SSL/TLS协议The First Few Milliseconds of an HTTPS ConnectionSSL/TLS原理详解",
    "postDate": "2019-01-30T23:40:45.3377988+08:00",
    "email": "admin@masuit.com",
    "label": "https,网络安全",
    "keyword": null,
    "id": 126,
    "indexId": "Post:126"
  },
  {
    "title": "面向对象的八大设计原则解析",
    "author": "懒得勤快",
    "content": "最近公司安排培训学习，既然培训了，那也跟大家一起分享下吧。开放封闭原则OCP核心思想：对扩展开放，对修改关闭。增加新功能，不改变原有代码。在软件系统开发过程中，软件的需求往往会随着时间的推移而发生变化。因此，进行软件设计时需要考虑怎样的设计才能面对需求的改变却可以相对保持稳定，从而使得系统可以在第一个版本以后不断推出新的版本。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在进行软件设计时，一般先评估出最有可能发生变化的类，然后构造抽象来隔离那些变化。当变化发生时，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。单一职责原则SRP核心思想：一个类有且只有一个改变它的原因。适用于基础类，不适用基于基础类构建复杂的聚合类。一个类不要负责太多“杂乱”的工作。在软件系统中，如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时设计或遭受到意想不到的破坏。以项目开发为例，如果项目组成员每个人的职责都很明确，可以专心开发自己负责的模块，则项目成果的质量往往很高。相反，如果职责不清晰，分工就会混乱，极有可能出现A负责N个模块，而B则可以在一旁开心地打酱油的情况。这样，如果A所负责的模块中有多个模块集中暴露问题时，A就很难高质量地将问题从容解决。自己负责领域的事情都做，不是自己领域的事不去插手。实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则。需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。依赖倒置原则DIP核心思想：客户端代码(调用的类)尽量依赖(使用)抽象的组件。抽象的是稳定的。实现是多变的。依赖倒置原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。我们需要针对抽象层编程，而将具体类的对象通过依赖注入的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。组合复用原则CRP核心思想：如果仅仅为了代码复用优先选择组合复用，而非继承复用。组合的耦合性相对继承低。尽量使用对象组合，而不是继承来达到复用的目的。在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）。由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用，相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。里氏替换原则LSP核心思想：父类出现的地方可以被子类替换，在替换后依然保持原功能。子类要拥有父类的所有功能。子类在重写父类方法时，尽量选择扩展重写，防止改变了功能。(1)子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。(2)尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，从而可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。是开闭原则的具体实现手段之一。接口隔离原则ISP核心思想：尽量定义小而精的接口interface，少定义大而全的接口。本质与单一职责相同。小接口之间功能隔离，实现类需要多个功能时可以选择多实现.或接口之间做继承。使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干，使接口的职责明确。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法。因此如果接口方法过多，其实现类中就不得不去处理许多自己根本不需要的方法。故大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。面向接口编程而非面向实现核心思想：客户端通过一系列抽象操作实例，而无需关注具体类型。便于灵活切换一系列功能。实现软件的并行开发。迪米特法则LOD核心思想：类与类交互时，在满足功能要求的基础上，传递的数据量越少越好。因为这样可能降低耦合度。一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。通过引入一个合理的第三者来降低现有对象之间的耦合度。在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。需要注意的：在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；\n在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；\n在对其他类的引用上，一个对象对其他对象的引用应当降到最低。附上脑图：http://naotu.baidu.com/file/14bf087a6589b5d0eded1932e83cf49c?token=ddf98356f26ba04a",
    "postDate": "2019-01-30T23:40:45.337861+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "面向对象,设计原则",
    "id": 1381,
    "indexId": "Post:1381"
  },
  {
    "title": "Bandcam录屏软件破解版",
    "author": "茄子炒肉多放辣",
    "content": "Bandicam(班迪录屏)与Fraps、Dxtory被广大游戏视频录制爱好者合称为世界三大游戏录制神器。其中Bandicam优势明显，绝对是广大视频录制爱好者的首选！！Bandicam 一款由韩国开发的高清录制视频的工具，Bandicam 的优势在于对电脑配置要求低，一些配置比较低端的电脑，通常录制视频会出现不同步现象，使用 Bandicam 就可以避免此问题。Bandicam录制的视频体积小，而且画面清晰，可以录制分辨率高达2560×1600高画质视频（1080p全高清视频可以做的），录制的时候可添加自己的LOGO到视频中，支持bmp、 png 与 jpeg 格式截图。功能介绍可同时录制电脑屏幕、电脑声音、麦克风声音。被录制的视频容量很小。(现有程序的1/5至1/20水平)如果硬盘容量足够，可24小时长时间录制视频。与其他软件不同，电脑上很少出现网速减慢现象(Lag)。支持图像截图(BMP、PNG、JPG)及连续截图功能。在录像对象屏幕上可添加网络摄像头(Webcam)视频。(可实时合并网络摄像头画面，PIP功能)无需编码，即可将录制的视频上传至You tube。(可上传720p及1080p)可录制电脑全屏，或选择指定区域录制视频。支持在预约时间开始录制视频，可使用自动结束的计时器功能。可通过硬件加速并快速录制高清视频，也能实现高压缩。支持CFR功能，能与Sony Vegas、Adobe Premiere等视频编辑软件兼容。使用方法一、可以选择游戏窗口或指定区域进行视频录制1、 全屏录制：能录制全屏游戏和窗口游戏。2、 窗口（区域）录制可录制（1）全屏游戏的绝大部分（2）窗口游戏（3）网上视频或音乐（4）网页游戏（5）屏幕操作等。二、录制视频：先运行软件，进入游戏后按快捷键（默认F12）开始录制，再按F12结束录制，按F8暂停。三、游戏截图：先运行软件，进入游戏后按快捷键（默认F11）就可截图。四、高清设置：首先是“大小”的设置。根据优酷的官方超清标准，上传视频分辨率必须达到或超过720p（1280x720），码率必须在1.5Mbps以上，首先确定你所使用的显示器的分辨率，如果是19寸宽屏，则为1440x900，那么你这“大小”就必须设置为“完全”或者“宽度”数值1280。编码器可选MPEG-1和Xvid，勾选VBR，也就是动态码率，该功能可以根据视频画面的复杂与否自行判断实时码率，可以在保证录制质量的前提下减小视频体积。录制质量建议选择100，保证原文件的质量才能更好地保证渲染转码后输出视频的质量。音效这里就一个关键点，就是编码器默认的MPEG-1 L2，会导致会声会影渲染输出出错，程序强行关闭，Vegas虽然可以完成转码，但输出的视频只有图像没有声音。改为PCM后一切正常，推荐使用PCM。Bandicam录制超清视频教程：http://www.pc6.com/infoview/Article_82094.html更新日志1 增加截图的复制到剪贴板功能2 支持 AMD VCE H.264编码器分辨率高达4096x21603 增加未选择录制模式而点击“自动开始录制“时弹出错误信息4 改善把录制窗口拖动时手绘涂鸦工具也一起拖动5 改善 Bandicam 启动速度性能6 改写 AMD APP 更改到 AMD VCE 单词7 解决在全屏录制时光标（鼠标操作）功能不正常动作的问题8 解决其他部分问题下载地址https://www.lanzous.com/i2jh11a",
    "postDate": "2019-01-30T23:40:45.3379232+08:00",
    "email": "iamsocoool@vip.qq.com",
    "label": null,
    "keyword": null,
    "id": 1394,
    "indexId": "Post:1394"
  },
  {
    "title": "谈一谈单例模式、静态类和线程内唯一对象有什么区别",
    "author": "懒得勤快",
    "content": "说起单例模式、静态类、线程内唯一对象，想必大家都不陌生，或多或少都用过，然而在什么场景下我们该选用哪种模式？以及它们之间到底有什么根本的区别？今天我们就来详细的研究一下它们之间的联系和区别。这样的问题也是在面试的时候经常会被问到或提起的一个问题。可能这三者，我们最常用的也就是单例模式了，单例模式用在什么场合，为什么不用静态类而用单例？首先，我们得从静态方法和非静态方法的区别和联系说起。静态方法常驻内存，实例方法只有在使用的时候才加载？一般我们都是这样理解的，并且是为了防止静态方法占用过多内存而建议使用实例方法，其实这样的理解不完全正确。为什么要这样说？我们得从内存的分配开始讲起：托管堆的定义：对于应用程序来说，应用程序完成进程的初始化之后，CLR将会在应用程序域中的可用内存地址分配一块保留的内存空间，它是进程(假设是32位应用程序，那么每个进程理论上可使用4GB)中可用地址空间上的一片区域，但并不针对任何物理内存，这块内存空间就是托管堆。而托管堆又分为了多个区域，其中最重要的也就是垃圾回收堆(GC Heap)和加载堆(Loader Heap)了，垃圾回收堆用于存储对象实例，这样就受GC管理了，而加载堆又分为了High-Frequency Heap、Low-Frequency Heap和Stub Heap，不同的堆上又存储不同的信息。Loader Heap最重要的信息就是元数据相关的信息，也就是Type对象，每个Type在Loader Heap上体现为一个Method Table（方法表），而Method Table中则记录了存储的元数据信息，例如基类型、静态字段、实现的接口、所有的方法等等。Loader Heap不受GC控制，其生命周期为从创建到AppDomain卸载。（选自《你必须知道的.Net》）到这里我们就应该明白了，静态方法和实例方法在内存里其实都放在了方法区(Method Table)里了，当一个类第一次加载的时候，它会在加载堆里面将静态方法和实例方法都写入到方法区，而且加载堆不受GC控制，所以一旦被加载，就不会被回收了，直到应用程序生命周期结束。由此我们明白了，静态方法和实例方法它们都是在首次加载后常驻内存，所以方法本身就在内存里，没有什么区别，在C#里面，方法也本身也是作为一个特殊的对象而存在，而刚才也说了加载堆里存放的是类的元数据Type对象，而这个Type对象在之前的这篇文章中也提到，Type是所有class实例所共有的，所有实例的每个方法对应的都是同一对象。所以也就不存在“静态方法常驻内存，实例方法只有在使用的时候才加载”这个说法了。静态类和实例对象的区别？在内存中的区别是，实例对象在创建对象时，因为属性的值对于每个对象都各不相同，因此在new创建对象时，会把这个实例属性在GC堆中拷贝一份，同时将这个对象放到堆内存上，内存指针指向了刚才拷贝的一份实例的内存地址，而静态类则不需要，因为静态类里的静态方法和属性，已经在方法表里了，只有一份。为什么要有实例方法？早期的时候，还是结构化编程，也就是面向过程，还没有面向对象这个概念，几乎所有的方法都是“静态方法”，而引入了面向对象这个概念以后，区分静态方法和实例方法不能单方面的从性能上去理解，发明C++、java、C#语言的这些大师们引入实例方法并不是解决什么性能、内存的问题，而是为了让开发更加模块化、面向对象化。归根结底其实静态方法和实例方法的区分是为了解决开发模式的问题。那我们继续思考，如果我们全部用静态方法，而不用实例方法，不也一样的能实现功能嘛，像stackoverflow一样，大量的静态方法支撑起了世界第56大网站，这也不是不可以，但是，这样的代码是基于对象的，而不是面向对象的，只是这样看上去有悖于面向对象的概念，因为面向对象的继承和多态，都是非静态方法。其次，为什么不建议都用静态方法，试想如果我们在高并发的情况下，某个静态方法引用了一个静态字段，那么这个静态字段就会被多个线程共享，因此，静态方法里面用了静态变量，这就会有线程安全问题，当然，就算不是多线程，因为静态字段只有一份，同样有可能会被其他地方修改的问题。结论什么时候用静态方法，什么时候使用实例方法？既然静态方法和实例方法只是解决开发模式的问题，那么如果我们不考虑继承和多态，就可以使用静态方法，但就算不考虑继承和多态，就一概使用静态方法也不是什么好的编程习惯。换个角度考虑，如果一个方法和它所在的实例对象无关，那么它应该是静态的，否则就因该是非静态的，因此就像一个工具类，它一般是静态的。那么为什么用单例而不是静态类？从面向对象的角度讲，虽然都能实现相同的功能，但是它们一个是基于对象，一个是面向对象的，就像我们不用面向对象也能解决问题一样，面向对象只是提供了一个更高层次的编程思想。如果一个方法和它所在的实例对象无关，那么它应该是静态的，否则就因该是非静态的。如果我们确实应该使用实例方法，但是在整个应用程序的生命周期中又确实只需要维护一份实例时，就需要用单例模式了。比如我们应用程序启动的时候需要加载一些配置和属性，这些配置和属性一定是存在的咯，又是公共的，同时又要伴随应用程序的整个生命周期存在，所以只需要加载一次就行，而这个时候我们需要再new一个的时候，再指定值，这显然是浪费内存并且再次赋值是没有意义的事情，所以这样的场景我们就需要使用单例模式或者静态类去维持有且仅有的一份，但这样的配置和属性又是通过面向对象的编码方式而得到的，那就只能是单例模式，或者不面向对象，但本身的属性是面向对象的，我们使用静态类也能解决这样的问题，但最好的解决方案还是单例模式。从功能上讲，单例模式可以控制实例的数量，同时也是个实例类，可以进行有意义的派生，对实例的创建有更自由的控制。静态类和单例类有什么区别？我们已经基本上得出了结论，似乎发现静态类和单例类除了开发模式上，就真的没什么区别了么？仍然从内存的角度考虑，如果静态类中包含了一些预先初始化的字段，那么静态类是一启动就常驻内存，而单例类延迟加载了。诶，这不和一开篇所提出的问题相矛盾了么？请注意，这并不矛盾，开篇提到的仅仅是静态方法和实例方法，并没有说到字段的存在，字段是个内存引用，而属性，其实也是对应的get、set方法。上文说了这么多，都是单例和静态类的，也没有半句提到线程内唯一对象，那这个线程内唯一对象跟它们又有什么联系和区别呢，有了上文的认知，我们接下来才能更清楚的了解线程内唯一对象。典型场景：数据库访问为什么要用线程内唯一对象？我们做.NET的一定都用过EntityFramework，当初在学习的时候老师也教我们说封装的时候要将DbContext封装成一个线程内唯一对象，为什么用单例不行？假设用了单例，那么造成的问题可能就是：1.因为单例的存在，造成了数据库连接connection对象也封存在了单例中，而数据库连接池中是有很多连接可以用的，那么被单例化了，在web并发访问的时候，所有请求就只能共用一个数据库连接，那是不是造成悲剧了；2.其次，因为DbContext要跟踪实体的上下文，如果使用了单例，那么所有用户的请求都共用了这个数据上下文对象，当你在执行某个修改操作的时候，但并没有提交，可能同时其他人在执行保存数据的操作，那么你的数据也就被其他人操纵了；3.正是由于数据上下文对象对实体的跟踪，排除刚才的数据被其他人操作的情况，如果是单例，那么所有用户操作数据时，数据实体都被跟踪到DbContext，假设有百万千万级的用户同时在线，那这个DbContext的负担是不是很大，内存会不会爆了？我们再举个场景，比如我们在同一个请求里，这个请求从开始到结束肯定是同一线程咯，也就是HttpContext在请求的开始到结束都唯一存在，我们的DAL层在某个方法里调用某张数据表，要进行修改操作，在另一个方法里调用另外一张数据表，要进行插入操作，如果我们每次调用都实例化一个DbContext，那么这样就执行了两次数据保存操作，而如果使用了线程内唯一对象，那么我们只需要在请求结束前将两次数据的更新和添加，执行一次SaveChanges，就可以了。针对数据库访问的单例，其实连接池可以做成单例，其实也不叫单例，确切点说是对象池模式，这种模式类似于单例，对象池实例在初始化的时候，比如创建100个Connection对象先存到一个集合里，这个集合就像是个池子，所以叫对象池，每次GetInstance的时候从对象池里面拿出一个实例，用完了再放回来或者释放掉，当池子里面的对象都用完了，GetInstance的时候检测到拿不出对象，则再创建一定数量的对象存到池子里，并拿出一个对象实例。",
    "postDate": "2019-01-30T23:40:45.3379844+08:00",
    "email": "admin@masuit.com",
    "label": ".NET,C#,高并发,数据库",
    "keyword": null,
    "id": 1204,
    "indexId": "Post:1204"
  },
  {
    "title": "OmniGroup全系列注册机（支持OmniPlan v3、OmniGraffie v7、OmniFocus v2...）",
    "author": "懒得勤快",
    "content": "随着macOS Sierra 10.12普及，OmniGroup全系列软件均大版本更新，原先的注册机不适用，同时也不兼容10.12，因此… 编不下去了，还是切入主题吧：OmniGroup全系列注册机支持情况：✅&nbsp; &nbsp;macOS Sierra 10.12✅&nbsp; &nbsp;OmniGraffle v7.x✅&nbsp; &nbsp;OmniPlan v3.x✅&nbsp; &nbsp;OmniFocus v2.x✅&nbsp; &nbsp;OmniPlan v3.x✅&nbsp; &nbsp;OmniOutliner v5.x刚看到竟然有锋友帮别人算号，又是几千块价值、又是留邮箱，感觉很麻烦，毕竟用的是Core团队的成果，还未标注声明，有剽窃之嫌，总之让人不舒服，明白的人总会明白，不懂得也就不说了正文：OmniGroup的软件可以自己去官网下载：https://www.omnigroup.com/注册机说明：下载附件，并打开双击运行：Omni_keygen_2016.app（2014版是给老版本产品用的）点击下拉框选择你的产品点击Owner输入框：输入注册用户名点击Generate，Lic Key会自动生成鼠标双击Lic Key输入框，复制序列号（注册码）打开软件的许可证页面，点击添加注册码在所有者中输入注册用户名，在许可证密匙中粘贴注册码具体步骤见图：Core Keygen1Core Keygen2Core Keygen3OmniGroup 全系列下载OmniPlan：OmniPlan-3.10.2.dmgOmniGraffle：OmniGraffle-7.9.2.dmgOmniFocus：OmniFocus-2.12.3.dmgOmniOutliner：OmniOutliner-5.3.4.dmg破解补丁下载附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!点击前往稀缺资源统一下载地址页",
    "postDate": "2019-01-30T23:40:45.3380456+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "Omni Group",
    "id": 1371,
    "indexId": "Post:1371"
  },
  {
    "title": "计算机入门实用教程-写给非IT人员的计算机指南",
    "author": "懒得勤快",
    "content": "文档下载：https://pan.baidu.com/s/1R_azFI8Y2qPIQ0uLzMzEcw以下是试读部分：Q&amp;AQ:看本书需要什么基础？A:本书是专为电脑小白而打造的一本计算机常用的实用技巧集，不管你曾经有没有接触过电脑，只要你有兴趣，你就能把这里面的东西都变成你自己的东西。Q:本书适合哪一类人群？A: 这本书没有针对某部份人群，可以说适合所有在工作中需要使用电脑的人们。编者寄语为想学计算机而又不知道从何入手的童鞋而著书，为想学计算机而又想少走弯路的朋友而著书。发扬互联网精神，一切为了你们！敢于尝试，你将会得到巨大的收获，大胆地去尝试，你会发现，原来，一切都很神秘的事物原来不过如此简单！也许，下一个大神就是你！希望大家能喜欢这本书，并且付诸实践，闻见知行……——懒得勤快2016年1月前言随着科技的发展，随着时代的进步，随着大数据时代的来临，随着智慧地球正在慢慢实现，随着新硬件时代的到来，计算机、互联网都成为了我们生活中的必不可少的一部分，如今是一个离不开计算机和网络的时代，现在这个时代，如果没有网络，就好比20世纪没有电一样痛苦，计算机和网络可见在我们的日常生活中扮演着重要的角色。好道是：有网走遍天下，无网寸步难行；有网光阴似箭，无网度日如年；有网天下无敌，无网手无缚鸡之力！然而在计算机和互联网高速发展的今天，我们的身边还有不少的电脑小白，他们可能从没接触过计算机，买了一台电脑，却不懂得如何如何去使用好这台计算机，也不懂得如何去管理好自己的计算机，再加上在中国这样的环境下，造成的结果就是懂电脑的人非常懂电脑，不懂电脑的人也不愿意学电脑。OK,never claver and get to business（闲话少说言归正传），这是一本技术教程，我真心诚意会用很简单的文字表达清楚自己的意思，只要你识字就能看懂，就能学到知识。我写这本教程的目的，是让每一个看过这些文字的朋友记住一句话：如果爱可以让事情变的更简单，那么就让它简单吧！看这篇教程的方法，就是慢！慢慢的，如同品一杯茗茶，你会发现很多以前就在眼前的东西突然变的很遥远，而有些很遥远的东西却又突然回到了眼前。学习计算机的目的，不仅仅是为了让自己多一项技能，更重要的是让你自己更能有效地去管理和利用好自己的计算机，为自己完成更多的事情，我会用很多简单实用的例子让读这本教程的朋友去体会计算机世界那四射的魅力，感受它那古灵精怪的性格，不知不觉中爱上计算机（晕，怎么又是爱？到底计算机和爱有什么关系？答案：没有！）。先来个简单的小技巧，感受一下折腾电脑的乐趣：还在为网上找资源总是找到假资源而烦恼吗？自己发现个好资源，想要下载，结果下载下来之后发现TMD竟然是一个冒牌货，双击它，卧槽！XXX全家桶正在安装……顿时心碎的感觉有木有？！这样的情况我们每个人都遇到过吧。好了，现在就简单的说一下搜索引擎的高级搜索功能：假如我是一位大学的计算机老师，由于时间紧促，来不及备课做ppt，&nbsp;这时想到的就是马上上网搜一下有木有相关的ppt资料下载。好了，我就以下载&quot;计算机网络.ppt&quot;为例吧。直接上谷歌搜索&quot;计算机网络课件&quot;这几个关键字，出来的肯定是一大堆的网页链接，进去后又不知道下载地址在哪里藏着，怎么办？试试高级搜索，在搜索框里输入：计算机网络&nbsp;filetype:ppt通过这个实例，有木有觉得很有意思呢！或许刚才这个你觉得不太感兴趣，别急，我会让你爱上计算机的，我再来个小技巧，当你在逛某某贴吧或者某某论坛的时候，有些好贴你发现了大量的好图片资源，想赶紧收藏起来，你是不是一张一张图片都右键然后另存为？！这样的话你不觉得麻烦吗？！当一个页面里有数百张你想要的图片时，你要一张一张地另存为这样去操作，这一下来不把你手点痛我都不相信，既辛苦又没效率(卧槽！这是什么网页，一个页面里竟然能有这么多吸引你的图片，我相信你我都是聪明人，哈哈！我真不知道是什么网页，好吧，那你就尽情地发挥一下你的想象空间吧)。既然有好方法，那我就不卖关子了，来点实际的，我这个人喜欢逛论坛，有时候难免会看到一些养眼的资源值得收藏，注意哦，重点来了，打开一个贴子，发现里面好多资源，打开这个文件夹，你会发现这个网页里面所有的东西都在这里面，然后，不用我再继续说怎么做了吧。是不是觉得下图片很快很方便啊，赶紧打开你想要下载图片的网页试试吧。&nbsp;&nbsp;&nbsp;&nbsp;怎么样，看到这里，你对计算机是不是已经有点兴趣了？是不是发现自己已经慢慢爱上了这个东东？别高兴的太早，爱不是一件简单的事，它也许能带给你快乐和幸福，当然也能让你痛苦的想去跳楼。如果你知道很难还敢继续的话，I服了YOU！继续努力吧，也许到最后你不一定得到真爱（真的有这可能，爱过的人都知道），但你可以体会到整个爱的过程，就是如此。酸、苦和辣，有没有甜天知道。为什么会把计算机和爱情扯上关系？不是我无聊，也不是因为这样写有趣多少，原因有二：其一，计算机世界和爱情有很多相同的地方，有些地方我用&quot;专业&quot;的行话解释不清（我不怀疑自己的表达能力，而是事情本身就不好说清楚），说了=没说，但用地球人都知道的比喻一爱情（爱情是什么？我TM怎么知道！！），没准你心里一下就亮堂了，事半功倍，何乐而不为？其二，我这段时间状态不是很好，主要还是感情上精神摧残，搞的人烦透了，借写教程之际感慨几句，大家就全当买狗皮膏药了，完全可以省略不看（也许还真有点效果---不至于让你看着看着就睡着了，把头磕了来找我报销医药费）。说不定下次的教程中大家还会看到杨过、张无忌等金老前辈笔下的英雄们。&nbsp;&nbsp;&nbsp;&nbsp;然而，很多童鞋也正处于深受国产软件毒害得水深火热之中，要我说，国产&quot;流氓&quot;软件是真没把用户当成一回事，表面上说是帮你优化电脑、为你的电脑保驾护航，它在背地里到底干了些什么事情，我想用过的人和正在使用的人，你们的感受我想都是差不多的。从第一章开始，将由浅入深的带你了解计算机，学习计算机的一些使用技巧、维护策略、管理方案、优化美化等实用技能，本教程主打实用，旨在让更懂不懂电脑的人能玩转电脑，而绝不是为了让你能顺利过二级考试而生的。本教程所讲到的内容对你还有你的将来，我敢打包票的说，绝对都是你能够经常用到的一些小技巧，哪怕你现在什么也不会。你要是觉得本教程所讲到的某个内容即使学了也并没有什么卵用，你可以拿刀砍我，我就是可以把话说得这么绝！我会把我都知道的，并且是我每天都在用的东西，尽大可能地讲授给你们，授人以渔，不如授之以渔，只要你跟着我的思路走，我相信，通过本教程，你一定会成为一个计算机高手，成为一个人人都膜拜的计算机大神！好了，就不扯远了，下面就开始我们的学习之旅吧。&nbsp;文档下载：https://pan.baidu.com/s/1R_azFI8Y2qPIQ0uLzMzEcw",
    "postDate": "2019-01-30T23:40:45.3381067+08:00",
    "email": "admin@masuit.com",
    "label": "计算机基础",
    "keyword": "计算机入门实用教程,写给非IT人员的计算机指南",
    "id": 90,
    "indexId": "Post:90"
  },
  {
    "title": "Corel Products KeyGen 20180618",
    "author": "懒得勤快",
    "content": "Corel的产品在设计行业非常知名了，甚至于媒体和办公软件也有Corel的身影。老殁作为一个非专业的设计狗，对Corel旗下的产品也非常熟悉了，不过由于Corel的价格比较昂贵，很多小伙伴也是望尘莫及。这里给大家分享一个Corel的KeyGen吧。软件截图支持列表* CorelDRAW Technical Suite 2018 激活* Lattice3D Studio Corel Edition v4.0 激活* Corel DESIGNER Technical Suite X5* CorelDRAW Graphics Suite X6* CorelDRAW Graphics Suite X7* CorelDRAW Graphics Suite X8* CorelDRAW Graphics Suite 2017* CorelDRAW Technical Suite X6* CorelDRAW Technical Suite X7* Corel MotionStudio 3D* Corel Office v5.0* Corel Paint It! v1.0.0.127* Corel Painter 12* Corel Painter X3* Corel Painter 2015* Corel Painter 2016* Corel Painter 2017* Corel Painter 2018* Corel Painter Essentials 5* Corel Painter Essentials 6* Corel PaintShop Pro X5* Corel PaintShop Pro X6* Corel PaintShop Pro X7* Corel PaintShop Pro X8* Corel PaintShop Pro X9* Corel PaintShop Pro 2018* Corel PaintShop Ultimate 2018* Corel ParticleShop v1.0.516* Corel Perfect Authority v1.3会声会影2018旗舰版 / X10旗舰版* Corel VideoStudio Pro/Ultimate X5* Corel VideoStudio Pro/Ultimate X6*&nbsp;Corel VideoStudio&nbsp;Pro/Ultimate X7* Corel VideoStudio Pro/Ultimate X8* Corel VideoStudio Pro/Ultimate X9* Corel VideoStudio Ultimate X10* Corel VideoStudio Ultimate 2018* Corel WinDVD Pro 11* Corel WinDVD Pro 12* Corel WordPerfect Office X6* Corel WordPerfect Office X7* Corel WordPerfect Office X8* XVL Studio 3D CAD Corel Edition v1.0* Lattice3D Studio Corel Edition v2.0* Corel AfterShot Pro v1.1.0.30* Corel AfterShot Pro v2.0.3.25* Corel AfterShot Pro v3.0.0.126* Corel AfterShot Pro v3 Roxio Edition* Noise Ninja v2.0.1* Corel PDF Fusion v1.11官方更新2018/06/18增加 CorelDRAW Technical Suite 2018 激活增加 Lattice3D Studio Corel Edition v4.0 激活2018/04/19 Up3：CorelDRAW Technical Suite 2017Corel Draw Graphics Suite 2018Corel Painter 2018Lattice3d Studio Corel Edition 3.02018/04/16 Up2：CorelDRAW Graphics Suite 20182018/02/20：Corel Video Studio Ultimate 2018Corel Painter Essentials 6Corel PaintShop Pro 2018 Ultimate/Pro下载地址附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!稀缺资源统一下载地址页",
    "postDate": "2019-01-30T23:40:45.3381678+08:00",
    "email": "admin@masuit.com",
    "label": "Corel",
    "keyword": "Corel Products KeyGen,Corel全家桶",
    "id": 1237,
    "indexId": "Post:1237"
  },
  {
    "title": "Paragon NTFS for Mac 15.4.11 苹果NTFS支持软件",
    "author": "Mannix",
    "content": "Paragon NTFS for Mac®完全兼容苹果新的安全政策，确保快速、轻松和安全的访问NTFS分区从MacOS 10.12。一旦安装了程序，用户就可以立即开始：方便地导航内容，读取、编辑、复制或创建文件和文件夹。司机保证NTFS文件系统先进的支持和提供快速和透明的读写访问任何NTFS分区在MacOS 10.12。在MacOS Sierra无限访问NTFS卷！在OS X下对NTFS分区的完全读/写访问前所未有的高NTFS性能易于安装和使用验证、修复和格式化选项MacOS 10.12 Sierra支持效率就是一切Paragon NTFS for Mac®是世界上速度最快的应用，实现本地的驱动速度，对应的Sierra！卷管理工具允许格式化、检查和修复NTFS卷。安装它，让它去。就是这么简单您将访问Mac的Mac上的Windows分区，这样您自然会忘记到底是谁在运行这个节目。安全事项Paragon NTFS for Mac®提供Windows和Mac®®之间没有数据交换，即使在繁重的工作公用事业附加在Mac上格式化任何分区作为NTFS，检查NTFS分区的完整性和控制驱动行为最近对Mac的NTFS更改：–多语言版–MacOS 10.12 Sierra支持-验证、修复和格式化选项；所有操作只需轻轻一点轻量级的快捷菜单栏，可访问所有NTFS驱动器并执行最常见的卷操作，如挂载，卸载和验证。从菜单栏中快速启动NTFS for Mac界面，一键点击，更加方便。完美设计 无缝体验 简单操作NTFS for Mac继承了苹果公司的最佳磁盘实用程序，并将其升级到新的水平，增加了NTFS卷操作和高级安装选项。只需将硬盘或者其他外置存储设备与Mac相连即可访问NTFS格式文件。高级选项 支持全面操作启用所有权：允许指定用户读写文件或文件夹。保存上次访问时间：随时调用上次访问的每个文件。&nbsp;启用Spotlight索引：可即时Spotlight搜索，查看空间详细信息。以只读方式安装：可访问敏感数据而不修改任何文件。&nbsp;不要自动挂载：可支持手动控制对卷的访问。下载地址附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!磁力下载：magnet:?xt=urn:btih:18BD281E458CA243811E7A9DC2AAC5E264874CD0gitlab下载：稀缺资源统一下载地址页",
    "postDate": "2019-01-30T23:40:45.3382652+08:00",
    "email": "794450497@qq.com",
    "label": null,
    "keyword": "Paragon NTFS",
    "id": 1361,
    "indexId": "Post:1361"
  },
  {
    "title": "BetterZip 4.2.1(1439) 快速的压缩工具破解版",
    "author": "懒得勤快",
    "content": "BetterZip是一款功能强大的压缩软件，不必解压就能快速地检查压缩文档。它能执行文件之间的合并并提供密码。使用它，用户可以更快捷的向压缩文件中添加和删除文件。它支持包括zip、gz、bz、bz2、tar、tgz、tbz、rar、7-zip、cpio、 arj、lha、lhz、cab、iso、chm、rpm、deb、nsis、sit、dd、hqx和bin等多种格式的文件。此外，它还能让文件在Windows 和Linux系统中兼容。BetterZip是Mac平台比较有名的压缩解压缩软件，类似于windows平台的Winrar。应用介绍BetterZip for Mac让您快速检查档案，而不首先提取其内容。BetterZip for Mac只对你真正需要的文件进行解压：如果你只需要从一个更大的存档中几个文件或文件夹，您不必提取整个事情。只需将任何Finder窗口或桌面的文件拖动到BetterZip for Mac窗口中即可。无需解压的开放档案：BetterZip for Mac不仅可以开放档案，不先提取它们，你也可以使用类似于iTunes的界面搜索一个文件。 BetterZip for Mac可以打开最常见的格式： ZIP ， SIT ， TAR ， XAR ，GZIP ，BZIP2 ， RAR ， 7 -ZIP ， CPIO ， ARJ ， LZH / WAR ， JAR ， LHA ， CAB ， ISO ， CHM ， RPM和提取档案， DEB ，NSIS ， BIN ， HQX 。创建归档：只需从您的硬盘驱动器，磁盘，或网络的地方拖动文件和文件夹到新的zip文件。您再也不用到一个临时文件夹中的所有文件复制。支持的格式包括ZIP ， TAR ，GZIP和bzip2压缩的tar ， XAR ， 7 - ZIP ， RAR （使用外部RAR命令行工具） 。大型归档，也可以分割。保护您的数据：BetterZip for Mac可以保护您的数据，一个密码和创建兼容的WinZip AES -256加密档案。 7- ZIP和RAR档案也可以受到保护。下载地址附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!点击前往稀缺资源统一下载地址页",
    "postDate": "2019-01-30T23:40:45.3383274+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "BetterZip,压缩,解压",
    "id": 1366,
    "indexId": "Post:1366"
  },
  {
    "title": "IT职场跳槽季：开发者专属技术简历攻略，帮你提高面试率70％",
    "author": "懒得勤快",
    "content": "上次给大家分享了一下面试攻略，这次跟大家谈谈写简历相关的。基本策略大部分情况下，简历都是很重要的敲门砖，必须把自己的真实水平描述出来，让企业认识到你的价值，展现出你有能力应对这份工作。因为只有足够优秀的人，企业才能更看重你，也有更大几率谈下高薪。所以根本策略就是体现出你的水平和阅历简历虽然不是论文，但也要具备一定的论证逻辑，让看的人觉得你优秀。所以简历上的每一点都应该是经过精雕细琢的，经得起推敲并具备一定意义的。随时更新不建议用同一份简历去海投，简历是很重要的资料，海投更是效率不高。求职者要对你投递的公司有基本的了解，业务方向、公司企业文化、从事的行业等等，假如可能，也应该了解你所投递的具体部门是做什么的，是应用开发部门，还是技术研发部门。搜集这些的目的是为了让你更好的做决断，假如你对这家公司很满意，那可以在简历上根据特定的情况做些修改，比如说这家公司特别需要数据挖掘方面的人才，那么在简历中，可以有倾向性的多描述一些相关的经验和见识。渠道也很重要，假如你知道看简历的人是 HR，那么描述上可以强调工作经历，因为他不是技术专家，只会看一些自己感兴趣的东西，比如你曾经的职位和公司。所以你可以重点标出hr可能感兴趣的内容。假如是内推，很可能看你简历的人是技术管理者，这些人最关心你用什么语言，做过什么项目，所以你要重点在简历上体现这些。归根结底，写的简历要考虑第一筛选人，简历是动态变化的（技术是变化的，人亦如此）。基本法则现在你有了心仪的公司，了解了足够多的信息，准备开写了，这时候要掌握一定的基本法则，不要小事情上犯错。千万不要有错别字，标点符号要使用准确，很多人一看到有这些错误，80％会放弃你的简历，虽然可能就是你的一个小失误。写简历不是写论文，篇幅上不要太多，最好不要超过三页，hr每天阅简历无数，假如你写太多，根本没心思去看完，也可能会干扰判断，所以要简单明了。最好是 PDF 格式的，也不要使用很多招聘网站的简历模版，选择你认为正确的模版，因为那体现了你的思维模式。（播妞会提供一些好的模板）不要浮夸，更不要弄虚做假，可以有一定的修饰，擅长的多写，不擅长的少写。你写的每行都是经过你仔细考虑的，假如你觉得没用，千万不要写，切记画蛇添足。掌握了这些基本法则后，就要开始去写了，写简历先要有个基本模版，也就是大纲，简历的骨架。简历大纲主要体现了你想表达的信息，同时顺序也非常重要，你总不希望自己的闪光点别人看不到把。列举：基本信息\n工作经历\n项目经验\n专业技能\n其他基本信息基本信息尽量简单，没有用就少写，能提升自己分量的就多写工作经历这个要和项目区别写，工作经历主要体现你在曾经的公司，岗位和职位，专注的技术领域，获得过的成就。简历筛选者会通过这些评估你：是不是经常离职、在某家公司是不是有进步，所处的行业是什么。举个例子：2013年~2017年，供职于某公司开发部，先后历任软件开发工程师、项目经理、架构师岗位，目前主要负责架构设计工作、核心项目的开发工作，主要使用XXX技术，在公司期间各获得优秀员工三次。项目经验项目经验是比较重要的，从中能看出一个人到底干了啥，是技术的实践家还是理论的提出者，在这个项目的贡献度多大，获得了什么成长，收获了那些经验。假如说公司经历可能有点虚，那项目经验就能让人看出几斤几两。在写项目经验时有几个点需要留意：很多人说，我在上家主要是做维护工作，产品比较稳定，好像没什么可写的。其实维护工作也很有挑战，需要快速的分析和解决能力，可以总结这方面的经验比如使用了自动化机制、通过某些策略快速解决了某些问题。也有人说，虽然也经历过不少项目，但都是打酱油，这怎么写呢？第一你不要把别人做的工作全部写成是自己的，因为也许一问就露陷了，毕竟实践很重要，没有实践光看 PPT 是很难掌握的。但假如你对这个项目的技术实现有深刻的理解，而且后续也一直关注这个产品的演变和进化，那么适当的可以写成自己的工作经历。提几个重要的项目在简历中描述即可，千万不要太多，没有那么多时间看，由于在简历中你没法用图表和大块的语言去论证你在这个项目起到了非常大的作用，所以用语一定要精准。举个例子：主要负责产品的维护工作，产品作为公司的核心项目，主要服务于企业用户，所以快速响应能力尤为重要，在任职期间，领导开发了&quot;客户问题智能搜集工具&quot;、“实时日志搜集和分析系统”，通过这些技术手段，每天的投诉减少了百分之二十，客服响应问题时间也快了百分之二十，获得了用户的极大认可。通过此项目自己也意识到，服务始终第一，任何的技术解决手段的核心目的是解决用户的问题，同时培养了自己坚韧的攻坚能力，能够快速解决未知的问题。通过上面例子，体现你在技能上具备相当的实力，为公司业务的发展做了极大的支撑，你的价值也极大的涌现，假如应聘的公司选择了你，可以在某一领域得到非常多的经验，能够让公司的技术能力提升一大块。专业技能专业技能主要是你掌握的技术，记住假如掌握的并不透彻，尽量少使用“精通”这两个字。专业技能能够让应聘的公司了解你掌握的技能是否符合要求。专业技能建议不要写的特别多，写一些能提升你分量的技能，同时专业术语不要用错， 多写一些能落地的技能，理论性的技能尽量少写。举个例子：精通&nbsp;Java和&nbsp;Python&nbsp;开发语言，拥有X年的一线开发经验\n了解主流的&nbsp;WEB&nbsp;服务器，对于Apache&nbsp;的配置、优化、机制、维护有一定经验\n了解&nbsp;Mysql&nbsp;服务的使用，对于&nbsp;Mysql&nbsp;的优化、业务设计、集群配置、运维有X年的实践\n了解&nbsp;CentOS、Ubuntu&nbsp;操作系统，会基本的&nbsp;Linux&nbsp;操作和管理&nbsp;。\n熟练使用&nbsp;Redis、Memcached、MongoDB&nbsp;等数据库。\n主要使用&nbsp;Flask、Codeigniter、CakePHP&nbsp;等语言开发框架。最后将你写好的简历不断的修改和完善，直到自己满意，然后将简历投递给心仪的公司吧。",
    "postDate": "2019-01-30T23:40:45.3383938+08:00",
    "email": "admin@masuit.com",
    "label": "职场,互联网",
    "keyword": null,
    "id": 168,
    "indexId": "Post:168"
  },
  {
    "title": "Ableton Live Suite 10 中文版 10.0.3 破解版",
    "author": "懒得勤快",
    "content": "Ableton Live 10 中文破解版是一款全套完整版的音乐制作软件，它功能强大内容丰富可允许用户以自然的方式作曲、录音、remix(重混音), 完美的创作和编辑自己的音乐，小编给大家带来的这款软件极其的实用. 它使用户可以把全部精力集中到真正该关注的东西，第七小编在这里重点推荐！软件新功能1、用新设备创建满足波形，回声，鼓车和脚踏：新的设备，意味着五颜六色的新声音是可能与现场的仪器和效果。2、留在流动中你会发现生活的改进可以帮助你在创作过程的每一个阶段都保持在流动中，不管你是在整理你的想法，组织你的设置，还是编辑你的音乐细节。3、从推来做更多Live10带来了新的功能和新的高分辨率可视化。现在你花在电脑上的时间更少了-不管你是在创作思想，编辑MIDI，还是塑造和混合声音。4、新声音图书馆随着新的收藏包，Live10有更多的声音，准备完成音乐，就在盒子里。它们是为调整你的需求或采取不同的方向而设置的。此外，库已经被重组，以使它更容易找到你想要的东西。5、最大的生活-无限制，内置于MAX技术现在完全集成到Live10Suite中。不需要额外的下载或设置来创建和自定义MAX for Live设备。他们只是在工作。此外，新的设备和功能为音乐家和设备开发人员带来了更多的可能性。软件特色一、用新设备创建满足波形，回声，鼓车和脚踏：新的设备，意味着五颜六色的新声音是可能与现场的仪器和效果。1、可波立即可播放，无限能力，波形是一个新的合成器，由阿伯尔顿。形状，伸展和形状的声音使用来自模拟合成，以及一系列其他仪器和声音的波形。立即开始雕刻声音-即使没有对合成的深入了解-或者通过直观的界面探索其丰富的调色板和潜力。2、回波Echo将经典的模拟和数字硬件延迟的声音集中在一个设备上-您的新入门延迟。驱动和形状的声音，它的模拟模型滤波器，打开噪音和摆动的老式缺陷，或添加调制和混响，以创造弥漫的声音风景，哀号反馈等。3、鼓车鼓巴斯是一个一站式的鼓工作站，能够添加微妙的字符或弯曲和打破鼓到你的意志。增加温暖和扭曲驱动器和紧缩，采取控制动态与压缩和瞬态成形，拨号和调音繁荣和控制低音衰减专用低端部分。4、踏板与单独的电路级模型的过度驱动，失真和毛茸茸的吉他踏板，佩达尔带来了模拟绊脚盒的特点，以生活。它的效果从微妙到鲁莽-它擅长于热身的声音和其他乐器，驱动合成声音或完全击打鼓。当然，这和吉他一起听起来很棒。二、留在流动中你会发现生活的改进可以帮助你在创作过程的每一个阶段都保持在流动中，不管你是在整理你的想法，组织你的设置，还是编辑你的音乐细节。1、捕获MIDI把你最自发的想法变成音乐，而不考虑录音。唱首歌？手挽着一条中间的曲目就行了。当一个想法出现的时候，在你播放它之后按下捕获MIDI。生活将与你的节奏和时机相匹配，并在一个完美的循环开始你的旋律或凹槽。你也可以使用这个功能来改进你的歌曲：添加新的部分或在现有的剪辑中添加过多的MIDI而不会打断你的流-在你正确播放完之后，只需按Capture MIDI就可以了。2、编辑多个MIDI剪辑创造鼓和低音，或和弦和旋律的串联。工作与多个MIDI剪辑跨多个轨道在一个单一的视图-在会议和安排。现在，你可以编辑更聪明，并采取更好的控制音乐关系在你的歌曲。3、创造和安排得更流畅排列视图已经被优化为快速的创造性编辑和更有效的歌曲创作。轻松伸展剪辑，滑动其内容或创建音频衰减与新的剪辑互动，直接工作在安排。自动化与更大的控制使用网格快照和其他改进的断点交互。立即将注意力集中在你需要的快速键盘快捷键上：切换所有曲目的自动可见性，放大歌曲的选择，轻推剪辑，甚至进行音频编辑，如倒车样例。4、大量的工作流细化当涉及到创造性的流动，有时小的事情是最大的改变。“生活10号”提供了一长串它们-以下就是其中的几个。①浏览器集合将你的进入设备，插件和样本放在手边：创建颜色编码的集合，并在浏览器中立即访问它们。②便条追逐音符现在触发，即使回放开始在中间，所以你不需要启动剪辑从一开始听到一个长垫，例如。③I/O重命名立即通过标记Live的输入和输出来选择正确的路由，以匹配您工作室中的仪器和硬件。④混合改进随着它的增益范围的改善，您可以更有效地使用实用的音量自动化，保持混频器自由。在实用和EQ 8的扩展10赫兹低频范围内的Bass Mono功能为您提供更精确的低音控制。分离式立体声混频器现在允许灵活地放置单独的通道在立体声空间。⑤在组内创建组以更大的灵活性-处理单个组元素、子组或整个总线。而且管理集更容易；即使有大量的曲目和详细的安排，您也可以使用多个级别的组快速折叠轨道，以进行简单的概述。⑥精致的外观和感觉Ableton Live的界面已经被更新，变得更干净和更清晰，更清晰的图形和精致的颜色。一系列优化的主题提高了所有环境中的可见性。系统要求OS X 10.11.6或更高版本Intel Core™2双处理器(建议采用Intel Core™i5处理器或更快的处理器)4 GB RAM(推荐8GB或更多)1280x800显示分辨率建议采用符合核心音频的音频接口用于程序安装的USB端口(USB2.0或更高版本)访问用于授权Live的互联网连接(对于下载附加内容和更新Live，建议使用快速互联网连接)系统驱动器上大约3GB的磁盘空间用于基本安装(建议使用8GB的空闲磁盘空间)多达76 GB的磁盘空间，用于额外可用的声音内容安装教程1、下载完成后，断网安装Ableton Live Suite 10。2、安装完成后，打开Live 10 Suite ，点击NO internet on this computer。3、找到Your hardware code，打开Live 10 Suite注册机。4、将Your hardware code输入到Live 10 Suite注册机中，然后点击Generate。5、跳出保存页面，自动默认保存位置为桌面，点击II(S)保存。6、把桌面上保存好的Ableton Live 10 Suite密钥拖动到软件中。7、Ableton Live Suite 10 破解完成。下载地址附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!链接: https://pan.baidu.com/s/1CfAGK9g6pPjNafzfuyIZGw&nbsp;提取码: 9l2a",
    "postDate": "2019-01-30T23:40:45.3384555+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "Ableton Live",
    "id": 1372,
    "indexId": "Post:1372"
  },
  {
    "title": "深入浅出依赖注入容器——Autofac",
    "author": "懒得勤快",
    "content": "1.写在前面相信大家对IOC和DI都耳熟能详，它们在项目里面带来的便利大家也都知道，微软新出的.NetCore也大量采用了这种手法。如今.NetCore也是大势所趋了，基本上以.Net为技术主导的公司都在向.NetCore转型了，我也一直在想抽时间写几篇.NetCore的文章，可无奈最近的项目实在太赶，也没时间写什么文章。但今天这篇文章不是专门讲.NetCore的。算了，废话不多说，开始今天的主题吧。本篇文章主要讲解Autofac的基本使用和高级用法，以及可能会踩到的一些坑。2.基本概念相信大家都知道IOC、DIP和DI是什么，用倒是网上抄点代码过来，项目就能跑起来了，但真要你讲出个花样，估计还是有点悬吧，这也是找工作面试时候经常被问起的。控制反转　谁控制谁?IoC/DI容器控制应用主程序。　控制什么?IoC/DI容器控制对象本身的创建、实例化;控制对象之间的依赖关系。　何谓反转(对应于正向)?因为现在应用程序不能主动去创建对象了，而是被动等待对象容器给它注入它所需要的资源，所以称之为反转。　哪些方面反转了?&nbsp;&nbsp;&nbsp;&nbsp;1.创建对象&nbsp;&nbsp;&nbsp;&nbsp;2.程序获取资源的方式反了　为何需要反转?&nbsp;&nbsp;&nbsp;&nbsp;1.引入IoC/DI容器过后,体系更为松散，而且管理和维护以及项目升级更有序;&nbsp;&nbsp;&nbsp;&nbsp;2.类之间真正实现了解耦依赖　什么是依赖(按名称理解、按动词理解)?依赖(按名称理解):依赖关系;依赖(按动词理解):依赖的动作　谁依赖于谁?应用程序依赖于IoC/DI容器　为什么需要依赖?因为发生了反转，应用程序依赖的资源都是IoC/DI容器里面　依赖什么东西?应用程序依赖于IoC/DI容器为它注入所需要的资源。（比如：依赖关系）注入　谁注入于谁?IoC/DI容器注入于应用程序。　注入什么东西?注入应用程序需要的对象，比如依赖关系。　为何要注入?因为程序要正常运行需要访问这些对象。IOC(控制反转Inversion of Control)控制反转(Inversion of Control)就是使用对象容器反过来控制应用程序所需要的外部资源，这样的一种程序开发思想，调用者不再创建被调用者的实例，由IOC框架实现（容器创建）所以称为控制反转；创建对象和对象非托管资源的释放都由外部容器去完成，实现项目层与层之间的解耦的一种设计思想。DI(依赖注入)和DIP(依赖倒置原则)相信很多人还分不清楚DI和DIP这两个词，甚至认为它们就是同一个词。依赖倒置原则（Dependency Inversion Principle）为我们提供了降低模块间耦合度的一种思路，而依赖注入（Dependency Injection）是一种具体的实施方法，容器创建好实例后再注入调用者称为依赖注入，就是应用程序依赖IOC容器来注入所需要的外部资源，这样一种程序的开发思想。能做什么(What)？松散耦合对象，解耦项目架构层。怎么做(How)？使用Autofac/Unity/Spring等框架类库，里面有实现好了的IoC/DI容器。用在什么地方(Where)？凡是程序里面需要使用外部资源的情况，比如创建对象，都可以考虑使用IoC/DI容器。DI和IOC是同一概念吗?肯定不是同一概念啊，但它们两个描述的是同一件事件，从不同的角度来说:IOC是从对象容器的角度；DI是从应用程序的角度。控制反转的描述：对象容器反过来控制应用程序，控制应用程序锁所需要的一些对象，比如DbContext。依赖注入的描述：应用程序依赖对象容器，依赖它注入所需要的外部资源。对IoC的理解：a. 应用程序无需主动new对象，而是描述对象应该如何被创建(构造方法、属性、方法参数等)。b. 应用程序不需要主动装配对象之间的依赖关系,而是描述需要哪个服务，IoC容器会帮你装配，被动接受装配。c. 主动变被动，是一种让服务消费者不直接依赖于服务提供者的组件设计方式，是一种减少类与类之间依赖的设计原则。3.Autofac/Unity简介Autofac是.NET领域最为流行的IOC框架之一，传说是速度最快的一个，而今微软也很青睐的一个轻量高效的IOC框架，简单易上手且让人着迷；Unity是微软官方出品的IOC框架，用法和Autofac大致差不多。4.基本使用通过nuget引入autofac；准备几个实例对象：public&nbsp;class&nbsp;Doge\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;SayHello()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;我是小狗，汪汪汪~&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\npublic&nbsp;class&nbsp;Person\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;Age&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n}我们传统的做法当然是直接new啦，但现在有了IOC容器，怎么还能那样做呢！接下来准备IOC容器，通过IOC容器来实例化对象；var&nbsp;builder&nbsp;=&nbsp;new&nbsp;ContainerBuilder();//准备容器\nbuilder.RegisterType&lt;Doge&gt;();//注册对象\nvar&nbsp;container&nbsp;=&nbsp;builder.Build();//创建容器完毕\nvar&nbsp;dog&nbsp;=&nbsp;container.Resolve&lt;Doge&gt;();//通过IOC容器创建对象\ndog.SayHello();还可以直接实例注入：builder.RegisterInstance(new&nbsp;Doge());//实例注入单例托管：builder.RegisterInstance(Singleton.GetInstance()).ExternallyOwned();//将单例对象托管到IOC容器还可以Lambda表达式注入：builder.Register(c&nbsp;=&gt;&nbsp;new&nbsp;Person()&nbsp;{&nbsp;Name&nbsp;=&nbsp;&quot;张三&quot;,&nbsp;Age&nbsp;=&nbsp;20&nbsp;});//Lambda表达式创建\nPerson&nbsp;p&nbsp;=&nbsp;container.Resolve&lt;Person&gt;();还可以注入泛型类：builder.RegisterGeneric(typeof(List&lt;&gt;));\nList&lt;string&gt;&nbsp;list&nbsp;=&nbsp;container.Resolve&lt;List&lt;string&gt;&gt;();你却说搞这么多过场，就为了创建一个对象？！咱不着急，接下来的才是重头戏5.以接口方式注入接着刚才的例子，添加个接口IAnimal，让Doge来实现它；public&nbsp;interface&nbsp;IAnimal\n{\n&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;SayHello();\n}\npublic&nbsp;class&nbsp;Doge&nbsp;:&nbsp;IAnimal\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;SayHello()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;我是小狗，汪汪汪~&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\npublic&nbsp;class&nbsp;Cat&nbsp;:&nbsp;IAnimal\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;SayHello()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;我是小猫，喵喵喵~&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\npublic&nbsp;class&nbsp;Pig&nbsp;:&nbsp;IAnimal\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;SayHello()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;我是小猪，呼呼呼~&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}然后IOC注册对象的方式改变为：var&nbsp;builder&nbsp;=&nbsp;new&nbsp;ContainerBuilder();//准备容器\nbuilder.RegisterType&lt;Doge&gt;().As&lt;IAnimal&gt;();//映射对象\nvar&nbsp;container&nbsp;=&nbsp;builder.Build();//创建容器完毕\nvar&nbsp;dog&nbsp;=&nbsp;container.Resolve&lt;IAnimal&gt;();//通过IOC容器创建对象\ndog.SayHello();如果一个类型被多次注册,以最后注册的为准。通过使用PreserveExistingDefaults() 修饰符，可以指定某个注册为非默认值。builder.RegisterType&lt;Doge&gt;().As&lt;IAnimal&gt;();//映射对象\nbuilder.RegisterType&lt;Cat&gt;().As&lt;IAnimal&gt;().PreserveExistingDefaults();//指定Cat为非默认值\n\nvar&nbsp;dog&nbsp;=&nbsp;container.Resolve&lt;IAnimal&gt;();//通过IOC容器创建对象\ndog.SayHello();如果一个接口类被多个实例对象实现，可以进行命名，注入的时候使用名字进行区分builder.RegisterType&lt;Doge&gt;().Named&lt;IAnimal&gt;(&quot;doge&quot;);//映射对象\nbuilder.RegisterType&lt;Pig&gt;().Named&lt;IAnimal&gt;(&quot;pig&quot;);//映射对象\n\nvar&nbsp;dog&nbsp;=&nbsp;container.ResolveNamed&lt;IAnimal&gt;(&quot;pig&quot;);//通过IOC容器创建对象\ndog.SayHello();ResolveNamed()只是Resolve()的简单重载，指定名字的服务其实是指定键的服务的简单版本。有Named的方式很方便，但是只支持字符串，但有时候我们可能需要通过其他类型作键，比如枚举。先声明一个枚举类：public&nbsp;enum&nbsp;AnumalType\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Doge,&nbsp;Pig,&nbsp;Cat\n}然后将上面的代码改造成：builder.RegisterType&lt;Doge&gt;().Keyed&lt;IAnimal&gt;(AnumalType.Doge);//映射对象\nbuilder.RegisterType&lt;Pig&gt;().Keyed&lt;IAnimal&gt;(AnumalType.Pig);//映射对象\n\nvar&nbsp;dog&nbsp;=&nbsp;container.ResolveKeyed&lt;IAnimal&gt;(AnumalType.Cat);//通过IOC容器创建对象\ndog.SayHello();不过这种方式是不推荐使用的，因为autofac容器会被当作Service Locator使用，推荐的做法是通过索引类型来实现，Autofac.Features.Indexed.IIndex&lt;K,V&gt;是Autofac自动实现的一个关联类型。使用IIndex&lt;K,V&gt;作为参数的构造函数从基于键的服务中选择需要的实现：var&nbsp;animal&nbsp;=&nbsp;container.Resolve&lt;IIndex&lt;AnumalType,IAnimal&gt;&gt;();\nvar&nbsp;cat&nbsp;=&nbsp;animal[AnumalType.Cat];\ncat.SayHello();IIndex中第一个泛型参数要跟注册时一致，在例子中是AnimalType枚举。其他两种注册方法没有这样的索引查找功能，这也是为什么设计者推荐Keyed注册的原因之一。6.自动装配从容器中的可用对象中选择一个构造方法来创建对象，这个过程叫做自动装配。它是通过反射实现的，所以实际上容器创造对象的行为比较适合用在配置环境中。改造Person类：public&nbsp;class&nbsp;Person\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Person()&nbsp;{&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Person(string&nbsp;name)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;=&nbsp;name;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Person(string&nbsp;name,&nbsp;int&nbsp;age)&nbsp;:&nbsp;this(name)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Age&nbsp;=&nbsp;age;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;Age&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n}注入时指定构造函数Autofac默认从容器中选择参数最多的构造函数。如果想要选择一个不同的构造函数，就需要在注册的时候就指定它：builder.RegisterType&lt;Person&gt;().UsingConstructor(typeof(string));这种写法将指定调用Person(string)构造函数，如该构造函数不存在则报错。额外的构造函数参数：　　有两种方式可以添加额外的构造函数参数，在注册的时候和在检索的时候。在使用自动装配实例的时候这两种都会用到。　　注册时添加参数，使用WithParameters()方法在每一次创建对象的时候将组件和参数关联起来。List&lt;NamedParameter&gt;&nbsp;pars&nbsp;=&nbsp;new&nbsp;List&lt;NamedParameter&gt;()&nbsp;{&nbsp;new&nbsp;NamedParameter(&quot;Age&quot;,&nbsp;20),&nbsp;new&nbsp;NamedParameter(&quot;Name&quot;,&nbsp;&quot;张三&quot;)&nbsp;};\nbuilder.RegisterType&lt;Person&gt;().WithParameters(pars);　　在检索阶段添加参数：　　在Resolve()的时候提供的参数会覆盖所有名字相同的参数，在注册阶段提供的参数会覆盖容器中所有可能的服务。7.MVC控制器和WebAPI控制器注入当然是web MVC项目了，要在MVC或WebApi项目中用autofac，当然需要以下nuget包了，准备几个Repository和Service；public&nbsp;class&nbsp;Person\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;Id&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;Age&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n}\npublic&nbsp;interface&nbsp;IRepository\n{\n&nbsp;&nbsp;&nbsp;&nbsp;List&lt;Person&gt;&nbsp;GetPersons();\n}\npublic&nbsp;class&nbsp;RepositoryBase&nbsp;:&nbsp;IRepository\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;List&lt;Person&gt;&nbsp;Persons&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}&nbsp;=&nbsp;new&nbsp;List&lt;Person&gt;();\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;RepositoryBase()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i++)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Persons.Add(new&nbsp;Person()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Id&nbsp;=&nbsp;i&nbsp;+&nbsp;1,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;=&nbsp;&quot;张三&quot;&nbsp;+&nbsp;i,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Age&nbsp;=&nbsp;10&nbsp;+&nbsp;i&nbsp;*&nbsp;2\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;List&lt;Person&gt;&nbsp;GetPersons()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Persons;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\npublic&nbsp;class&nbsp;PersonRepository&nbsp;:&nbsp;RepositoryBase\n{\n}\npublic&nbsp;interface&nbsp;IService\n{\n&nbsp;&nbsp;&nbsp;&nbsp;List&lt;Person&gt;&nbsp;GetPersons();\n}\npublic&nbsp;class&nbsp;ServiceBase&nbsp;:&nbsp;IService\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;IRepository&nbsp;Repository&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ServiceBase(IRepository&nbsp;repository)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Repository&nbsp;=&nbsp;repository;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;List&lt;Person&gt;&nbsp;GetPersons()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Repository.GetPersons();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\npublic&nbsp;class&nbsp;PersonService&nbsp;:&nbsp;ServiceBase\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;PersonService(IRepository&nbsp;repository)&nbsp;:&nbsp;base(repository)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}网站启动时注册容器,在Global的Application_Start方法中注册IOC容器；//注册IOC容器\nvar&nbsp;builder&nbsp;=&nbsp;new&nbsp;ContainerBuilder();\n//告诉autofac将来要创建的控制器类存放在哪个程序集\nbuilder.RegisterControllers(Assembly.GetExecutingAssembly());//注册MVC控制器\nbuilder.RegisterApiControllers(Assembly.GetExecutingAssembly());//注册WebAPI控制器\n//注册Repository和Service\nbuilder.RegisterType&lt;PersonRepository&gt;().As&lt;IRepository&gt;().InstancePerDependency();\nbuilder.RegisterType&lt;PersonService&gt;().As&lt;IService&gt;().InstancePerDependency();\nvar&nbsp;container&nbsp;=&nbsp;builder.Build();\n//将当前容器交给MVC底层，保证容器不被销毁，控制器由autofac来创建\nGlobalConfiguration.Configuration.DependencyResolver&nbsp;=&nbsp;new&nbsp;AutofacWebApiDependencyResolver(container);//先给WebAPI注册\nDependencyResolver.SetResolver(new&nbsp;AutofacDependencyResolver(container));//再给MVC注册InstancePerDependency：为你注入的这个服务的生命周期.(注:生命周期我们后面讲)现在就可以在控制器中通过构造函数注入对象了public&nbsp;class&nbsp;HomeController&nbsp;:&nbsp;Controller\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;IService&nbsp;Service&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;HomeController(IService&nbsp;service)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Service&nbsp;=&nbsp;service;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;GET:&nbsp;Home\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ActionResult&nbsp;Index()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;ps&nbsp;=&nbsp;Service.GetPersons();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Json(ps,&nbsp;JsonRequestBehavior.AllowGet);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}8.属性注入有时候我们需要对对象的属性进行注入，比如EF上下文对象DbContext，很简单，两句话搞定；我们先来模拟一个DbContext：public&nbsp;class&nbsp;DataContext\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ICollection&lt;Person&gt;&nbsp;Persons&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}&nbsp;=&nbsp;new&nbsp;List&lt;Person&gt;();\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;DataContext()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i++)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Persons.Add(new&nbsp;Person()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Id&nbsp;=&nbsp;i&nbsp;+&nbsp;1,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;=&nbsp;&quot;张三&quot;&nbsp;+&nbsp;i,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Age&nbsp;=&nbsp;10&nbsp;+&nbsp;i&nbsp;*&nbsp;2\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}在IOC容器中注入；//注册IOC容器\nvar&nbsp;builder&nbsp;=&nbsp;new&nbsp;ContainerBuilder();\n//告诉autofac将来要创建的控制器类存放在哪个程序集\nbuilder.RegisterControllers(Assembly.GetExecutingAssembly()).PropertiesAutowired(PropertyWiringOptions.AllowCircularDependencies).InstancePerDependency();//注册MVC控制器\nbuilder.RegisterApiControllers(Assembly.GetExecutingAssembly()).PropertiesAutowired(PropertyWiringOptions.AllowCircularDependencies).InstancePerDependency();//注册WebAPI控制器\nbuilder.RegisterFilterProvider();//特性注入\nbuilder.RegisterType&lt;DataContext&gt;().InstancePerRequest();\n//注册Repository和Service\nbuilder.RegisterType&lt;PersonRepository&gt;().As&lt;IRepository&gt;().PropertiesAutowired(PropertyWiringOptions.AllowCircularDependencies).InstancePerDependency();\nbuilder.RegisterType&lt;PersonService&gt;().As&lt;IService&gt;().PropertiesAutowired(PropertyWiringOptions.AllowCircularDependencies).InstancePerDependency();\nvar&nbsp;container&nbsp;=&nbsp;builder.Build();\n//将当前容器交给MVC底层，保证容器不被销毁，控制器由autofac来创建\nGlobalConfiguration.Configuration.DependencyResolver&nbsp;=&nbsp;new&nbsp;AutofacWebApiDependencyResolver(container);//先给WebAPI注册\nDependencyResolver.SetResolver(new&nbsp;AutofacDependencyResolver(container));//再给MVC注册PropertiesAutowired(PropertyWiringOptions.AllowCircularDependencies)表示属性注入，当实例对象存在有被IOC容器对象托管的时候，IOC容器会自动给属性实例化，Controller则可以不通过构造函数注入，直接属性注入；public&nbsp;class&nbsp;HomeController&nbsp;:&nbsp;Controller\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;DataContext&nbsp;DataContext&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ActionResult&nbsp;GetPersons()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Json(DataContext.Persons,&nbsp;JsonRequestBehavior.AllowGet);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}关于参数PropertyWiringOptions的三个选项：PropertyWiringOptions.None：默认的注入方式，当发现注入的对象有属性依赖的时候，会注入一个新的对象；PropertyWiringOptions.AllowCircularDependencies：循环依赖注入方式，当发现注入的对象有循环依赖关系的时候，会循环注入；PropertyWiringOptions.PreserveSetValues：保留预设值注入，当注入时发现属性已经有初始值，会自动忽略。同样，我们也可以改造刚才的Repository，通过属性注入DataContext；public&nbsp;class&nbsp;RepositoryBase&nbsp;:&nbsp;IRepository\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;DataContext&nbsp;DataContext&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;List&lt;Person&gt;&nbsp;GetPersons()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;DataContext.Persons.ToList();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}上面是自动注入属性，有时候我们还可以手动去注入属性：builder.RegisterType&lt;Person&gt;().OnActivated(e&nbsp;=&gt;&nbsp;e.Instance.Name&nbsp;=&nbsp;&quot;李四&quot;);如果你预先知道属性的名字和值，你还可以使用：builder.RegisterType&lt;Person&gt;().WithProperty(&quot;Name&quot;,&nbsp;&quot;李四&quot;);9.方法注入可以实现方法注入的方式有两种。1、使用Activator如果你使用委托来激活，只要调用这个方法在激活中:builder.Register(c&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;result&nbsp;=&nbsp;new&nbsp;Person();\n&nbsp;&nbsp;&nbsp;&nbsp;result.SayHello(&quot;my&nbsp;name&nbsp;is&nbsp;van&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;\n});注意，使用这种方法，Person类里必须要有这个方法：public&nbsp;void&nbsp;SayHello(string&nbsp;hello)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(hello);\n}2、使用Activating Handler如果你使用另外一种激活，比如反射激活，创建激活的事件接口OnActivating，这种方式仅需一行代码：builder.RegisterType&lt;Person&gt;().OnActivating(e&nbsp;=&gt;&nbsp;e.Instance.SayHello(&quot;my&nbsp;name&nbsp;is&nbsp;van!&quot;));10. Attribute注入有时候我们还需要注入一些Attribute特性，在使用MVC的时候,肯定会用到特性，比如ActionFilter，肯定会有一些自己定义的特性，我们想在里面做一些逻辑操作，比如用户登录状态检查，我们就需要在ActionFilter里面实例化Service对象，那么这些特性里面要用到相关的服务,该怎么注入呢？很简单，我们只需要在IOC容器构建时再加上builder.RegisterFilterProvider()即可；//注册IOC容器\nvar&nbsp;builder&nbsp;=&nbsp;new&nbsp;ContainerBuilder();\n//告诉autofac将来要创建的控制器类存放在哪个程序集\nbuilder.RegisterControllers(Assembly.GetExecutingAssembly());//注册MVC控制器\nbuilder.RegisterApiControllers(Assembly.GetExecutingAssembly());//注册WebAPI控制器\nbuilder.RegisterFilterProvider();//特性注入\n//注册Repository和Service\nbuilder.RegisterType&lt;PersonRepository&gt;().As&lt;IRepository&gt;().InstancePerDependency();\nbuilder.RegisterType&lt;PersonService&gt;().As&lt;IService&gt;().InstancePerDependency();\nvar&nbsp;container&nbsp;=&nbsp;builder.Build();\n//将当前容器交给MVC底层，保证容器不被销毁，控制器由autofac来创建\nGlobalConfiguration.Configuration.DependencyResolver&nbsp;=&nbsp;new&nbsp;AutofacWebApiDependencyResolver(container);//先给WebAPI注册\nDependencyResolver.SetResolver(new&nbsp;AutofacDependencyResolver(container));//再给MVC注册然后就可以直接通过属性的方式注入到ActionFilter中，是的，你没看错，就只需要这一行代码就可以了，特性里面就可以取到想要的服务了；public&nbsp;class&nbsp;MyActionFilterAttribute&nbsp;:&nbsp;ActionFilterAttribute\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;IService&nbsp;Service&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;在执行操作方法之前由&nbsp;ASP.NET&nbsp;MVC&nbsp;框架调用。&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;param&nbsp;name=&quot;filterContext&quot;&gt;筛选器上下文。&lt;/param&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;override&nbsp;void&nbsp;OnActionExecuting(ActionExecutingContext&nbsp;filterContext)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;ps&nbsp;=&nbsp;Service.GetPersons();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;base.OnActionExecuting(filterContext);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}11.Hangfire注入如果我们项目中还用到了hangfire这样的分布式任务调度框架，我们也可以通过autofac来进行对象的依赖注入；首先我们引入hangfire的一些基础包，并配置好hangfire；当然，还要引入hangfire的autofac支持库：Startup.cs类：public&nbsp;class&nbsp;Startup\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Configuration(IAppBuilder&nbsp;app)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//配置任务持久化到内存\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GlobalConfiguration.Configuration.UseMemoryStorage();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//启用dashboard\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;app.UseHangfireServer(new&nbsp;BackgroundJobServerOptions&nbsp;{&nbsp;WorkerCount&nbsp;=&nbsp;10&nbsp;});\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;app.UseHangfireDashboard(&quot;/taskcenter&quot;,&nbsp;new&nbsp;DashboardOptions()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Authorization&nbsp;=&nbsp;new[]&nbsp;{&nbsp;new&nbsp;MyRestrictiveAuthorizationFilter()&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;//注册dashboard的路由地址\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\npublic&nbsp;class&nbsp;MyRestrictiveAuthorizationFilter&nbsp;:&nbsp;IDashboardAuthorizationFilter\n{\n&nbsp;&nbsp;&nbsp;&nbsp;//public&nbsp;RedisHelper&nbsp;RedisHelper&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}&nbsp;=&nbsp;new&nbsp;RedisHelper();\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;bool&nbsp;Authorize(DashboardContext&nbsp;context)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}Global.Application_Start():Hangfire.GlobalConfiguration.Configuration.UseMemoryStorage();\nHangfire.GlobalConfiguration.Configuration.UseAutofacActivator(container);&nbsp;//注册IOC容器\nServer&nbsp;=&nbsp;new&nbsp;BackgroundJobServer(new&nbsp;BackgroundJobServerOptions\n{\n&nbsp;&nbsp;&nbsp;&nbsp;ServerName&nbsp;=&nbsp;$&quot;{Environment.MachineName}&quot;,&nbsp;//服务器名称\n&nbsp;&nbsp;&nbsp;&nbsp;SchedulePollingInterval&nbsp;=&nbsp;TimeSpan.FromSeconds(1),\n&nbsp;&nbsp;&nbsp;&nbsp;ServerCheckInterval&nbsp;=&nbsp;TimeSpan.FromSeconds(1),\n&nbsp;&nbsp;&nbsp;&nbsp;WorkerCount&nbsp;=&nbsp;Environment.ProcessorCount&nbsp;*&nbsp;2,\n});配置hangfire后台任务；public&nbsp;interface&nbsp;IHangfireBackJob\n{\n&nbsp;&nbsp;&nbsp;&nbsp;DataContext&nbsp;DataContext&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;UpdatePersons();\n}\npublic&nbsp;class&nbsp;HangfireBackJob&nbsp;:&nbsp;IHangfireBackJob\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;DataContext&nbsp;DataContext&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;UpdatePersons()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataContext.Persons.Clear();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i++)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataContext.Persons.Add(new&nbsp;Person()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;=&nbsp;&quot;李四&quot;&nbsp;+&nbsp;i,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Age&nbsp;=&nbsp;20&nbsp;+&nbsp;i&nbsp;*&nbsp;2,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Id&nbsp;=&nbsp;i&nbsp;+&nbsp;1\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}配置IOC容器：builder.RegisterType&lt;DataContext&gt;().InstancePerBackgroundJob(MatchingScopeLifetimeTags.RequestLifetimeScopeTag,&nbsp;AutofacJobActivator.LifetimeScopeTag);&nbsp;//指定生命周期为每个后台任务依赖，并且每次http请求内单例\nbuilder.RegisterType&lt;BackgroundJobClient&gt;().SingleInstance();//指定生命周期为单例\nbuilder.RegisterType&lt;HangfireBackJob&gt;().As&lt;IHangfireBackJob&gt;().PropertiesAutowired(PropertyWiringOptions.AllowCircularDependencies).InstancePerDependency();创建任务：public&nbsp;ActionResult&nbsp;CreateJob()\n{\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;type&nbsp;=&nbsp;typeof(IHangfireBackJob);\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;job&nbsp;=&nbsp;new&nbsp;Job(type,&nbsp;type.GetMethod(&quot;UpdatePersons&quot;));\n&nbsp;&nbsp;&nbsp;&nbsp;BackgroundJobClient.Create(job,&nbsp;new&nbsp;EnqueuedState());\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Content(&quot;ok&quot;);\n}12. SignalR注入如果我们项目中还用到了SignalR这样的socket通信框架，我们也可以通过autofac来进行对象的依赖注入；按照刚才hangfire的套路，我们先引入SignalR的一些基础包，并配置好SignalR；当然，还要引入SignalR的autofac支持库：注册容器的方式和上面的例子都有些不同了，SignalR的IOC容器注入必须在Startup里面注入，不能在Global中注入，因为SignalR是Owin项目，OWIN 集成常见错误为使用GlobalHost。OWIN中配置你会抓狂. OWIN集成中，任何地方你都不能引用 。当年博主我也不太清楚，反正当时也踩了这一大坑。至于hangfire也是owin项目，为什么可以在Global里面注入，因为hangfire不是用GlobalHost去注入的，而是GlobalConfiguration。public&nbsp;class&nbsp;Startup\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Configuration(IAppBuilder&nbsp;app)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;builder&nbsp;=&nbsp;new&nbsp;ContainerBuilder();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;config&nbsp;=&nbsp;new&nbsp;HubConfiguration();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.RegisterHubs(Assembly.GetExecutingAssembly()).PropertiesAutowired(PropertyWiringOptions.AllowCircularDependencies);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.RegisterType&lt;DataContext&gt;().InstancePerLifetimeScope();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;container&nbsp;=&nbsp;builder.Build();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;config.Resolver&nbsp;=&nbsp;new&nbsp;AutofacDependencyResolver(container);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;app.UseAutofacMiddleware(container);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;app.MapSignalR(&quot;/signalr&quot;,&nbsp;config);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}然后，hub就可以用属性注入，构造函数注入等方式了；[HubName(&quot;myhub&quot;)]//声明hub的显式名字\npublic&nbsp;class&nbsp;MyHub&nbsp;:&nbsp;Hub\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;DataContext&nbsp;DataContext&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Send()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clients.All.hello(DataContext.Persons.ToJsonString());\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}前端代码：&lt;!DOCTYPE&nbsp;html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta&nbsp;name=&quot;viewport&quot;&nbsp;content=&quot;width=device-width&quot;&nbsp;/&gt;\n&lt;title&gt;WebSocket&lt;/title&gt;\n&lt;script&nbsp;src=&quot;~/Scripts/jquery-3.3.1.js&quot;&gt;&lt;/script&gt;\n&lt;script&nbsp;src=&quot;~/Scripts/jquery.signalR-2.2.3.js&quot;&gt;&lt;/script&gt;\n&lt;script&nbsp;src=&quot;~/signalr/hubs&quot;&gt;&lt;/script&gt;&lt;!--后端SignalR根据注册的路由生成的js脚本--&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;span&nbsp;class=&quot;msg&quot;&gt;&lt;/span&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n&lt;script&gt;\n$(function&nbsp;()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;//客户端都以驼峰命名法使用\n&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;hubProxy&nbsp;=&nbsp;$.connection[&quot;myhub&quot;];&nbsp;//hub代理对象\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;$msg&nbsp;=&nbsp;$(&quot;.msg&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;//注册客户端方法\n&nbsp;&nbsp;&nbsp;&nbsp;hubProxy.client.hello&nbsp;=&nbsp;function&nbsp;(msg)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$msg.text(msg);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;//向服务端发数据\n&nbsp;&nbsp;&nbsp;&nbsp;$.connection.hub.start().done(function&nbsp;()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hubProxy.server.send();\n&nbsp;&nbsp;&nbsp;&nbsp;});\n});\n&lt;/script&gt;注意：由于 SignalR 是内部构件，所以不支持SignalR每请求的生命周期依赖。13. 注册程序集然而大多数时候我们的项目很多代码是直接用代码生成器生成的，像Repository和Service并非完全手写的，并不想这么一个一个类的去builder.RegisterType，那多麻烦啊，所以autofac还提供了程序集批量注入的选项；一句话搞定：builder.RegisterAssemblyTypes(Assembly.GetExecutingAssembly()).Where(t&nbsp;=&gt;&nbsp;t.Name.EndsWith(&quot;Repository&quot;)&nbsp;||&nbsp;t.Name.EndsWith(&quot;Service&quot;)).AsSelf().AsImplementedInterfaces().PropertiesAutowired(PropertyWiringOptions.PreserveSetValues).InstancePerDependency();这里真的只有一句话！14. Resolve的参数当注册或者检索component的时候可以使用参数。1、传递参数给ResolveResolve接受可变参数或IEnumerable&lt;T&gt;传入多个值：Person&nbsp;p&nbsp;=&nbsp;container.Resolve&lt;Person&gt;(new&nbsp;NamedParameter(&quot;name&quot;,&nbsp;&quot;王五&quot;),&nbsp;new&nbsp;NamedParameter(&quot;age&quot;,&nbsp;22));Person下必须添加如下构造函数：public&nbsp;Person(string&nbsp;name,&nbsp;int&nbsp;age)&nbsp;:&nbsp;this(name)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;=&nbsp;name;\n&nbsp;&nbsp;&nbsp;&nbsp;Age&nbsp;=&nbsp;age;\n}2、可用的参数类型　　Autofac提供几种不同的参数对应策略：NamedParameter&nbsp;：像上面那样对应的参数名字\nTypedParameter：对应到参数的类型（必须是具体的类型）\nResolvedParameter：灵活的参数匹配\nNamedParameter&nbsp;和TypedParameter：只能提供常量参数3、从表达式中使用参数如果使用表达式注册的方式，可以使用第二个可用的委托参数来获得参数。builder.Register((c,&nbsp;p)&nbsp;=&gt;&nbsp;new&nbsp;Person(p.Named&lt;string&gt;(&quot;name&quot;),&nbsp;p.Named&lt;int&gt;(&quot;age&quot;)));\nPerson&nbsp;pp&nbsp;=&nbsp;container.Resolve&lt;Person&gt;(new&nbsp;NamedParameter(&quot;name&quot;,&nbsp;&quot;王五&quot;),&nbsp;new&nbsp;NamedParameter(&quot;age&quot;,&nbsp;22));15. 对象生命周期InstancePerDependency对每一个依赖或每一次调用创建一个新的唯一的实例。也称作瞬态或者工厂，使用PerDependency作用域，服务对于每次请求都会返回互补影响实例。在没有指定其他参数的情况下，这也是默认的创建实例的方式。官方文档解释：Configure the component so that every dependent component or call to Resolve() gets a new, unique instance (default.)InstancePerLifetimeScope在一个生命周期域中，每一个依赖或调用创建一个单一的共享的实例，且每一个不同的生命周期域，实例是唯一的，不共享的，也就是线程内唯一对象。官方文档解释：Configure the component so that every dependent component or call to Resolve() within a single ILifetimeScope gets the same, shared instance. Dependent components in different lifetime scopes will get different instances.InstancePerMatchingLifetimeScope在一个做标识的生命周期域中，每一个依赖或调用创建一个单一的共享的实例。打了标识了的生命周期域中的子标识域中可以共享父级域中的实例。若在整个继承层次中没有找到打标识的生命周期域，则会抛出异常：DependencyResolutionException。官方文档解释：Configure the component so that every dependent component or call to Resolve() within a ILifetimeScope tagged with any of the provided tags value gets the same, shared instance. Dependent components in lifetime scopes that are children of the tagged scope will share the parent&#39;s instance. If no appropriately tagged scope can be found in the hierarchy an DependencyResolutionException is thrown.InstancePerOwned在一个生命周期域中所拥有的实例创建的生命周期中，每一个依赖组件或调用Resolve()方法创建一个单一的共享的实例，并且子生命周期域共享父生命周期域中的实例。若在继承层级中没有发现合适的拥有子实例的生命周期域，则抛出异常：DependencyResolutionException。官方文档解释：Configure the component so that every dependent component or call to Resolve() within a ILifetimeScope created by an owned instance gets the same, shared instance. Dependent components in lifetime scopes that are children of the owned instance scope will share the parent&#39;s instance. If no appropriate owned instance scope can be found in the hierarchy an DependencyResolutionException is thrown.SingleInstance每一次依赖组件或调用Resolve()方法都会得到一个相同的共享的实例。其实就是单例模式。官方文档解释：Configure the component so that every dependent component or call to Resolve() gets the same, shared instance.InstancePerRequest在一次Http请求上下文中,共享一个组件实例。仅适用于asp.net mvc开发。16. 需要Dispose的对象的注入像RedisClient、DbContext这类对象需要用完之后被Dispose的，也很简单；改造成可Dispose的DataContext：public&nbsp;class&nbsp;DataContext&nbsp;:&nbsp;IDisposable\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ICollection&lt;Person&gt;&nbsp;Persons&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}&nbsp;=&nbsp;new&nbsp;List&lt;Person&gt;();\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;DataContext()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i++)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Persons.Add(new&nbsp;Person()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Id&nbsp;=&nbsp;i&nbsp;+&nbsp;1,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;=&nbsp;&quot;张三&quot;&nbsp;+&nbsp;i,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Age&nbsp;=&nbsp;10&nbsp;+&nbsp;i&nbsp;*&nbsp;2\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;执行与释放或重置非托管资源关联的应用程序定义的任务。&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Dispose()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Persons&nbsp;=&nbsp;null;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}然后在创建IOC容器的时候：builder.RegisterType&lt;DataContext&gt;().OnRelease(db&nbsp;=&gt;&nbsp;db.Dispose());给对象注册OnRelease事件，每次使用完的时候会由IOC容器去释放。17.绑定事件在对象生命周期的不同阶段使用事件。Autofac暴露五个事件接口供实例的按如下顺序调用1)OnRegistered\n2)OnPreparing\n3)OnActivated\n4)OnActivating\n5)OnRelease　　这些事件会在注册的时候被订阅，或者被附加到IComponentRegistration 的时候。builder.RegisterType&lt;Person&gt;().OnRegistered(e&nbsp;=&gt;&nbsp;Console.WriteLine(&quot;在注册的时候调用!&quot;)).OnPreparing(e&nbsp;=&gt;&nbsp;Console.WriteLine(&quot;在准备创建的时候调用!&quot;)).OnActivating(e&nbsp;=&gt;&nbsp;Console.WriteLine(&quot;在创建之前调用!&quot;)).OnActivated(e&nbsp;=&gt;&nbsp;Console.WriteLine(&quot;创建之后调用!&quot;)).OnRelease(e&nbsp;=&gt;&nbsp;Console.WriteLine(&quot;在释放占用的资源之前调用!&quot;));　　以上示例输出如下：　　　　OnActivating　　组件被创建之前调用，在这里你可以：1)将实例转向另外一个或者使用代理封装它\n2)进行属性注入\n3)执行其他初始化工作　　OnActivated　　在component被完全创建的时候调用一次。在这个时候你可以执行程序级别的一些工作（这些工作依赖于对象被完全创建）-这种情况很罕见。　　OnRelease　　替代component的标准清理方法。实现了IDisposable 接口的标准清理方法（没有标记为ExternallyOwned） 通过调用Dispose 方法。没有实现IDisposable或者被标记为ExternallyOwned的清理方法是一个空函数-不执行任何操作。OnRelease 就是用来覆盖默认的清理行为的。18. .NetCore中使用Autofac在 Starpup 中 配置 Autofac，注意的是要将 ConfigureServices 的返回类型从void类型 改成IServiceProvider，并 return new AutofacServiceProvider(ApplicationContainer); 官方解释是，让第三方容器接管Core的默认DI。public&nbsp;IServiceProvider&nbsp;ConfigureServices(IServiceCollection&nbsp;services)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;services.AddMvc();\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;builder&nbsp;=&nbsp;new&nbsp;ContainerBuilder();\n&nbsp;&nbsp;&nbsp;&nbsp;builder.RegisterType&lt;DataContext&gt;().InstancePerLifetimeScope();\n&nbsp;&nbsp;&nbsp;&nbsp;builder.RegisterAssemblyTypes(Assembly.GetExecutingAssembly()).Where(t&nbsp;=&gt;&nbsp;t.Name.EndsWith(&quot;Repository&quot;)&nbsp;||&nbsp;t.Name.EndsWith(&quot;Service&quot;)).AsSelf().AsImplementedInterfaces().PropertiesAutowired(PropertyWiringOptions.PreserveSetValues).InstancePerDependency();\n&nbsp;&nbsp;&nbsp;&nbsp;builder.Populate(services);\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;container&nbsp;=&nbsp;builder.Build();\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;AutofacServiceProvider(container);\n}源码下载：http://masuit.com/download?path=/file/AutofacDemo.7z",
    "postDate": "2019-01-30T23:40:45.3385164+08:00",
    "email": "admin@masuit.com",
    "label": ".NET,C#,依赖注入",
    "keyword": null,
    "id": 1192,
    "indexId": "Post:1192"
  },
  {
    "title": "PDF Expert for Mac破解版 v2.4.13直装破解教程 免序列号激活",
    "author": "Mannix",
    "content": "从 1 到 2，只是数字世界最微不足道的量变，但 PDF Expert Mac 版的从 1 到 2，则完成了从「PDF 阅读器」到「PDF 编辑器」的质变。不想只当个好读者，更试着做个好编辑Readdle 旗下的软件界面都以高度简洁、寸土寸金著称，而在本次 2.0 版本的更新中，PDF Expert 不仅把新人手册的最显著位置给了「编辑」功能，更是在最显眼的标题栏上永久放置了「编辑」模式按钮，与阅读时最常用的「批注」并列，这一切都在反复强调 2.0 版本作为编辑器的存在感。进入编辑模式之后，PDF Expert 会动态识别并标记出全部可以编辑的页面元素，鼠标划过时会动态出现一个框选，表示此处可编辑，双击即可进行调整。在文字模式下，PDF Expert 可以快速对字体、字号、颜色和对齐方式进行修改，对于填写表格等内容非常实用。得益于精确的文字区域识别，新增的隐藏功能给了用户一个隐藏个人信息的功能，可以通过用黑色覆盖或者白色擦除两种模式隐匿掉敏感内容。在图片模式下，PDF Expert 提供了非常罕见的所见即所得展示，关于图片的伸缩、替换、插入、旋转等都能非常神速的完成。结合苹果的 Handoff 功能，在同一 Wi-Fi 下的 iOS 设备可以直接看到 PDF 在 Mac 上的实时编辑效果，也让 Mac 版上的编辑功能提升了实用价值。不过作为新功能，在试用的 3 天时间的过程中，我也在通过 PDF Expert 进行文档编辑时遇到了一些问题：1. 虽然软件对中文提供了良好支持，但是在某些文字编辑过一次之后，再次编辑时仍然会出现乱码。2. 虽然软件可以识别各种字体，但对于定制化字体仍然在修改之后会变形，如下图，航空公司的付款证明在修改之后变成了系统原生字体。3. 软件不带有 OCR 功能，对于扫描版 PDF 中的文字无能为力。4. 还有有一点需要注意，一旦编辑过 PDF，无论以何种方式退出 PDF Expert，软件都不会提示另存为文档，也就是说你的全部修改也是「所见即所得」的，所有的修改都会在退出之后被保存。所以一定谨慎，对于失误修改要及时通过 Command＋Z 恢复，以免造成不必要的损失。为了稳妥起见，也可以在关闭 PDF Expert 之前单独关闭每个 PDF 文件。编辑，不仅局限在页面之间如果说单独编辑模式还只是局限在某一个页面之间的话，大纲编辑和页面管理的加入则让 PDF Expert 的能力发挥到章节之间甚至是文件之间。大纲模式对于学生撰写论文，以及企业归档重要文件的价值都很高，PDF Expert 2 除了支持插入和创建大纲之外，还能对现有大纲进行重命名、重定向等修订，如果你在企业中维护一个反复更新版本的 PDF，你应该能体会到这个功能的价值所在。同时软件还加入了对文件合并的支持，可以快速合并多个文件，并对合并后的各个页面进行删除、排序、旋转等。下载地址：附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!磁力下载：magnet:?xt=urn:btih:71F8463B8CEF3AA6E260D76BC3DA4FB675A19A28gitlab下载：稀缺资源统一下载地址页",
    "postDate": "2019-01-30T23:40:45.3385778+08:00",
    "email": "794450497@qq.com",
    "label": null,
    "keyword": "pdf",
    "id": 1365,
    "indexId": "Post:1365"
  },
  {
    "title": "jdk 10.0.2绿色免环境变量精简版",
    "author": "懒得勤快",
    "content": "JDK（Java Development Kit）是整个Java的核心，包括了Java运行环境、Java工具和Java基础类库。JDK作为JAVA开发的环境，运行JAVA程序不可缺少的环境，不管是做JAVA开发还是做安卓开发，都必须在电脑上安装JDK。小到小型设备，大到智慧城市，Java的贡献力量是其他任何技术都无可比拟的。Java 8 已经出来三年多的时间了，原本计划2016年七月份release Java 9，但是基于种种原因，Java 9 被推迟到了2017年的3月份，本人也在Open JDK的官网上看到了Java 10的标准也在制定当中，Java的发展真的越来越快了，在Java 9正式发布之前，我们可以使用它的SNAPSHOT版本，先来体验一下Java 9 有哪些新的特性，下面的清单来自于官方文档，看着似乎很多，但是真正具有颠覆意义的其实就是Module System，其余很多主要是一些新的feature增加，还有一些功能的加强，在本篇文章中，我们将介绍一下主要的几个，不会一一去说，资料也不多，所以我想说也没的说，另外Java 8 是我认为迄今为止Java 最大的一次变化，不光是特性的增加，更多的是编程风格的转变，如果你还没有掌握Java 8，建议你赶紧学一下java8的一些新特性吧。以下是java9 所带来的新特性1. Modular System – Jigsaw Project&nbsp;该特性是Java 9 最大的一个特性，Java 9起初的代号就叫Jigsaw，最近被更改为Modularity，Modularity提供了类似于OSGI框架的功能，模块之间存在相互的依赖关系，可以导出一个公共的API，并且隐藏实现的细节，Java提供该功能的主要的动机在于，减少内存的开销，我们大家都知道，在JVM启动的时候，至少会有30～60MB的内存加载，主要原因是JVM需要加载rt.jar，不管其中的类是否被classloader加载，第一步整个jar都会被JVM加载到内存当中去，模块化可以根据模块的需要加载程序运行需要的class，那么JVM是如何知道需要加载那些class的呢？这就是在Java 9 中引入的一个新的文件module.java我们大致来看一下一个例子（module-info.java）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modulecom.baeldung.java9.modules.car{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requirescom.baeldung.java9.modules.engines;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exportscom.baeldung.java9.modules.car.handling;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}关于更多Java 9 模块编程的内容请参考一本书：《Java 9 Modularity》里面讲的比较详细，介绍了当前Java对jar之间以来的管理是多么的混乱，引入modularity之后的改变会是很明显的差别。2. 全新的HttpClient就目前而言，JDK提供的Http访问功能，几乎都需要依赖于HttpURLConnection，但是这个类大家在写代码的时候很少使用，我们一般都会选择Apache的Http Client，此次在Java 9的版本中引入了一个新的package:java.net.http，里面提供了对Http访问很好的支持，不仅支持Http1.1而且还支持HTTP2，以及WebSocket，据说性能可以超过Apache HttpClient，Netty，Jetty，简单的来看一个代码片段URIhttpURI=newURI(&quot;http://www.masuit.com&quot;);\nHttpRequestrequest=HttpRequest.create(httpURI).GET();\nHttpResponseresponse=request.response();\nStringresponseBody=response.body(HttpResponse.asString());3. Process API Enhance在Java很早的版本中，提供了Process这样的API可以获得进程的一些信息，包括runtime，甚至是用它来执行当前主机的一些命令，但是请大家思考一个问题，你如何获得你当前Java运行程序的PID？很显然通过Process是无法获得的，需要借助于JMX才能得到，但是在这一次的增强中，你将会很轻松的得到这样的信息，我们来看一个简单的例子ProcessHandleself=ProcessHandle.current();\nlongPID=self.getPid();\nProcessHandle.InfoprocInfo=self.info();\nOptional&lt;String[]&gt;args=procInfo.arguments();\nOptional&lt;String&gt;cmd=procInfo.commandLine();\nOptional&lt;Instant&gt;startTime=procInfo.startInstant();\nOptional&lt;Duration&gt;cpuUsage=procInfo.totalCpuDuration();上面有大量的Optional，这是Java 8中的API，同样在Java 9中对其进行了增强，本人在Java 8实战视频中对Optional API进行了源码级别的剖析，感兴趣的一定要去看看。已经获取到了JVM的进程，我们该如何将该进程优雅的停掉呢？下面的代码给出了答案childProc=ProcessHandle.current().children();\nchildProc.forEach(procHandle-&gt;{\nassertTrue(&quot;Couldnotkillprocess&quot;+procHandle.getPid(),procHandle.destroy());\n});通过上面的一小段代码，我们也发现了Java 9对断言机制同样增加了一些增强，多说一些题外话，我们目前的系统中运行一个严重依赖于Hive beelineServer的程序，beeline server不是很稳定，经常出现卡顿，甚至假死，假死后也不回复的问题，这样就导致我们的程序也会出现卡顿，如果运维人员不对其进行清理，系统运行几个月之后会发现很多僵尸进程，于是增加一个获取当前JVM PID的功能，然后判断到超过给定的时间对其进行主动杀死，完全是程序内部的行为，但是获取PID就必须借助于JMX的动作，另外杀死它也必须借助于操作系统的命令，诸如kill这样的命令，显得非常的麻烦，但是Java 9的方式明显要优雅方便许多。4. Try-With-Resources的改变我们都知道，Try-With-Resources是从JDK 7 中引入的一项重要特征，只要接口继承了Closable就可以使用Try-With-Resources，减少finally语句块的编写，在Java 9 中会更加的方便这一特征MyAutoCloseablemac=newMyAutoCloseable();\ntry(mac){\n//dosomestuffwithmac\n}\ntry(newMyAutoCloseable(){}.finalWrapper.finalCloseable){\n//dosomestuffwithfinalCloseable\n}catch(Exceptionex){}我们的Closeable完全不用写在try（）中。5. Diamond Operator ExtensionFooClass&lt;Integer&gt;fc=newFooClass&lt;&gt;(1){//anonymousinnerclass\n};\nFooClass&lt;?extendsInteger&gt;fc0=newFooClass&lt;&gt;(1){\n//anonymousinnerclass\n};\nFooClass&lt;?&gt;fc1=newFooClass&lt;&gt;(1){//anonymousinnerclass\n};6.Interface 也可以有私有方法了interface&nbsp;InterfaceWithPrivateMethods{\nprivate&nbsp;static&nbsp;StringstaticPrivate(){\nreturn&quot;staticprivate&quot;;\n}\nprivate&nbsp;String&nbsp;instancePrivate(){\nreturn&quot;instanceprivate&quot;;\n}\ndefault&nbsp;void&nbsp;check(){\nStringresult=staticPrivate();\nInterfaceWithPrivateMethodspvt=new&nbsp;InterfaceWithPrivateMethods(){\n//anonymousclass\n};\nresult=pvt.instancePrivate();\n}\n}}该特性完全是为了Java 8中default方法和static方法服务的。7.JShell Command Line Tool在Java 8 出来的时候，很多人都喊着，这是要抢夺Scala等基于JVM动态语言的市场啊，其中有人给出了一个Java做不到的方向，那就是Scala可以当作脚本语言，Java可以么？很明显在此之前Java不行，ta也不具备动态性，但是此次Java 9 却让Java也可以像脚本语言一样来运行了，主要得益于JShell，我们来看一下这个演示jdk-9\\bin&gt;jshell.exe\n|WelcometoJShell--Version9\n|Foranintroductiontype:/helpintro\njshell&gt;&quot;Thisismylongstring.Iwantapartofit&quot;.substring(8,19);\n$5==&gt;&quot;mylongstring&quot;这是我们在Jshell这个控制台下运行，我们如何运行脚本文件呢？jshell&gt;/savec:\\develop\\JShell_hello_world.txt\njshell&gt;/openc:\\develop\\JShell_hello_world.txt\nHelloJShell!8.JCMD Sub-Commands记得在Java 8中，放弃了Jhat这个命令，但是很快在Java 9中增加了一些新的命令，比如我们要介绍到的jcmd,借助它你可以很好的看到类之间的依赖关系jdk-9\\bin&gt;jcmd14056VM.class_hierarchy-i-sjava.net.Socket\n14056:\njava.lang.Object/null\n|--java.net.Socket/null\n|implementsjava.io.Closeable/null(declaredintf)\n|implementsjava.lang.AutoCloseable/null(inheritedintf)\n||--org.eclipse.ecf.internal.provider.filetransfer.httpclient4.CloseMonitoringSocket\n||implementsjava.lang.AutoCloseable/null(inheritedintf)\n||implementsjava.io.Closeable/null(inheritedintf)\n||--javax.net.ssl.SSLSocket/null\n||implementsjava.lang.AutoCloseable/null(inheritedintf)\n||implementsjava.io.Closeable/null(inheritedintf)9.Мulti-Resolution Image API接口java.awt.image.MultiResolutionImage封装了一系列的不同分辨率图像到一个单独对象的API，我么可以根据给定的DPI 矩阵获取resolution-specific，看一下下面的代码片段BufferedImage[]resolutionVariants=....\nMultiResolutionImagebmrImage\n=new&nbsp;BaseMultiResolutionImage(baseIndex,resolutionVariants);\nImagetestRVImage=bmrImage.getResolutionVariant(16,16);\nassertSame(&quot;Imagesshouldbethesame&quot;,testRVImage,resolutionVariants[3]);关于AWT的东西，本人几乎不怎么接触，如果有用到的朋友，等JDK 9出来之后，自己体会使用一下吧。10.Variable Handles很早之前就传言Java 会将unsafe这一个类屏蔽掉，不给大家使用，这次看他的官方文档，貌似所有已sun开头的包都将不能在application中使用，但是java 9 提供了新的API供大家使用。在JDK 9中提供了一个新的包，叫做java.lang.invoke里面有一系列很重要的类比如VarHandler和MethodHandles，提供了类似于原子操作以及Unsafe操作的功能。11.Publish-Subscribe Framework在新版的JDK 9 中提供了消息发布订阅的框架，该框架主要是由Flow这个类提供的，他同样会在java.util.concurrent中出现，并且提供了Reactive编程模式。12.Unified JVM Logging该特性为JVM的所有组件引入了一个通用的日志系统，提供了JVM日志的基础设施，你可以不用专门为了打印某些日志而添加一些专门的标签，只需要使用统一的log指令即可，比如：java-Xlog:gc=debug:file=gc.txt:none...\njcmd9615VM.logoutput=gc_logswhat=gc13.Immutable Set其实在Java的早期版本中就已经有这样的功能了，比如Collections.xxx就可以将某个collection封装成不可变，但是此次的Java 9版本将其加到了对应的Set和List中，并且有一个专门的新包用来存放这些具体的实现java.util.ImmutableCollections，这一个特性和Scala真的如出一辙。Set&lt;String&gt;strKeySet=Set.of(&quot;key1&quot;,&quot;key2&quot;,&quot;key3&quot;);14. Optional To Stream对Option提供了stream功能，关于Optional的用法，我在我的教程中讲的非常详细，如果你还没有掌握，抓紧啊List&lt;String&gt;filteredList=listOfOptionals.stream()\n.flatMap(Optional::stream)\n.collect(Collectors.toList());15. 其他大致的特性我就介绍这么多，你也可以到openJDK官网下载snapshot版本的java 9 来玩一下，当然还有其他很多功能我就不一一介绍了，这里只是大概的提一下轻量级的json文本处理api移除很多已经被过期的GCC回收器（是移除哦，因为在Jdk 8 中只是加了过期的标记）使用G1垃圾回收器作为默认的垃圾回收器HTML5风格的java docjava doc只是智能搜索功能javascript的引擎得到了进一步的升级引入了SHA-3的hash算法下载地址：https://pan.baidu.com/s/19ONvTI7vt_6pCiej1rfqcA",
    "postDate": "2019-01-30T23:40:45.3386393+08:00",
    "email": "admin@masuit.com",
    "label": "java",
    "keyword": "java,jdk,sdk,java10",
    "id": 57,
    "indexId": "Post:57"
  },
  {
    "title": "比几何画板更强大的——几何图霸4.5破解版",
    "author": "懒得勤快",
    "content": "以前大家都在求几何画板，今天给大家找来了一款更强大的几何工具。几何图霸4.5是一款三维动态图形软件，是一款功能强大的几何图形绘制工具，使用能够伴奏用户快速绘制动态几何图形，可自由拖动绘制的对象并保持几何关系不变，包括各种常见的图元类型，可从多种角度观察形体，从而寻找它的规律，非常直观、自然，适合教师教学、制作课件、研究问题等使用，让学生了解的更加透彻，培养想象能力，领悟几何真谛。立体几何高级画板，教师上课得力助手，学生学习良师益友，数学探索工具平台。《几何图霸》是三维动态图形软件，立体几何高级画板。它界面友好、操作方便、图形美观、虚实自然、文件小巧、功能强大。它是教师上课得力助手，学生学习良师益友，数学探索工具平台。博主今天带来的是几何图霸4.5中文破解最新版安装包，内含破解补丁文件，可以完美激活几何图霸！软件特色1、图元类型丰富点线面圆、柱锥台球、曲线曲面、轨迹踪迹、组件模型、课件打包，一应俱全。图元选取方法多样，属性修改方便，帮助系统完备，易学易用。2、图形直观性强可以把被遮挡的线自动显示为虚线，可以运用多种投影方式显示，可以多视图显示，可以对几何模型添加材质贴图、灯光效果。显示精美，自然逼真。3、变换方式多样它类似于几何画板，具有动态变换功能，自由拖动对象仍能保持几何关系不变。它既可以从多种角度观察形体，进行视变换；还可以对图形进行旋转、平移、缩放等点变换。在变化中寻求不变的规律。4、计算快捷准确它具有强大的度量、计算功能。可以进行表达式求值，可以迅速判断点线面位置关系，可以动态度量坐标、长度、角度、面积、体积等。它能根据度量结果绘制点、实施变换。这种形与数的转化功能为数学学习和研究构建了极好的平台。5、图文功能强大可以粘贴图片、WORD文本，编辑数学公式、3D文字，导入幻灯片，插入表格。文本清晰，表格雅致，图文并茂，缩放自如。6、应用范围广泛它不仅可用于立体几何教学，也可用于平面几何、解析几何、三角、数列、函数、概率、算法等教学中。教师可用之制作课件、研究问题，在上课时进行示范；学生可用之画图计算、验证探究，培养想象能力，领悟几何真谛。功能介绍1、选择“点、线、点”可以度量二面角依次选择点A、线段BC、点D，【度量】-【角】-【二面角】。选择两个面也可以度量二面角，但要注意两个面的方向。右手螺旋确定面的正向，两个法向所成角与二面角平面角互补。2、【度量】选项卡中增加了【比】命令按钮选中共线的三点A、B、C，度量它们定义的比AC：AB的值，同向为正，反向为负。（当三点不共线时与【点在线上的值】相同）；或选中两条线段，度量它们的长度比。3、【度量】选项卡中增加了【斜率】命令按钮选中一条二维（两点的竖坐标z值相同）的直线或线段、射线、向量，度量它的斜率。4、可以构造直线和球交点选择直线和球，【构造】-【交点】，或直接用【点】工具构造。如下图中的P,Q就是圆柱的母线与球的交点。5、赋值和取值可以对1000多个内置变量执行，新增set(n,x)函数内存变量数由原来的6个增为1024个，编号从0到1023。类似于高级语言中的数组。set(n,x)表示把值x赋给n号变量，get(n)表示把n号变量的值取出。6、累加函数 accum(n,x) 合并了“读取，相加及赋值”三个函数功能accum(n)表示把n号变量的值加1；accum(n,x)表示把n号变量的值加x，“和”仍然保存在n号变量中。图霸中显示时用m[k]表示k号变量，不直接用变量名，相当于用身份证号表示某人。其中“←”表示赋值， 显示的更易读。例：新建参数s，选中它，分别加入四个计算，如上图左。拖动参数的滑块，各个函数依次分别执行求值，显示效果与输入的不一样，更直观，如上图右。思考一下，通过上述计算后，第20号变量中当前值是多少？（20）7、新增循环函数for()，增强对内置变量的处理能力下图是用伪代码表示的算法：有四个部分组成：1. 变量赋初始值 2. 循环条件 3. 循环体，4. 输出值打开图霸的计算器，输入（可以复制粘贴）：for((set(1,1),set(2,0)),get(1)&lt;=100,(accum(2,get(1)),accum(1)),get(2))上面的数学格式显示为：for((m[1]←1, m[2]←0), m[1]≤100, (m[2]+←m[1], m[1]+←1), m[2])确定后可以看到表达式及输出结果。for()函数类似的也有四个部分组成：用1号和2号变量表示i和s，set(1,1)表示i=1，set(2,0)表示s=0.两句之间用逗号分隔，每一部分是一个整体，多个语句时外加小括号，即(set(1,1)，set(2,0)).注意输入的不能是中文的逗号与括号。循环条件是i≤100，在图霸中要先取出1号变量值再用逻辑运算：get(1)&lt;=100. 小于或等于用两个符号。不能用中文的“≤“。循环体也有两句构成，之间用逗号分隔，外加小括号：(accum(2,get(1)),accum(1))。accum()是累加函数。前一个把2号变量的值加上1号变量的值再赋给2号变量，即s←s+i；后一句将1号变量的值加1（加数为1时省略），即i←i+1。(accum(2,get(1))显示为：m[2]+←m[1]输出变量s的值，用get(2). 你要输出多个变量值，可以用含参数的语句：如get(t). 拖动滑块t即可显示各个值，迭代时可以看到列表。循环中还可以再用循环，即循环的嵌套。复杂的表达式在”记事本“中编辑好，粘贴到输入区。每个循环要确保能正常退出，循环条件不能永远为真，否则进入死循环，可以在循环体中修改循环变量的值。当然，程序为了防止初学者出现错误，加上了循环次数的限制，每个循环不超过100万次。选择表达式，【修改标签】，点选【自定义标签】，如图。按【编辑】按钮，在&quot;数学格式文本编辑&quot;框中可以对刚才的显示文本进行编辑，确定后保存。8、功能合一的”视变换“按钮改变当前的视点视角，用此命令可以记住当前状态。以后你平移、旋转、缩放视图，只要点此按钮，将会切换回刚才设置时的视状态。它是以前的三个视变换按钮的综合，但起始状态是随时变化的当前状态。选择视变换按钮，用属性命令修改标签，动画时间。9、增加“动画编排”功能，方便用“翻页笔”控制动画按钮。依次选择各个操作按钮，用【编辑】-【动画放映】-【动画编排】命令，这些按钮将加入到当前页的动画序列中。再选择一些按钮，用此命令会添加到刚才添加的序列的后面。如果不选择按钮，用此命令将清除当前页的动画序列。要组织一个比较好的演示序列，请在图形区对按钮排序，然后用此命令。发现错误时清空序列，重新添加。如果当前页的【动画编排】工具高亮显示，表示当前页设置有动画序列。用“翻页键”或“上下方向键”可以依次控制按钮的运行，没有序列或到序列首尾，再次翻页，将“切换页”。用向上翻页表示回放刚才一个按钮动画。进入每一页时，序列自动从头开始，图霸的动画从前向后是有序的，不建议经常从后向前演示。如果你的翻页键不能切换页，请在“自定义快捷访问工具栏&quot;中，全部重置所有快捷键命令。10、可以为计算式添加先于它生成的参数或值作为父对象先选择一个计算式，再选择先于它生成的参数或度量值，用【属性】命令，添加参数或值作为计算式的父对象，在“计算器”对话框的数值列表中可以对它进行引用。11、修改插入的”二维坐标轴“组件属性。选择2维轴，在其属性中可以选择分别”隐藏x轴或y轴上刻度及标签“。全隐轴及标签，可以仅显示坐标网格。【个性设置】中改字体大小，部分刻度值会遮住轴线，这时拖动刻度值，适当移动，可以调整位置。12、支持透明纹理，更换了部分纹理图片。你可以为1-3号纹理图更换其它的图片。4-16号图用”jpg&quot;或“png&quot;格式。当选用”png“时支持含透明层的32位图。添加一个二面角，为两个半平面添加纹理。更换纹理为蝴蝶图，”透明“，显示如下（图片用蝴蝶一半，png格式，32位色，含透明层，看示例文件）：13、乘方运算的底数是负数时，根据指数化为近似分数后，分子与分母的奇偶性确定是否有意义。从而方便地绘制常见幂函数的图象。新建两个整数参数p、q，插入二维坐标系，构造曲线：x=t,y=t^(p/q),z=0.构造曲线上的点P，添加附点的文本.计算p,q的最大公约数，分别除p,q，得既约分数的分子与分母，分别组合到点P上。拖动它与文本间距，得到动态的函数解析式14、选择两点构造【球】时，不再添加大圆，直接”光照“实体显示选择点A，点B，用【球】工具添加球，选中球，【属性】中改使用纹理615、其它改进：（1）求余运算“%”的结果改为与除数同号（2）单位阶跃函数hv(x)定义改为x≥0时为1,其余为0（3）按钮循环执行的条件改为与逻辑运算一致，零为假，非零为真（4）在迭代中，选择迭代表也可以拖动，等同于拖动标签（5）【2D视图】、【3D视图】、【三视图】等工具在选中时高亮显示（6）【画笔】状态时，右击鼠标切换到箭头状态（7）【整编】完成后自动保存并打开，使各页内的图元序号连续。（8）个性设置中增加“保存设置”按钮，将当前设置保存到文件中，重启程序时自动使用。若未保存，设置只对文档中新建对象有效。破解教程1.安装官方版2.把loader.exe文件复制到原安装目录，并创建loader的快捷方式3.从loader启动应用。下载地址https://www.lanzous.com/i27pguf",
    "postDate": "2019-01-30T23:40:45.3387001+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "几何图霸,几何画板",
    "id": 1321,
    "indexId": "Post:1321"
  },
  {
    "title": "互联网架构之浅谈数据库用户表结构设计与第三方登录接入",
    "author": "懒得勤快",
    "content": "说起用户表，大概是每个应用/网站立项动工（码农们）考虑的第一件事情。用户表结构的设计，算是整个后台架构的基石。如果基石不稳，待到后面需求跟进了发现不能应付，回过头来反复修改用户表，要大大小小作改动的地方也不少。与其如此，不妨设计用户表之初就考虑可拓展性，争取不需要太多额外代价的情况下一步到位。先前设计：id\nusername\npassword用户名加上密码，解决简单需求，留个id作为其他表的外键。当然，那时候密码还可能是明文存储，好点的知道md5。后来呢，随着业务需求的拓展，要加个用户状态 status 判断用户是否被封禁，注册时间和注册IP地址、上次登录时间和IP地址备查（并衍生出登录记录表，用来判断是否异地登录等，在此不表），用户角色/权限 role （又衍生出用户角色权限关系，还是另文讨论），业务也需要个人的个人信息如真实姓名、地址等也一股脑往上添加，现在形成了一个很完整的用户关系表。　　id\n　　username\n　　password\n　　realname\n　　address\n　　…\n　　status\n　　role\n　　register_time\n　　register_ip\n　　login_time\n　　login_ip　　现在问题来了，进入Web2.0时代，微博开放了第三方网站登录，用微博帐号就能登录我们的网站，老板说，这个我们得要。加个微博用户登录表吧，当然，得和我们自己的用户表关联，这个微博用户信息表如下：　　id&nbsp;//自增ID\n　　user_id&nbsp;//关联本站用户ID\n　　uid&nbsp;//微博唯一ID\n　　access_token\n　　access_expire　　这还不算完，QQ又开放用户登录了，一下子要接入好多家第三方登录了，只能就着“微博用户信息表”继续加类型加判断，如果是每个第三方登录都新建一个表，肯定会疯的。　　时代变了，进入了移动互联网时代，怎么也得支持个手机号登录吧？所以现在每家标配都是：用户名/邮箱/手机号登录，外加一系列微博、微信等第三方登录。表结构如下：　　用户表：　　id\n　　username\n　　email\n　　phone\n　　…　　用户第三方登录表：　　id\n　　user_id\n　　app_type\n　　app_user_id\n　　access_token\n　　…　　用户在输入框输入用户名/邮箱/手机号和密码之后，后台判断是邮箱、手机号或是用户名，再根据条件查询是否为特定用户。这个表结构能够承载未来一段时间的业务需求了。如果说某天冒出了一个新的登录方式，比如身份证号登录，怎么办？继续在用户表加字段？我觉得有更好的选择。改进版：　　无论username+password，还是phone+password，都是一种用户信息+密码的验证形式；再来理解第三方登录，其实它也是用户信息+密码的形式，用户信息即第三方系统中的ID（第三方登录一定会给一个在他们系统中的唯一标识），密码即access_token，只不过是一种有使用时效定期修改的密码。所以我们把它抽象出了用户基础信息表加上用户授权信息表的形式。　　用户基础信息表 users：　　id\n　　nickname\n　　avatar　　用户授权信息表 user_auths：　　id\n　　user_id\n　　identity_type&nbsp;//登录类型（手机号&nbsp;邮箱&nbsp;用户名）或第三方应用名称（微信&nbsp;微博等）\n　　identifier&nbsp;//标识（手机号&nbsp;邮箱&nbsp;用户名或第三方应用的唯一标识）\n　　credential&nbsp;//密码凭证（站内的保存密码，站外的不保存或保存token）　　这个系统最大的特色就是，用户信息表不保存任何密码，不保存任何登录信息（如用户名、手机号、邮箱），只留有昵称、头像等基础信息。所有和授权相关（且基本前端展示无关的），都放在用户信息授权表，用户信息表和用户授权表是一对多的关系。说起来太抽象，show you the code.　　users　　|id|nickname|avatar|\n　　|1|慕容雪村|http://…/avatar.jpg|\n　　|2|魔力鸟|http://…/avatar2.jpg|\n　　|3|科比|http://…/avatar3.jpg|　　user_auths　　|id|user_id|identity_type|identifier|credential|\n　　|1|1|email|123@example.com|password_hash(密码)|\n　　|2|1|phone|13888888888|password_hash(密码)|\n　　|3|1|weibo|微博UID|微博access_token|\n　　|4|2|username|moliniao|password_hash(密码)|\n　　|5|3|weixin|微信UserName|微信token|　　说说具体处理，用户发来邮箱/用户名/手机号和密码请求登录的时候，依然是先判断类型，以某用户使用了手机号登录为例，使用 SELECT * FROM user_auths WHERE type=’phone’ and identifier=’手机号’ 查找条目，如有，取出并判断password_hash(密码)是否和该条目的credential相符，相符则通过验证，随后通过user_id获取用户信息。　　如果使用第三方登录，则只要判断 SELECT * FROM user_auths WHERE type=’weixin’ and identifier=’微信UserName’ ，如果有记录，则直接登录成功，使用新的token更新原token。假设与微信服务器通信不被劫持的情况下无需判断凭证问题。　　通过这个表结构设计，使许多原来纠结的问题瞬间解决，说说优点吧：　一，站内登录类型无限拓展，代码改动小。如果真要支持身份证登录了，只要少许几处改动，无需修改表结构。\n二，第三方登录类型可用工场模式批量拓展，新增第三方登录类型的开发成本降到最低。\n三，原来条件下，应用需要验证手机号是否已验证和邮箱是否已验证，需要相对应多一个字段如&nbsp;phone_verified&nbsp;和&nbsp;email_verified，如今只要在user_auths表中增加一个统一的verified字段，每种登录方式都可以直观看到是否已验证情况。基于信任第三方登录的数据准确性，默认第三方登录都是已验证。如果用户修改登录手机号或登录邮箱，也能清晰跟踪每一步的完成度。\n四，可按需绑定任意数量的同类型登录方式，即一个用户可以绑定多个微信，可以有多个邮箱，可以有多个手机号，是不是很赞？当然你也可以限制一种登录方式只有一条记录。\n五，在user_auths添加相应的时间和IP地址，就可以更加完整地跟踪用户的使用习惯，比如，已经不使用微博登录两年多，已经绑定微信300天\n六，即使完全使用第三方帐号登录，可在前端做到“无需注册本站帐号”的效果。过去许多网站虽然支持第三方帐号登录，但出于留存用户等原因，第一次微博登录回来，让你再填写一套他们网站的邮箱、密码等信息，也就失去了微博登录的最大意义。从技术上说，原有的结构导致除了在微博用户表建立一个条目外，必须在用户表建立一条对应的条目，而且一般情况下不能让用户表里的邮箱或者用户名和密码留空。用户体验好的，邮箱自动生成&nbsp;微博ID@id.weibo.sina.com，密码则随机生成。至于体验不好的，只能说早知道还不如不用微博登录呢！现在呢，我们的这个用户表结构则完全没有这样的困扰，只要微博提供的昵称和头像地址就可以生成这个用户，再关联他的微博登录记录。而且我们的表结构意味着，用户可以解除他的所有登录方式，于是这个账户变彻底变成了没法登录的僵尸（解决办法是在代码里加一个限制，至少保留一条user_auths的记录）。如果你非得得到用户的邮箱，那么每次登录的时候看到他不存在一条identify_type为email的记录，则弹窗弹死他，让他赶快填邮箱，否则啥都别干。\n七，提升了逻辑思维能力。抽象出事物本质是码农必备职业素养，通过对用户表结构的学习研究，提高了鄙人的各方面技能，从此写代码一路顺风顺水…\n八，如果你说邮箱和手机号就是用户信息的组成部分，他们依然需要体现在users表中作为前端展示？没问题，users表尽管拓展，users表里依然有email,phone，但他们仅仅作为“展示用途”，和昵称、头像、或者性别这些属性没有本质区别。在用户信息表与用户授权登录拆分后，用户信息表可以随时增加任意字段，加星座，加生日，都没问题，只需要在前端展示时多几个输入框，录入时多几行代码，与用户登录相关的问题做到最大程度解耦。有利必有弊，说说缺点：一，原先的用户判断由1次SQL变成2次SQL请求。\n二，用户同时存在邮箱、用户名、手机号等多种站内登录方式时，改密码时必须一起改，否则就变成了邮箱+新密码，手机号+旧密码访问了，肯定是很诡异的情况。如果考虑到这一点，又要在user_auths表中新增一个表示站内登录方式或第三方登录方式的标识字段。\n三，代码量增加了，有些情况下逻辑判断增加了，难度增大了。　　举个例子，无论用户是否已登录，无论用户是否已注册过，都是点击同一链接前往微博第三方授权后返回，可能出现几种情况：1，该微博在本站未注册过，很好，直接给他注册关联并登录；\n2，该微博已经在本站存在，当前用户未登录，直接登录成功；\n3，该微博未在本站注册，但当前用户已经登录并关联的是另一个微博帐号，作何处理取决于是否允许绑定多个微博帐号；\n4，该微博未在本站注册过，当前用户已登录，尝试进行绑定操作；\n5，该微博已经注册，用户又已使用该帐号登录，为何他重复绑定自己\n6，该微博已经在本站存在，但当前用户已经登录并关联的是另一个微博帐号，作何处理？切换用户或是报错？（画一个流程图能更好描述这个问题）这个问题与采用的数据结构没有关系，只是在做第三方帐号注册登录时遇到的各种情况，在此一并整理。",
    "postDate": "2019-01-30T23:40:45.3387618+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": null,
    "id": 114,
    "indexId": "Post:114"
  },
  {
    "title": "TeamViewer v13.2.26558 绿色破解版(去除商业限制)",
    "author": "懒得勤快",
    "content": "TeamViewer是一个能在任何防火墙和NAT代理的后台用于远程控制，桌面共享和文件传输的简单且快速的解决方案。为了连接到另一台计算机，只需要在两台计算机上同时运行 Team Viewer 即可，而不需要进行安装（也可以选择安装，安装后可以设置开机运行）。该软件第一次启动在两台计算机上自动生成伙伴 ID。只需要输入你的伙伴的ID到TeamViewer，然后就会立即建立起连接。软件特点1、可支援亲朋好友并存取无人看管的电脑（Windows、Mac、Linux）。2、使用多种触控方式轻松控制远端电脑，包括按鼠标左键、按鼠标右键、拖放、滚轮、缩放、变更屏幕大小等。3、完整的键盘控制，包括Ctrl、Alt、Windows?等特殊键。4、轻松使用防火墙和Proxy服务器存取电脑。5、远端重新开机。软件功能远程控制支持即时远程控制&nbsp;–&nbsp;客户端无需安装任何程序\n远程维护&nbsp;–&nbsp;全天候访问远程计算机和服务器\n远程访问&nbsp;–&nbsp;随时随地访问您的数据和应用\n家庭办公&nbsp;–&nbsp;在家也能访问办公室计算机会议演示在线会议&nbsp;–&nbsp;最多可容纳25名参加者\n演示&nbsp;–&nbsp;提升销售潜力\n培训会&nbsp;–&nbsp;实施在线培训，削减支出多连接与使用浏览器一样，在选项卡中打开多个远程会话。为了实现最佳浏览效果，您可分别在不同的选项卡中打开属于同一台远程计算机的所有监视器。只要远程计算机上出现新活动(例如，客户发来新聊天消息)，打开的标签就会始终闪烁，确保您不会错过任何事件。LAN唤醒您是否希望每周7天、每天24小时访问计算机，但又不希望计算机全天候运行？ 有了全新的LAN唤醒功能，您就可以在需要访问时远程唤醒您的计算机。唤醒功能通过本地网络中另一台使用TeamViewer的计算机或者路由器实现。双重验证如果您的密码意外落入他人之手，双重验证可防止您的TeamViewer帐户受到未经授权的访问。使用成熟的验证应用程序 (如Google Authenticator)，您可轻松地为您的智能手机生成安全代码。登录时需同时提供代码和密码。通过这项双重验证，TeamViewer将帮助您满足HIPAA、PCI DSS以及其他各方面的要求。支持Windows 8.1和Mac OS X Mavericks您或您的客户在使用Windows 8.1或Mac OS Mavericks？ 没问题。TeamViewer 9也针对这些操作系统进行了优化。客户模块您现在可以在Management Console中保存带有您公司标识的客户模块设置。(TeamViewer QuickSupport、QuickJoin或Host)。您或您的客户只需通过一个链接即可下载所创建的模块。破解说明by DeltaFoX/TeamURET(国外专注该软件破解的作者)—基于官方安装版绿化破解，启动即为企业许可证的特别版！（TeamViewer破解补丁由意大利大神DeltaFoX专注制作，可以选择破解为高级版、公司版、企业版，自动进入对应许可证通道，无免费版任何功能限制，无首次退出软件后订阅弹窗，无怀疑商业用途提示弹窗。）—绿色完整版支持无人值守访问、支持设置随机访问；支持VPN、远程打印、适用于Outlook的会议插件；—全部优化默认预配置：默认已关闭检测更新及不会接受新版推送、首次启动不会显示软件特性介绍弹窗；俄国大神破解版安装教程压缩包解压后，找到EXE文件，右键选择（以管理员身份运行）一路点击Next最后点击下Finish按钮就完成了。没有其繁琐的操作最好换一个其他的盘，和你之前的不一样就可以下面还有讲解，下拉注意上图这一步我建议除了最后一个全部选择安装才是完整版完整功能，安装完你的Windows菜单里面有个重置ID的脚本快捷键右键管理员运行，一定要重置ID.这是一种永久的方法， 出限制换一下ID即可。很简单。软件默认是英文，修改语言按照一下操作：按照英文依次点点点即可，&nbsp;必须要彻底重启TV软件才会生效，中文说明：选项-高级-显示高级选项-语言选择&quot;简体中文&quot;-确定-提示重启TeamViewer，应用新的显示语言。英文说明：Extras-Options-Advanced-Show advanced options-Display language项选择语言，重启软件即可应用新的显示语言；下载地址稀缺资源统一下载地址页附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!13.2版本不能更换ID，如需更换ID建议使用13.1版本。另外，13.2版本似乎不太稳定，推荐用13.1版本。",
    "postDate": "2019-01-30T23:40:45.3388229+08:00",
    "email": "admin@masuit.com",
    "label": "TeamViewer",
    "keyword": "TeamViewer破解版",
    "id": 118,
    "indexId": "Post:118"
  },
  {
    "title": "文件对比神器——Beyond Compare 4.2.7.23425绿色特别版+4.2.8.23479手动破解版",
    "author": "懒得勤快",
    "content": "最近博主看后台统计的时候发现，很多朋友都在搜索这软件，所以今天，博主就给你们找来了。Beyond Compare是一款不可多得的专业级的文件夹和文件对比工具，使用它可以很方便地对比出两个文件夹或者文件的不同之处，相差的每一个字节用颜色加以表示，查看方便，支持多种规则对比，使用Beyond Compare只需使用简单而强大的命令和操作，即可开启最优质的对比体验，找出您感兴趣的差异，合并变化，然后同步文件，并生成报告，用户可以从Windows、Mac OSX和Linux工作站直接访问FTP网站、媒体设备、WebDAV资源，SVN存储库和云存储，Beyond Compare包含多种数据类型的内置比较浏览器，除了文本之外，还可以进行表格、图片、二进制文件、注册表的比较。比较文件，文件夹、可以高效对比整个驱动器和文件夹，检查大小和修改时间；或者逐字节完整验证每个文件；无缝集成了FTP站点、云存储和压缩文件，强大的过滤功能允许您只看到的自己感兴趣的。Beyond Compare选择最好的方法来突出不同之处，文本文件可以用语法高亮和比较规则调整进行查看和编辑，以用于文档、源代码和HTML。Word文档、Adobe和pdf文件也可以进行比较但是不能编辑。数据文件、可执行和二进制文件以及图像文件都有专用的查看器。三种方式合并、Beyond Compare的合并浏览器支持将一个文件或文件夹的两个不同版本进行变更合并，生成一个输出。这种智能的方式允许在仔细检查冲突的时候能快速接受大部分变更。颜色编码和部分高亮显示允许您简单、快速地接受、拒绝以及合并变更。文件合并时可以使用内置的语法高亮显示编辑器改变输出文件的任意行。大部分版本控制系统都可直接使用Beyond Compare，当需要时它能提供给您强大的对比和合并支持。同步文件夹、Beyond Compare文件夹同步界面可以自动协调数据差异；有效地更新您的电脑，备份您的计算机或管理你的网站；可以使用相同的接口从磁盘、FTP服务器和压缩文件拷内容。可以很容易地过滤掉您不需要的内容，并且可以使用所有强大的比较技术，让备份又快又准，可以使用一个灵活的脚本语言自动执行重复性任务，且可以从命令行调用任何脚本，以使您在最方便的时候安排同步。多平台、Beyond Compare在Windows、Linux和OS X上都能使用。运行速度快，并且拥有一个本地界面。同时为了满足您完成任务的各种需求，还针对各种平台进行功能提升。ZIP、压缩文件和其他文档类型都可以内置扩展用于对比和更新它们的内容，和其他文件夹一样简单。支持处理多种流行格式，包括 tar、gzip、 bzip2、Microsoft CAB、WinRAR、以及新版的Windows v4 、Zipx、7-zip、IMG/ISO磁盘图像文件。FTP，SFTP，FTPS、您无需一个单独的FTP客户端来更新您的网站或者进行离线备份。Beyond Compare能连接到FTP、FTP 通过 SSL和 SFTP (SSH)服务器，比较、合并或者同步变更您使用过的相同的命令。它保存了配置文件以便快速访问，支持多个并发连接以实现提速。媒体设备、与其他驱动器一样，Beyond Compare可以插入您的相机、MP3播放器或者安卓手机并且立即访问它。同步您的音乐、复制您的照片，保存您的高分。版本控制、通过一个远程的存储库直接对比您的本地版本控制工作目录，无需第二次校验。支持多个分支和之前的版本，也使合并分支易如反掌。新版变化http://scootersoftware.com/download.php?zz=v4changelog本版介绍* 基于官方简体中文版便携式制作* 绿色便携，无需安装* 数据保存至根目录* 绿色版可选添加右键资源管理器菜单* 单文件无右键扩展* 集成专业版永久授权密钥* 去主界面首页下方广告横幅* 完全禁止自动检测升级* 去选项检测升级* 去帮助菜单多余项下载地址4.2.7直装破解版+4.2.8破解补丁：稀缺资源统一下载地址页4.2.8官方下载：http://www.scootersoftware.com/BCompare-zh-4.2.8.23479.exe附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!正版激活密钥，支持在线联网激活—&nbsp;BEGIN&nbsp;LICENSE&nbsp;KEY&nbsp;—\nH1bJTd2SauPv5Garuaq0Ig43uqq5NJOEw94wxdZTpU-pFB9GmyPk677gJ\nvC1Ro6sbAvKR4pVwtxdCfuoZDb6hJ5bVQKqlfihJfSYZt-xVrVU27+0Ja\nhFbqTmYskatMTgPyjvv99CF2Te8ec+Ys2SPxyZAF0YwOCNOWmsyqN5y9t\nq2Kw2pjoiDs5gIH-uw5U49JzOB6otS7kThBJE-H9A76u4uUvR8DKb+VcB\nrWu5qSJGEnbsXNfJdq5L2D8QgRdV-sXHp2A-7j1X2n4WIISvU1V9koIyS\nNisHFBTcWJS0sC5BTFwrtfLEE9lEwz2bxHQpWJiu12ZeKpi+7oUSqebX+\n—&nbsp;END&nbsp;LICENSE&nbsp;KEY&nbsp;—–",
    "postDate": "2019-01-30T23:40:45.3388845+08:00",
    "email": "admin@masuit.com",
    "label": "beyond compare",
    "keyword": "文件对比神器,BeyondCompare破解版,Beyond Compare,BeyondCompare",
    "id": 1228,
    "indexId": "Post:1228"
  },
  {
    "title": "Tuxera NTFS 2018 for Mac 中文破解版",
    "author": "懒得勤快",
    "content": "号外Tuxera NTFS 2018 for Mac中文版终于上线了，备受期待的 Tuxera NTFS &nbsp;2018 Mac中文破解版终于上线了，千呼万唤的Tuxera NTFS for Mac 2018版终于上线了，重要的事说三遍，本次上新自带Tuxera NTFS for Mac注册码，安装即可使用，无需破解。并全新支持macOS High Sierra10.13以上系统。Tuxera NTFS 2018 Mac中文版使用说明1.重启电脑后，应用程序安装好的Tuxera NTFS 2018 Mac打开，插上您的移动硬盘，点击移动硬盘，右边会显示移动硬盘的信息，由此证明Tuxera NTFS 2018 Mac已经安装成功，读写正常。2.如果您还需要查看Tuxera NTFS 2018 Mac中文版的详细信息，请打开您的系统偏好设置，双击左下角的Tuxera NTFS 。3.解锁打开，在一般的目录下，显示Tuxera NTFS 2018 Mac状态：已启用。在右下角您可以看到卸载Tuxera NTFS 2018 Mac的提示，以后卸载该款软件，就在这里卸载。4.在卷目录下，您可以看到被Tuxera NTFS 2018 Mac挂载的卷，也就是您的移动硬盘。5.在激活目录下，您可以看到当前状态：产品密匙生效。6.在更新目录下，您可以看到您的版本是当前Tuxera NTFS 2018 Mac最新版本。7.最好关于目录，您可以看到Tuxera NTFS 2018 Mac作者信息，相关介绍等。8.至此软件安装成功，您可以尽情享受了。Tuxera NTFS &nbsp;2018 Mac破解版官方介绍适用于Mac粉丝的Tuxera NTFS的好消息！我们已经准备好了一个全新的版本，可以通过macOS High Sierra支持 - 适用于Mac 2018的Tuxera NTFS进行下载。在macOS High Sierra上读取和写入Windows NTFS驱动器与以前的版本一样，适用于Mac 2018的Tuxera NTFS为Windows NTFS格式的驱动器带来了对Mac的全面读写兼容性。我们的最新版本支持macOS High Sierra和Sierra，OS X El Capitan以及10.4（Tiger）以后的所有OS X版本。为现有客户提供优质服务无论您的操作系统版本如何，我们都建议您下载最新的Tuxera NTFS for Mac以获取所有最新功能和改进。对于我们现有的客户，新版本是最好用的，支持10.13macOS High Sierra如果您正在运行High Sierra，则一定要下载最新版本的Tuxera NTFS for Mac。在之前的文章中，我们讨论了高Sierra阻止2016年发布的Tuxera NTFS for Mac的问题。随着High Sierra的推出，Apple推出了一项要求，即用户必须手动批准加载新内核扩展的任何软件。NTFS for Mac 2018安装程序现在可以轻松引导您完成此过程。什么是内核扩展？用简单的英语，内核是运行在macOS核心的程序。内核完全控制Mac内的所有内容。“内核扩展”是有助于扩展内核功能的代码。在Tuxera NTFS for Mac的情况下，我们的内核扩展扩展了Mac在Windows NTFS格式化驱动器上写入，删除和移动文件的功能。新的Mac？如果您刚刚从Windows切换到Mac，则可能无法复制，编辑或删除存储在您用于Windows PC的USB存储棒或外部硬盘驱动器中的文件。这是因为开箱即用，Apple的操作系统macOS只允许您读取使用Windows PC格式化的文件系统上存储的文件。使用NTFS for Mac 2018，您可以轻松访问，编辑，存储和传输PC和Mac之间的文件。Tuxera NTFS 2018 Mac中文版软件介绍为什么你需要Tuxera NTFS 2018 for Mac当涉及到Windows NTFS格式的USB驱动器时，Mac只能用于阅读。这意味着您可以打开存储在这些驱动器上的文件，但无法使用Mac编辑，复制，移动或删除这些文件。要编写文件，您需要一个附加的NTFS驱动程序。适用于Mac的Tuxera NTFS是易于使用的软件，可以让这一切成为可能。适用于Mac的Tuxera NTFS在Mac上使用Windows驱动器做所有事情使用之前在Windows中格式化的外部USB驱动器交换机在Windows PC和Mac之间定期驱动如果您双启动Windows和macOS / OS X，则无缝交换数据如果您通过虚拟机（例如VMWare?）运行Windows，轻松进行文件处理Tuxera NTFS for Mac注册码版本特色轻松交换和更换驱动器不管你使用什么 - 使用相同的外部USB驱动器 - Windows PC或Mac。用于Mac的Tuxera NTFS为Windows NTFS格式的驱动器添加了完整的读取和写入功能。保留重要的东西在错误的时间意外断电或拔下USB驱动器可能会导致数据丢失（或更糟），从而损坏驱动器。我们市场领先的故障安全技术保持您的视频，图片和其他文件完好无损，并防止驱动器损坏。等待文件传输Tuxera NTFS for Mac通过我们的智能缓存技术提供快速，持续的文件传输速度。这意味着等待文件在USB驱动器和Mac之间进行保存或复制的时间更少。可负担得起的一次性购买我们提供便捷的一次性购买，安装即可无需破解，适用于整个软件生命周期。所有您的个人家用电脑都需要一款Tuxera NTFS &nbsp;2018 Mac破解版。技术爱好者的高级功能我们的软件是市场上唯一支持NTFS扩展属性的NTFS驱动程序。它还兼容流行的虚拟化和加密解决方案，包括ParallelsDesktop?和VMwareFusion?。您还可以获得Tuxera Disk Manager，这是一款可以轻松格式化，检查和修复NTFS驱动器的配套应用程序。下载地址稀缺资源统一下载地址页附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!",
    "postDate": "2019-01-30T23:40:45.3389501+08:00",
    "email": "admin@masuit.com",
    "label": "mac",
    "keyword": null,
    "id": 1306,
    "indexId": "Post:1306"
  },
  {
    "title": "强大专业的图标制作工具 Axialis IconWorkshop V6.9.1 汉化破解版",
    "author": "懒得勤快",
    "content": "Axialis IconWorkshop是一款功能强大的Windows XP图标制作、提取、转换、管理和发布软件，帮您在几分钟之内制作出专业的漂亮图标。IconWorkShop是一款专业的图标制作工具，通过IconWorkshop可以为Windows,MacOS和Unix操作系统创建图标。 为Vista/7系统创建256×256的Windows图标，为OSX Lion 系统创建1024×1024的Macintosh图标。以及为Unix/Linux系统创建PNG格式图标。软件特点支持各种图形格式导入自动生成图标Axialis IconWorkshop拥有功能强大的编辑器，同时也支持从现有图像来创建图标，且更为简单。您可以导入各种格式图片，自动生成图标。如PSD，PNG，BMP，JPEG，GIF，JPEG2000 …更有将包含多个图像格式的文件通过简单一步操作创建成为图标的独特功能！一切步骤都会自动完成：保留Alpha通道，调色板计算为256色格式，甚至有透明度的16色格式。对Visual Studio强力支持工作更高效允许用户在IconWorkshop中很容易地编辑包含在解决方案中的图标。只需在Visual Studio的资源编辑器中打开图标，启动相关的插件命令，该图标将自动在IconWorkshop中打开，可在需要时对其进行编辑。当图标在 IconWorkshop中被保存后，VS IDE将自动刷新该图标文件。Axialis IconWorkshop能够与Visual Studio同时运作相辅相成，这一插件的目的就是要在 IconWorkshop和VS IDE之间搭建一个的桥梁，使用户的工作效率大大提升。实现Windows和Mac OS系统间的图标转换IconWorkshop支持读取Mac OS图标并把它们转化为Windows图标。能够读取最新至OSX 10.7 Lion版本系统的所有Macintosh图标。使用此功能将能够在Windows 桌面上使用Macintosh图标。IconWorkshop还拥有在两个操作系统之间批量进行图标转换的功能（多个图标通过一步操作进行转换）。支持Mac Binary文件格式，允许图标在Macintosh和Windows之间的即刻转换。为智能手机创建图标：iPhone OS，Android，Windows Phone智能手机和其他便携式的媒体设备在应用程序开发领域建立了新的标准，通过高端的多点触摸界面将用户体验提高到了人体工程学的新层面。继而，图标在用户使用中是否更加直观、方便的层面起到了重要作用。IconWorkshop遵循不同操作系统的具体规格参数，使用户能在短短几分钟内创建出Android, iPhone OS和Windows Phone操作系统所需的图标。使用“图像对象包”，即可为手机应用创建海量高质的图标。为工具栏创建和编辑图像条的唯一图标编辑器IconWorkshop是唯一一款可以为工具栏创建和编辑图像条的图标编辑器，仅需在IconWorkshop中打开并逐个单独编辑。图像条中可以添加、复制、移动和删除图标。用户还可以从现成的图像条中通过简单的拖放创建新的图像条。IconWorkshop可以读取所有BMP和PNG格式的图像条。32 BPP图像通过Alpha通道支持透明度，24 BPP或更少像素的图像通过一个固定的背景颜色实现透明度。图像对象包 – 创建具有吸引力的图标使用图像对象创建图标是IconWorkShop的一项独特功能，IconWorkShop拥有一个含有丰富基本对象的图像库。只需通过鼠标的简单拖放，将基本图像一一联系起来（逐个迭加）即可在很短的时间内创建出自定义的专业图标。基本图像库是由专业设计师以256×256高品质PNG图像格式设计的。使用这些图像对象即能够轻松地为Windows XP，Windows Vista和Mac OS系统创建包含多种格式的图标。完全集成功能强大的编辑器市面上的许多图标制作是通过多个程序整合而成，因此使用起来十分复杂。IconWorkshop中拥有完全集成的工作区，所用功能都将显示在同一界面上，使用户的工作效率大大提升。在多文档的视图界面中，用户可以同时打开多个不同的文件窗口进行工作。IconWorkshop拥有强大功能的编辑器：一步命令轻松创建图像格式，导入、导出图像，调整图像尺寸，利用多种滤光器调节图像，改变色调、对比度、亮度、投影等多种功能。破解说明：1- 安装主程序，不要运行；2- 断网；3- 导入注册表文件regme.reg4- 运行程序，输入注册信息；5- 联网。汉化说明：现官网最新版本6.91！ 非破解版！未修改原版任何一个文件！以添加语言包的形式完成汉化！&nbsp;注：本资源不含 IconWorkshop 6.91 安装包，官网下载地址：https://secure.axialis.com/downloads/IconWorkshop-Pro.exe&nbsp;步骤：&nbsp;1. 从官网下载最新的 Axialis IconWorkshop 6.91 并安装（下载并运行iconworkshop.exe）2. 确保 Axialis IconWorkshop 程序没有运行（如果已运行请关闭）&nbsp;3. 复制 ResChs.dll 到工作文件夹（如：C:\\Program Files\\Axialis\\IconWorkshop）&nbsp;4. 运行 Axialis IconWorkshop 程序，即拥有简体中文界面。&nbsp;5. 如果仍然显示英文界面： * 单击 Edit \\ Preferences 菜单项 * 在弹出对话框的 General 标签页的 Application Language 组合框选择 &lt;Automatic&gt; 或 Chinese(ResChs.dll) * 单击确定，退出并重新运行程序下载地址感谢 @山清水秀·润智&nbsp;分享附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!稀缺资源统一下载地址页",
    "postDate": "2019-01-30T23:40:45.3390114+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "IconWorkshop",
    "id": 1310,
    "indexId": "Post:1310"
  },
  {
    "title": "C# vs Java：C# 五个不可替代的特性瞬间秒杀 Java",
    "author": "懒得勤快",
    "content": "作为一名集.NET、JavaEE、web前端于一身的全栈开发者，我自认为我对C#、java、javascript的认知都不算很浅的了，如果我们可以同时拥有 C# 和 Java 世界的最好特性，那会是什么样呢？完美的编程语言并不存在，我希望我们可以在这一点上达成一致。开发新语言往往是为了克服另一种语言的弊端，又不可避免的在某些方面上健壮一些，却在另一些方面上存在不足。　　C# 与 Java 都起源于 C/C++ 语言，他们在面向对象方面有许多相似之处。除了 Java JVM 和 C# .NET CLR 有许多相同结构上的相似性之外，他们各自的开发团队都有各自的发展方向，他们关注的是各自的语言应该成为什么样子。　　我们并不想纠结于某一个语言比另一个语言好，我们只想罗列出 C# 开发者能用到而 Java 中没有的那些特性而已。　　下面我们开始吧。1. LINQ　　LINQ (Language-Integrated Query，语言集成查询) 于 2007 年引入到 C＃，以帮助开发人员从各种数据源查询数据。使用它，我们可以在无需考虑正在调用的特定数据库的语法来编写查询语句。LINQ provider 所提供的一个组件将查询转换为下层数据源可读的格式。例如，如果我们需要从 SQL 数据库查询数据，LINQ to SQL provider 程序将把 LINQ 查询转换成 T-SQL，以便数据库可以理解它。　　要在 LINQ 中执行查询操作，首先获取数据库，然后创建查询，最后执行查询。在 LINQ to Object 查询中，这可能仅像一样代码一样简单，而不是为每个循环编写嵌套的复杂迭代。　　例如，我们来看看这个代码，用于在 C＃ 中从列表中过滤 2 位数。　　首先，在不使用 LINQ 的情况下：List&lt;int&gt;&nbsp;FilterTwoDigitNumbersWithoutLinq(List&lt;int&gt;&nbsp;numbers)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;tens&nbsp;=&nbsp;new&nbsp;List&lt;int&gt;();\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(var&nbsp;i=0;&nbsp;i&nbsp;&lt;&nbsp;numbers.Count();&nbsp;i++)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((9&nbsp;&lt;&nbsp;numbers[i])&nbsp;&amp;&amp;&nbsp;(numbers[i]&nbsp;&lt;&nbsp;100))\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tens.Add(numbers[i]);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;tens;\n}　　如果使用 LINQ 查询语法形式：List&lt;int&gt;&nbsp;FilterTwoDigitNumbersWithLinq(List&lt;int&gt;&nbsp;numbers)=&gt;(from&nbsp;a&nbsp;in&nbsp;numbers&nbsp;where&nbsp;(a&nbsp;&gt;&nbsp;9&nbsp;&amp;&amp;&nbsp;a&nbsp;&lt;&nbsp;100)&nbsp;select&nbsp;a).ToList();　　或者是方法语法形式：List&lt;int&gt;&nbsp;FilterNonTwoDigitNumbersWithLinq2(List&lt;int&gt;&nbsp;numbers)=&gt;&nbsp;numbers.Where(a&nbsp;=&gt;&nbsp;a&nbsp;&gt;&nbsp;9&nbsp;&amp;&amp;&nbsp;a&nbsp;&lt;&nbsp;100).ToList();　　这里两种语法都是正确的，唯一的区别就是查询语法看起来更像是 SQL 语句而方法语法使用 lambda 表达式（当然，看起来很像我们在 Java 里写的某些代码）　　综述：LINQ 所依赖的许多特性，如 lambda 表达式（就 LINQ 来说非常有用），已经在 Java 中有了等效的实现，尽管我们可以使用流和 lambda 来查询数据，但 LINQ 简化了整个过程并且移除了很多在 Java 中存在的冗余代码。2. Struct　　C＃ 中的结构体类似于类。实际上，一个 struct 甚至可以被认为是一个“轻量级类”，因为它可以包含构造函数、常量、方法等等。一个结构体和一个类之间最大的区别在于结构是值类型，而类是引用类型。　　相比于创建类，编写结构体最重要的好处是在构造一个值类型时比在构造引用类型时更容易确保值语义。如 Microsoft 的文档所述，“struct 类型的变量直接包含结构体的数据，而类类型的变量包含对数据的引用。”因此，对比使用类时，使用结构体的好处之一是，从代码的其他部分更改其值的唯一方法是将其作为参考进行显式传递。　　微软的开发人员建议对于那些小于 16 字节、生命周期短、不改变的而且不常装箱的类型，使用结构体(struct)而不是类(class)。在这种情况下，使用结构体可能会比使用类更有效率，因为它会保存在栈而不是堆中。　　比如：public&nbsp;struct&nbsp;Point\n{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;X;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;Y;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Point(int&nbsp;X,&nbsp;int&nbsp;Y)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.X&nbsp;=&nbsp;X;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.Y&nbsp;=&nbsp;Y;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Point&nbsp;operator&nbsp;+(Point&nbsp;p1,&nbsp;Point&nbsp;p2)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;Point(p1.X&nbsp;+&nbsp;p2.X,&nbsp;p1.Y&nbsp;+&nbsp;p2.Y);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;override&nbsp;string&nbsp;ToString()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;($&quot;({X},&nbsp;{Y})&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n}\nclass&nbsp;Program\n{\n&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;void&nbsp;Main(string[]&nbsp;args)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Point&nbsp;point1&nbsp;=&nbsp;new&nbsp;Point(1,&nbsp;5);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Point&nbsp;point2&nbsp;=&nbsp;new&nbsp;Point(2,&nbsp;3);&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;两个点相加的结果是:&nbsp;{0}&quot;,&nbsp;(point1&nbsp;+&nbsp;point2));&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n}　　小结：很多情况下使用结构体可以节省内存分配和释放的时间，这确实很有吸引力。然而事实是值类型拥有自己的存储空间。无论结构体拥有如何明显的优点和缺点，这在 Java 中都不需要操心。3.&nbsp;async/await　　在一段代码中调用 async，或者更明确地调用方法，这个方法都会在另一个线程上执行，不会阻塞当前线程。当代码运行到 await 命令的时候，它会继续运行(await 的语句)。如果这时 async 代码还没有完成，那么执行中的程序会返回到调用点。　　这有助于提高应用程序总体的响应速度，以及减少性能瓶颈。在应用程序访问 Web 和进行所有 UI 相关的活动时，使用异步程序非常重要。相对于以前的异步编程实现，使用 async/await 可以保留你代码的逻辑结构，而编译器则会担负起以前由开发者担负的重担。　　示例:class&nbsp;Program\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;Main()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;Hey&nbsp;David,&nbsp;How&nbsp;much&nbsp;is&nbsp;98745&nbsp;divided&nbsp;by&nbsp;7?&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Task&lt;int&gt;&nbsp;david&nbsp;=&nbsp;ThinkAboutIt();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;While&nbsp;he&nbsp;thinks,&nbsp;lets&nbsp;chat&nbsp;about&nbsp;the&nbsp;weather&nbsp;for&nbsp;a&nbsp;bit.&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;Do&nbsp;you&nbsp;think&nbsp;it&#39;s&nbsp;going&nbsp;to&nbsp;rain&nbsp;tomorrow?&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;No,&nbsp;I&nbsp;think&nbsp;it&nbsp;should&nbsp;be&nbsp;sunny.&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;david.Wait();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;davidsAnswer&nbsp;=&nbsp;david.Result;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine($&quot;David:&nbsp;{davidsAnswer}&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;async&nbsp;Task&lt;int&gt;&nbsp;ThinkAboutIt()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await&nbsp;ReadTheManual();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;Think&nbsp;I&nbsp;got&nbsp;it.&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(98745&nbsp;/&nbsp;7);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;async&nbsp;Task&nbsp;ReadTheManual()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;file&nbsp;=&nbsp;@&quot;D:\\HowToCalc.txt&quot;;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;Reading&nbsp;a&nbsp;manual.&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using&nbsp;(StreamReader&nbsp;reader&nbsp;=&nbsp;new&nbsp;StreamReader(file))\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;text&nbsp;=&nbsp;await&nbsp;reader.ReadToEndAsync();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;Done.&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n}　　输出://&nbsp;Possible&nbsp;Output:\nHey&nbsp;David,&nbsp;How&nbsp;much&nbsp;is&nbsp;98745&nbsp;divided&nbsp;by&nbsp;7?\nReading&nbsp;a&nbsp;manual.\nWhile&nbsp;he&nbsp;thinks,&nbsp;lets&nbsp;chat&nbsp;about&nbsp;the&nbsp;weather&nbsp;for&nbsp;a&nbsp;bit.\nDo&nbsp;you&nbsp;think&nbsp;it&#39;s&nbsp;going&nbsp;to&nbsp;rain&nbsp;tomorrow?\nNo,&nbsp;I&nbsp;think&nbsp;it&nbsp;should&nbsp;be&nbsp;sunny.\nDone.\nThink&nbsp;I&nbsp;got&nbsp;it.\nDavid:&nbsp;14106　　概要：CompletableFutures 无疑可以使我们更趋近于拥有等效于 C＃ 和 Java 所拥有的异步编程中的能力。尽管如此，使用它所带来的复杂性使其易用度不能与使用 async /await 关键字进行的实现相提并论。4. Lazy&lt;T&gt; 类　　无论使用 C# 还是 Java，很多人都已经实现了延迟初始化 (或实例化)，因此对象要在第一次使用的时候才会被创建。有一种常见的例子是将延迟初始化用于应用程序启动的时候加载大量对象，但实际需要初始化的对象可能只有少数几个。这种情况下，我们希望辨别哪些是不需要在这里初始化的。只初始化那些确实需要初始化的对象可以提升应用程序的性能。　　小结：最近，Lambda 表达式引入到 Java 8 之后，在 Java 中实现延迟加载(还有不少其它事情)变得更容易了。不过，在 C# 中我们可以使用语义化的 Lazy&lt;T&gt; 封装类来延迟初始化任何类库或用户指定的类型。5. 一些等价的关键词　　语言中的有用功能不一定像在 C＃ 中的 LINQ 或 Java 中的模块一样大。这里有一些可以帮助 C＃ 开发人员的关键字，它们在 Java 中并没有：　　a. as　　C# 中的 as 关键字会尝试安全地将对象转换为某个类型，如果不能转换的话，就返回 null。与 Java 的instanceof 几乎等同，但它是一个布尔值，如果类型匹配则返回 true，否则返回 false。　　b. yield　　在 C# 中使用&nbsp; Yield 和 return yield 来进行自定义且状态化的迭代，不需要显式创建额外的类，也不需要创建临时集合。在 Java 中我们实现迭代最好的选择是使用外部库或使用 Java 8 引入的 Lambda 表达式。　　c. var　　var 是一种自动推断类型，也可以称之为万能接口，其实际类型由编译器决定，其功能相当于写一个显式类型 (比如 int, string 等)。它除了可以减少一些按键之外，var 还允许用于匿名类型，而匿名类型在 LINQ 中很常用。我们期待看到“var”标识，备受瞩目的 Java SE 9 将实现“将类型推导扩展到定义并初始化局部变量时。”　　d.&nbsp;checked　　C# 中，我们使用 checked 关键字显式启用对整型表达式的溢出检查。如果表达式的运算结果超出目标类型的范围，我们可以使用 checked 强制要求运行时抛出 OverflowException。这十分有用，因为常量表达式会在编译期进行溢出检查，而非常量表达式不会。工具生态系统　　Java 和 C# 之间存在大量的不同之外，当然，其中一些源于 Java 和 .NET 框架的不同。这些不同之处也导致了一些工具在兼容性方面的差异，比如 OverOps 在生产监控和错误跟踪方面的差异。　　OverOps 向开发者展示生产中每个错误整个调用栈的全部源代码和变量状态。目前在 .NET 框架上并没有与之相同的内容，不过在接下来的几个月内会有一些变化。想了解更多信息，请点击这里加入我们 .NET Beta 的等候名单，如果你是 Java 开发者可以去 www.overops.com 查看演示。最后的思考　　在快结束时候，我们这里提到的大部分功能都在代码长度和简洁程度方面对 C# 开发者有所帮助，这些代码不能在 Java 中编写。事实上这些特性也或多或少说明了 Java 语言冗长的问题，包括最近版本更新带来的 Lambda 表达式。诚然，很多这些存在于 C# 而不存在于Java 中的特性在常规使用中提供了比使用 Lambda 更简洁的语法。　　再次说明，我们不想卷入没完没了的关于哪种言更好的争论，我们只是在这里指出两种语言之间的一些区别。我们是否遗漏了某些你希望 Java 拥有的特性？请在评论中告诉我们！&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;英文原文出处：http://blog.takipi.com/c-vs-java-5-irreplaceable-c-features-wed-kill-to-have-in-java/",
    "postDate": "2019-01-30T23:40:45.3390738+08:00",
    "email": "admin@masuit.com",
    "label": "C#,java",
    "keyword": null,
    "id": 117,
    "indexId": "Post:117"
  },
  {
    "title": "Xshell v6.0.0.107 永久授权补全中文绿色版",
    "author": "懒得勤快",
    "content": "NetSarang Xshell – 知名终端连接工具，非常强大的SSH远程终端客户端 ，非常好用的SSH终端管理器。Xshell功能超级强大，性能非常优秀，其特色功能支持多标签会话管理主机，支持远程协议Telnet、Rlogin、SSH/SSH PKCS＃11、SFTP、Serial，其它功能包括动态端口转发、自定义键盘映射、VB脚本支持、完全的 Unicode 支持等。Xshell 5.0版本之后软件已经自带简体中文语言，中文界面也让你轻松管理远程服务器。新版变化https://www.netsarang.com/news/ver6_beta_release.html—新增全局主密码保护已连接服务器的会话文件， 如果没有主密码即使会话文件被泄露攻击者亦无法登陆。主密码实际是解决去年维基解密爆料的CIA通过植入后门程序的方式盗取 XShell 会话文件攻击服务器。—多主题体验新增明亮和暗色两种新的主题模式，现在可以根据需要选择Xshell的颜色和整体主题，选择默认的有三种主题样式，同时用户也可以切换回v5 版那种传统的主题。—会话管理器最大的改变是加入了会话管理器面板，分栏方便快速连接服务器，用户可以轻松创建、编辑和删除会话文件。现在，会话管理的所有方面以及同时启动多个会话的功能都可以通过会话管理器在Xshell中访问。—可停靠的UI会话管理器窗口、编辑窗口和其他窗扣可以停靠在Xshell的主窗口中。这为Xshell的可定制配置提供了更多的功能。用户可以简单地拖放窗口。—支持SSH PKCS＃11PKCS＃11协议使用户能够使用硬件令牌（HSM）安全地存储私钥，支持诸如硬件令牌和智能卡等设备安全的存储用户使用的密钥以提高安全性。—编辑窗口以前，Xshell只能使用编辑栏向终端发送一行准备好的字符。Xshell 6引入了组合窗口，用户能够准备多行脚本或字符串，并同时将其传送到当前会话或多个会话中。—突出显示Xshell 6允许用户使用自定义的文本和背景颜色来区分终端的字符串输出。用户可以轻松地管理他们想要突出显示的关键字，也可以创建分组，以便在特定情况下使用设置的关键字。—ASCII和非ASCII（中文，韩文等）字符的独立字体集成常，在某些窗口中，即使使用相同的字体，ASCII字符和非ASCII字符的大小也可能不同。在Xshell 6中，用户可以为不同的语言指定不同的字体，从而获得更加一致和稳定的终端输出。-&nbsp;在网上搜索所选文本任何在Xshell 6终端中选择的字符串都可以通过用户定义的搜索引擎立即在网上搜索。—各种铃声/闹铃选项当监视远程服务器时，用户设置警报以通知他们任何改变、错误等。仅使用基于字符串的警报可能不足以吸引用户。Xshell 6的铃声选项提供了各种声音和屏幕效果，以确保用户可以及时得到提醒。—稳定性和性能增强工具增强了跟踪消息的功能，并添加了更多的日志记录选项以便用户可以更高效地识别和诊断连接问题。此版特点# 独家绿化，集成内部密钥启动为永久授权版；# 去启动效验，并移除版权保护服务安装程序；# 补全简体中文模块翻译，完整显示简体中文；# 已默认设置选择个人数据保存到当前目录下；# 删多国语言模块、密钥管理、在线升级程序；# 去除菜单多余项：检查更新、英文帮助等等；下载地址稀缺资源统一下载地址页推荐：Xmanager_Enterprise_v6.0.0008r官方企业版+注册机附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!最后，xshell官网域名不是xshellcn.com，真正的xshell中文官网地址是netsarang.com，也请需要支持正版的朋友们搜索的时候看清楚网址：附上搜集来的的所有域名，需要支持正版的童鞋请擦亮双眼：127.0.0.1&nbsp;www.makeding.com\n127.0.0.1&nbsp;makeding.com\n127.0.0.1&nbsp;vm.makeding.com\n127.0.0.1&nbsp;www.bingdianhuanyuan.cn\n127.0.0.1&nbsp;xia.bingdianhuanyuan.cn\n127.0.0.1&nbsp;bingdianhuanyuan.cn\n127.0.0.1&nbsp;huishenghuiying.com.cn\n127.0.0.1&nbsp;www.huishenghuiying.com.cn\n127.0.0.1&nbsp;xia.huishenghuiying.com.cn\n127.0.0.1&nbsp;coreldrawchina.com\n127.0.0.1&nbsp;xia.coreldrawchina.com\n127.0.0.1&nbsp;www.coreldrawchina.com\n127.0.0.1&nbsp;shankejingling.com\n127.0.0.1&nbsp;www.shankejingling.com\n127.0.0.1&nbsp;xia.shankejingling.com\n127.0.0.1&nbsp;mairuan.com\n127.0.0.1&nbsp;www.mairuan.com\n127.0.0.1&nbsp;xia.mairuan.com\n127.0.0.1&nbsp;logoshejishi.com\n127.0.0.1&nbsp;www.logoshejishi.com\n127.0.0.1&nbsp;xia.logoshejishi.com\n127.0.0.1&nbsp;keyshot.cc\n127.0.0.1&nbsp;xia.keyshot.cc\n127.0.0.1&nbsp;www.keyshot.cc\n127.0.0.1&nbsp;flstudiochina.com\n127.0.0.1&nbsp;www.flstudiochina.com\n127.0.0.1&nbsp;xia.flstudiochina.com\n127.0.0.1&nbsp;ediuschina.com\n127.0.0.1&nbsp;www.ediuschina.com\n127.0.0.1&nbsp;xia.ediuschina.com\n127.0.0.1&nbsp;vegaschina.cn\n127.0.0.1&nbsp;www.vegaschina.cn\n127.0.0.1&nbsp;xia.vegaschina.cn\n127.0.0.1&nbsp;guitarpro.cc\n127.0.0.1&nbsp;www.guitarpro.cc\n127.0.0.1&nbsp;xia.guitarpro.cc\n127.0.0.1&nbsp;www.xmindchina.cn\n127.0.0.1&nbsp;xia.xmindchina.cn\n127.0.0.1&nbsp;xmindchina.cn\n127.0.0.1&nbsp;xmindchina.net\n127.0.0.1&nbsp;www.xmindchina.net\n127.0.0.1&nbsp;xia.xmindchina.net\n127.0.0.1&nbsp;mindmanager.cc\n127.0.0.1&nbsp;www.mindmanager.cc\n127.0.0.1&nbsp;xia.mindmanager.cc\n127.0.0.1&nbsp;kingdeecn.cn\n127.0.0.1&nbsp;www.kingdeecn.cn\n127.0.0.1&nbsp;xia.kingdeecn.cn\n127.0.0.1&nbsp;xshellcn.com\n127.0.0.1&nbsp;www.xshellcn.com\n127.0.0.1&nbsp;xia.xshellcn.com\n127.0.0.1&nbsp;imindmap.cc\n127.0.0.1&nbsp;www.imindmap.cc\n127.0.0.1&nbsp;xia.imindmap.cc\n127.0.0.1&nbsp;abbyychina.com\n127.0.0.1&nbsp;www.abbyychina.com\n127.0.0.1&nbsp;xia.abbyychina.com\n127.0.0.1&nbsp;bartender.cc\n127.0.0.1&nbsp;www.bartender.cc\n127.0.0.1&nbsp;xia.bartender.cc\n127.0.0.1&nbsp;jihehuaban.com.cn\n127.0.0.1&nbsp;www.jihehuaban.com.cn\n127.0.0.1&nbsp;xia.jihehuaban.com.cn\n127.0.0.1&nbsp;mathtype.cn\n127.0.0.1&nbsp;www.mathtype.cn\n127.0.0.1&nbsp;xia.mathtype.cn\n127.0.0.1&nbsp;chemdraw.com.cn\n127.0.0.1&nbsp;www.chemdraw.com.cn\n127.0.0.1&nbsp;xia.chemdraw.com.cn\n127.0.0.1&nbsp;mycleanmymac.com\n127.0.0.1&nbsp;www.mycleanmymac.com\n127.0.0.1&nbsp;xia.mycleanmymac.com\n127.0.0.1&nbsp;ntfsformac.cn\n127.0.0.1&nbsp;www.ntfsformac.cn\n127.0.0.1&nbsp;xia.ntfsformac.cn\n127.0.0.1&nbsp;parallelsdesktop.cn\n127.0.0.1&nbsp;www.parallelsdesktop.cn\n127.0.0.1&nbsp;xia.parallelsdesktop.cn\n127.0.0.1&nbsp;beyondcompare.cc\n127.0.0.1&nbsp;www.beyondcompare.cc\n127.0.0.1&nbsp;xia.beyondcompare.cc\n127.0.0.1&nbsp;easyrecoverychina.com\n127.0.0.1&nbsp;www.easyrecoverychina.com\n127.0.0.1&nbsp;xia.easyrecoverychina.com\n127.0.0.1&nbsp;bingdianhuanyuan.cn\n127.0.0.1&nbsp;www.bingdianhuanyuan.cn\n127.0.0.1&nbsp;xia.bingdianhuanyuan.cn\n127.0.0.1&nbsp;hypersnap.mairuan.com\n127.0.0.1&nbsp;www.iconworkshop.cn\n127.0.0.1&nbsp;iconworkshop.cn\n127.0.0.1&nbsp;www.pdfexpert.cc\n127.0.0.1&nbsp;xiazai.pdfexpert.cc\n127.0.0.1&nbsp;www.zhzzx.com\n127.0.0.1&nbsp;yihuifu.cn\n127.0.0.1&nbsp;www.4009997658.com\n127.0.0.1&nbsp;4009997658.com\n127.0.0.1&nbsp;mairuanwang.com\n127.0.0.1&nbsp;www.mairuanwang.com\n127.0.0.1&nbsp;mairuan.com\n127.0.0.1&nbsp;mairuan.cn\n127.0.0.1&nbsp;mairuan.net\n127.0.0.1&nbsp;mairuan.com.cn",
    "postDate": "2019-01-30T23:40:45.3391349+08:00",
    "email": "admin@masuit.com",
    "label": "xshell",
    "keyword": "Xshell破解版,Xshell Plus",
    "id": 178,
    "indexId": "Post:178"
  },
  {
    "title": "Xmanager_Enterprise_v6.0.0010r官方企业版+独立版+注册机",
    "author": "懒得勤快",
    "content": "大家期待的Xmanager终于给大家扒来了xmanager enterprise 6又称xmanager 6企业版，这是一款功能强大、体积小巧的Linux远程管理软件，可以让用户Windows环境下浏览远端X窗口系统的工具，方便用户在windows平台下连接远程服务器进行管理操作，支持一键连接到unix、linux服务器系统进行文件的管理操作，这个是xmanager 5的升级版本，新版本还带来了全新的功能，同时还拥有全新的界面。在工作中经常使用Xmanager来登录远端的Solaris系统，在X窗口系统上作图形化的操作。但是，Xmanager默认并不提供对于中文的支持，为了能够浏览远端的中文Solaris系统，就必须对Xmanager作一些定制化操作，提供中文的浏览能力。这款软件能够完美支持多用户的Windows终端环境，功能齐全，使用便捷，通过这款软件还可以实现远程服务功能。Xmanager 6&nbsp;企业破解版提供强大的回话管理控制台和易于使用的X应用程序启动器，包含了常规XDMCP的所有好处，可以共享X应用程序，大幅度提高安全性。用户通过xmanager enterprise 6可以把远程的UNIX/Linux桌面环境无缝地导入到自己的Windows PC，即使用户的电脑是开启防火墙和安全软件的，用户也能通过SSH协议安全的运行远端的X应用程序。xmanager enterprise 6可以通过Xcongfig工具设置多个Xmanager设置，同时xmanager 6破解版支持多用户Windows终端环境的运行，支持多个IP地址同时在线，支持多窗口下的Windows打印等。还有用户可以在xmanager 破解版界面上同时启动多个会话，也可以创建各主机的快捷图标。通过xmanager 6破解版附属下的Xstart可以在用户PC运行远程X应用程序，登陆远程主机时支持SSH、TELNET、RLOGIN、REXEC、RSH和LOCAL协议，并且可以在本机轻松执行远程主机命令，可以大大地提高管理人员的效率。利用Xstart可以在用户的Windows PC非常轻松的执行远程主机的命令，就是这么简单和任性。xmanager 6破解版广泛用于各种领域的工作，包括大型工艺与半导体和服务器管理设计的IDC（互联网数据中心）。大学和公司的服务器管理员与想要通过互联网连接到远程主机的个人用户是这个产品常用群体。软件自带了中文语言，安装后输入算号器序列号就可以正常使用了，需要的朋友下载看看吧。Xmanager 6 功能特色1、会话管理介绍Xmanager 6的全新会话管理器。作为主Xmanager窗口中的可停靠窗口，您可以立即访问会话管理所需的所有必需品。 轻松查看，创建，编辑和删除会话，并同时启动多个会话。管理你的会话从未如此简单!2、使用主密码增强密码加密将用户定义的字符串设置为您的主密码，为您的会话文件密码添加一层加密。主密码会加密用于连接到服务器的密码(密码)，用户密钥的密码(密码)以及会话文件中包含的密码字符串。 将会话文件安全地存储在云中以在设备之间共享。3、支持SSH PKCS#11PKCS#11协议使用户能够使用硬件令牌(HSM)安全地存储用户的私钥，以增加安全性。 Xmanager 6还支持GSSAPI，密码，公钥和键盘交互式身份验证方法。4、会话配置文件与XconfigXmanager 6包含一个内置的服务器配置文件管理器。使用诸如窗口模式，字体目录，颜色等选项创建配置文件，并将它们应用于会话。使用Xconfig，您可以设置一次，避免每个会话手动设置选项的麻烦。5、使用Xstart快速和简单启动X应用程序使用Xmanager 6的Xstart快速高效地启动单个X应用程序。 可以从Xmanager 6内管理Xstart会话文件，以便轻松访问经常访问的X应用程序。6、灵活和强大的标签式环境使用Xmanager 6的选项卡式环境，您可以在单个窗口中打开多个选项卡，无需在Windows任务栏中切换多个远程桌面会话。 通过选项卡式窗口和RandR扩展支持，Xmanager 6提供了无与伦比的可用性，这在任何其他X服务器中都无法找到。7、动态搜索所有可用的UNIX / Linux主机当Xmanager 6启动时，它会动态搜索网络中所有可访问的主机。Xmanger 6自动创建动态会话，因此不需要为每个服务器设置单独的会话。 有了这个功能，X Window系统就像点击一样简单。8、使用地址栏进行即时连接使用地址栏，您可以连接到具有各种协议的各种主机，如XDMCP，SFTP，FTP，SSH和Telnet。 地址栏与您的网络浏览器具有相似的外观和感觉，因此习惯这种功能几乎不需要时间。xmanager6软件特点1、出众的性能在使用PC X服务器时，精度和速度至关重要。Xmanager 6基于高性能X11R7 PC X服务器，并支持多种X扩展以提高可用性。支持多达128个X客户端连接意味着您可以通过接近无限制的限制获得所有权力。2、无论何处都可以安全连接Xmanager 6的安全XDMCP提供了常规XDMCP的所有好处，而没有任何固有的安全风险。 即使它们位于防火墙后面或专用网络中，也可以远程安全地访问业务关键任务。利用主机访问控制，主密码，GSSAPI / PKCS#11支持等功能，确保只有授权用户才能访问您的数据。3、共享X应用程序在UNIX服务器系统(如CAD / GIS)上运行的X应用程序可以由多个使用Xmanager 6的个人共享。优化您的网络基础架构，同时最大限度地提高安全性。4、Windows和UNIX / Linux集成使用Xmanager 6，您可以将整个UNIX / Linux桌面环境带入Windows PC。 或者使用内置的Xstart工具快速访问单个X应用程序，并让它们与Windows应用程序并行运行。Xmanager 6结构介绍XstartXstart是一个窗口化的登陆界面，要求填入session，host，protocol，user name， password。可进行远程登陆。Xmanager PCX ServerXmanager是一个运行于MS Windows平台上的高性能的X window服务器。可以在本地PC上同时运行Unix/Linux和Windows图形应用程序。XftpXftp是一个用于MS Windows平台的强大的FTP和SFTP文件传输程序。Xftp能安全地在Unix/Linux和Windows PC之间传输文件。XshellXshell是一个用于MS Windows平台的强大的SSH，TELNET，和RLOGIN终端仿真软件。它使得用户能轻松和安全地从Windows PC上访问Unix/Linux主机。XlpdXlpd是一个用于MS Windows平台的LPD(行式打印机虚拟后台程序)应用程序。安装了Xlpd后，带有打印机的本地PC就成为了一个打印服务器，来自不同远程系统的打印任务都能在网络环境中得到请求和处理。更新说明(1)一体化的UNIX / Linux和Windows集成解决方案Xmanager Power Suite是一款全功能的解决方案，其中包括Xmanager，Xshell，Xftp和Xlpd。 Xmanager运行X窗口应用程序，Xshell使用安全终端管理远程Unix / Linux服务器。 Xftp安全地在系统之间传输文件，Xlpd在其他系统上运行远程文档的本地打印。(2)集中分散的系统资源并降低TCO由于多个X应用程序和文件系统，使用各种操作系统的公司可能会发现其系统资源分散在网络上。 Xmanager Power Suite 6通过允许用户直接从桌面访问所有分散的资源来解决此问题。 拥有允许用户远程访问应用程序的中央位置，升级和维护变得易于管理并降低TCO。(3)互操作性实现最高生产率该套件中包含的所有程序都共享一个通用的SSH(安全外壳)安全模块，以方便且高效地互相操作。通过将所有各种功能集成到一个套件中，客户可以通过购买，安装，维护以及降低总体拥有成本来体验更轻松的时间。破解说明1.卸载所有以前版本的Xmanager...2.运行Keygen并单击Fix Host + Register3.安装Xmanager PowerSuite，在安装时输入注册机生成的密钥4.请享用...提示：注册机只能注册带r版的。下载地址附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!官方安装包：https://share.weiyun.com/5HwuS2c破解补丁：稀缺资源统一下载地址页",
    "postDate": "2019-01-30T23:40:45.3392113+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "xmanager,xshell,xftp",
    "id": 1298,
    "indexId": "Post:1298"
  },
  {
    "title": "从.NET+25台服务器支撑世界第54大网站浅谈网站优化",
    "author": "懒得勤快",
    "content": "摘要：同时使用Linux和Windows平台产品，大量使用静态的方法和类，Stack Overflow是个重度性能控。同时，取代横向扩展，他们坚持着纵向扩展思路，因为“硬件永远比程序员便宜”。英文原文：StackOverflow Update: 560M Pageviews A Month, 25 Servers, And It&#39;s All About PerformanceStackOverflow&nbsp;是一个&nbsp;IT&nbsp;技术问答网站，用户可以在网站上提交和回答问题。当下的&nbsp;StackOverflow&nbsp;已拥有&nbsp;400&nbsp;万个用户，4000&nbsp;万个回答，月&nbsp;PV5.6&nbsp;亿，世界排行第&nbsp;54。然而值得关注的是，支撑他们网站的全部服务器只有&nbsp;25&nbsp;台，并且都保持着非常低的资源使用率，这是一场高有效性、负载均衡、缓存、数据库、搜索及高效代码上的较量。近日，High Scalability&nbsp;创始人&nbsp;Todd Hoff&nbsp;根据&nbsp;Marco Cecconi&nbsp;的演讲视频“&nbsp;The architecture of StackOverflow”以及&nbsp;Nick Craver&nbsp;的博文“&nbsp;What it takes to run Stack Overflow”总结了&nbsp;StackOverflow&nbsp;的成功原因。　　意料之中，也是意料之外，Stack Overflow&nbsp;仍然重度使用着微软的产品。他们认为既然微软的基础设施可以满足需求，又足够便宜，那么没有什么理由去做根本上的改变。而在需要的地方，他们同样使用了&nbsp;Linux。究其根本，一切都是为了性能。　　另一个值得关注的地方是，Stack Overflow&nbsp;仍然使用着纵向扩展策略，没有使用云。他们使用了&nbsp;384GB&nbsp;的内存和&nbsp;2TB的&nbsp;SSD&nbsp;来支撑&nbsp;SQL Servers，如果使用&nbsp;AWS&nbsp;的话，花费可想而知。没有使用云的另一个原因是&nbsp;Stack Overflow&nbsp;认为云会一定程度上的降低性能，同时也会给优化和排查系统问题增加难度。此外，他们的架构也并不需要横向扩展。峰值期间是横向扩展的杀手级应用场景，然而他们有着丰富的系统调整经验去应对。该公司仍然坚持着&nbsp;Jeff Atwood&nbsp;的名言——硬件永远比程序员便宜。　　Marco Ceccon&nbsp;曾提到，在谈及系统时，有一件事情必须首先弄明白——需要解决问题的类型。首先，从简单方面着手，StackExchange&nbsp;究竟是用来做什么的——首先是一些主题，然后围绕这些主题建立社区，最后就形成了这个令人敬佩的问答网站。　　其次则是规模相关。StackExchange&nbsp;在飞速增长，需要处理大量的数据传输，那么这些都是如何完成的，特别是只使用了&nbsp;25&nbsp;台服务器，下面一起追根揭底：状态StackExchange&nbsp;拥有&nbsp;110&nbsp;个站点，以每个月&nbsp;3&nbsp;到&nbsp;4&nbsp;个的速度增长。\n400&nbsp;万用户\n800&nbsp;万问题\n4000&nbsp;万答案\n世界排名&nbsp;54&nbsp;位\n每年增长&nbsp;100%\n月&nbsp;PV&nbsp;5.6&nbsp;亿万\n大多数工作日期间峰值为&nbsp;2600&nbsp;到&nbsp;3000&nbsp;请求每秒，作为一个编程相关网站，一般情况下工作日的请求都会高于周末\n25&nbsp;台服务器\nSSD&nbsp;中储存了&nbsp;2TB&nbsp;的&nbsp;SQL&nbsp;数据\n每个&nbsp;web&nbsp;server&nbsp;都配置了&nbsp;2&nbsp;个&nbsp;320G&nbsp;的&nbsp;SSD，使用&nbsp;RAID&nbsp;1\n每个&nbsp;ElasticSearch&nbsp;主机都配备了&nbsp;300GB&nbsp;的机械硬盘，同时也使用了&nbsp;SSD\nStack&nbsp;Overflow&nbsp;的读写比是&nbsp;40:60\nDB&nbsp;Server&nbsp;的平均&nbsp;CPU&nbsp;利用率是&nbsp;10%\n11&nbsp;个&nbsp;web&nbsp;server，使用&nbsp;IIS\n2&nbsp;个负载均衡器，1&nbsp;个活跃，使用&nbsp;HAProxy\n4&nbsp;个活跃的数据库节点，使用&nbsp;MS&nbsp;SQL\n3&nbsp;台实现了&nbsp;tag&nbsp;engine&nbsp;的应用程序服务器，所有搜索都通过&nbsp;tag\n3&nbsp;台服务器通过&nbsp;ElasticSearch&nbsp;做搜索\n2&nbsp;台使用了&nbsp;Redis&nbsp;的服务器支撑分布式缓存和消息\n2&nbsp;台&nbsp;Networks（Nexus&nbsp;5596&nbsp;+&nbsp;Fabric&nbsp;Extenders）\n2&nbsp;Cisco&nbsp;5525-X&nbsp;ASAs&nbsp;\n2&nbsp;Cisco&nbsp;3945&nbsp;Routers\n主要服务&nbsp;Stack&nbsp;Exchange&nbsp;API&nbsp;的&nbsp;2&nbsp;个只读&nbsp;SQL&nbsp;Servers\nVM&nbsp;用于部署、域控制器、监控、运维数据库等场合平台ElasticSearch\nRedis\nHAProxy\nMS&nbsp;SQL\nOpserver\nTeamCity\nJil——Fast&nbsp;.NET&nbsp;JSON&nbsp;Serializer，建立在&nbsp;Sigil&nbsp;之上\nDapper——微型的&nbsp;ORMUIUI&nbsp;拥有一个信息收件箱，用于新徽章获得、用户发送信息、重大事件发生时的信息收取，使用&nbsp;WebSockets&nbsp;实现，并通过&nbsp;Redis&nbsp;支撑。\n搜索箱通过&nbsp;ElasticSearch&nbsp;实现，使用了一个&nbsp;REST&nbsp;接口。\n因为用户提出问题的频率很高，因此很难显示最新问题，每秒都会有新的问题产生，从而这里需要开发一个关注用户行为模式的算法，只给用户显示感兴趣的问题。它使用了基于&nbsp;Tag&nbsp;的复杂查询，这也是开发独立&nbsp;Tag&nbsp;Engine&nbsp;的原因。\n服务器端模板用于生成页面。服务器25&nbsp;台服务器并没有满载，CPU&nbsp;使用率并不高，单计算&nbsp;SO（Stack&nbsp;Overflow）只需要&nbsp;5&nbsp;台服务器。\n数据库服务器资源利用率在&nbsp;10%&nbsp;左右，除下执行备份时。\n为什么会这么低？因为数据库服务器足足拥有&nbsp;384GB&nbsp;内存，同时&nbsp;web&nbsp;server&nbsp;的&nbsp;CPU&nbsp;利用率也只有&nbsp;10%-15%。\n纵向扩展还没有遇到瓶颈。通常情况下，如此流量使用横向扩展大约需要&nbsp;100&nbsp;到&nbsp;300&nbsp;台服务器。\n简单的系统。基于&nbsp;.Net，只用了&nbsp;9&nbsp;个项目，其他系统可能需要&nbsp;100&nbsp;个。之所以使用这么少系统是为了追求极限的编译速度，这点需要从系统开始时就进行规划，每台服务器的编译时间大约是&nbsp;10&nbsp;秒。\n11&nbsp;万行代码，对比流量来说非常少。\n使用这种极简的方式主要基于几个原因。首先，不需要太多测试，因为&nbsp;Meta.stackoverflow&nbsp;本来就是一个问题和&nbsp;bug讨论社区。其次，Meta.stackoverflow&nbsp;还是一个软件的测试网站，如果用户发现问题的话，往往会提出并给予解决方案。\n纽约数据中心使用的是&nbsp;Windows&nbsp;2012，已经向&nbsp;2012&nbsp;R2&nbsp;升级（Oregon&nbsp;已经完成了升级），Linux&nbsp;系统使用的是Centos&nbsp;6.4。SSD默认使用的是&nbsp;Intel&nbsp;330（Web&nbsp;层等）\nIntel&nbsp;520&nbsp;用于中间层写入，比如&nbsp;Elastic&nbsp;Search\n数据层使用&nbsp;Intel&nbsp;710&nbsp;和&nbsp;S3700\n系统同时使用了&nbsp;RAID&nbsp;1&nbsp;和&nbsp;RAID&nbsp;10（任何4+&nbsp;以上的磁盘都使用&nbsp;RAID&nbsp;10）。不畏惧故障发生，即使生产环境中使用了上千块&nbsp;2.5&nbsp;英寸&nbsp;SSD，还没碰到过一块失败的情景。每个模型都使用了&nbsp;1&nbsp;个以上的备件，多个磁盘发生故障的情景不在考虑之中。\nElasticSearch&nbsp;在&nbsp;SSD&nbsp;上表现的异常出色，因为&nbsp;SO&nbsp;writes/re-indexes&nbsp;的操作非常频繁。\nSSD&nbsp;改变了搜索的使用方式。因为锁的问题，Luncene.net&nbsp;并不能支撑&nbsp;SO&nbsp;的并发负载，因此他们转向了ElasticSearch。在全&nbsp;SSD&nbsp;环境下，并不需要围绕&nbsp;Binary&nbsp;Reader&nbsp;建立锁。高可用性异地备份——主数据中心位于纽约，备份数据中心在&nbsp;Oregon。\nRedis&nbsp;有两个从节点，SQL&nbsp;有&nbsp;2&nbsp;个备份，Tag&nbsp;Engine&nbsp;有&nbsp;3&nbsp;个节点，elastic&nbsp;有&nbsp;3&nbsp;个节点，冗余一切，并在两个数据中心同时存在。\nNginx&nbsp;是用于&nbsp;SSL，终止&nbsp;SSL&nbsp;时转换使用&nbsp;HAProxy。\n并不是主从所有，一些临时的数据只会放到缓存中\n所有&nbsp;HTTP&nbsp;流量发送只占总流量的&nbsp;77%，还存在&nbsp;Oregon&nbsp;数据中心的备份及一些其他的&nbsp;VPN&nbsp;流量。这些流量主要由SQL&nbsp;和&nbsp;Redis&nbsp;备份产生。数据库MS&nbsp;SQL&nbsp;Server\nStack&nbsp;Exchange&nbsp;为每个网站都设置了数据库，因此&nbsp;Stack&nbsp;Overflow&nbsp;有一个、Server&nbsp;Fault&nbsp;有一个，以此类推。\n在纽约的主数据中心，每个集群通常都使用&nbsp;1&nbsp;主和&nbsp;1&nbsp;只读备份的配置，同时还会在&nbsp;Oregon&nbsp;数据中心也设置一个备份。如果是运行的是&nbsp;Oregon&nbsp;集群，那么两个在纽约数据中心的备份都会是只读和同步的。\n为其他内容准备的数据库。这里还存在一个“网络范围”的数据库，用于储存登陆凭证和聚合数据（大部分是stackexchange.com&nbsp;用户文件或者&nbsp;API）。\nCareers&nbsp;Stack&nbsp;Overflow、stackexchange.com&nbsp;和&nbsp;Area&nbsp;51&nbsp;等都拥有自己独立的数据库模式。\n模式的变化需要同时提供给所有站点的数据库，它们需要向下兼容，举个例子，如果需要重命名一个列，那么将非常麻烦，这里需要进行多个操作：增加一个新列，添加作用在两个列上的代码，给新列写数据，改变代码让新列有效，移除旧列。\n并不需要分片，所有事情通过索引来解决，而且数据体积也没那么大。如果有&nbsp;filtered&nbsp;indexes&nbsp;需求，那么为什么不更高效的进行？常见模式只在&nbsp;DeletionDate&nbsp;=&nbsp;Null&nbsp;上做索引，其他则通过为枚举指定类型。每项&nbsp;votes&nbsp;都设置了&nbsp;1&nbsp;个表，比如一张表给&nbsp;post&nbsp;votes，1&nbsp;张表给&nbsp;comment&nbsp;votes。大部分的页面都可以实时渲染，只为匿名用户缓存，因此，不存在缓存更新，只有重查询。\nScores&nbsp;是非规范化的，因此需要经常查询。它只包含&nbsp;IDs&nbsp;和&nbsp;dates，post&nbsp;votes&nbsp;表格当下大约有&nbsp;56454478&nbsp;行，使用索引，大部分的查询都可以在数毫秒内完成。\nTag&nbsp;Engine&nbsp;是完全独立的，这就意味着核心功能并不依赖任何外部应用程序。它是一个巨大的内存结构数组结构，专为&nbsp;SO&nbsp;用例优化，并为重负载组合进行预计算。Tag&nbsp;Engine&nbsp;是个简单的&nbsp;windows&nbsp;服务，冗余的运行在多个主机上。CPU&nbsp;使用率基本上保持在2-5%，3&nbsp;个主机专门用于冗余，不负责任何负载。如果所有主机同时发生故障，网络服务器将把&nbsp;Tag&nbsp;Engine&nbsp;加载到内存中持续运行。\n关于&nbsp;Dapper&nbsp;无编译器校验查询与传统&nbsp;ORM&nbsp;的对比。使用编译器有很多好处，但在运行时仍然会存在&nbsp;fundamental&nbsp;disconnect&nbsp;问题。同时更重要的是，由于生成&nbsp;nasty&nbsp;SQL，通常情况还需要去寻找原始代码，而&nbsp;Query&nbsp;Hint&nbsp;和parameterization&nbsp;控制等能力的缺乏更让查询优化变得复杂。编码流程\n大部分程序员都是远程工作，自己选择编码地点\n编译非常快\n然后运行少量的测试\n一旦编译成功，代码即转移至开发交付准备服务器\n通过功能开关隐藏新功能\n在相同硬件上作为其他站点测试运行\n然后转移至&nbsp;Meta.stackoverflow&nbsp;测试，每天有上千个程序员在使用，一个很好的测试环境\n如果通过则上线，在更广大的社区进行测试\n大量使用静态类和方法，为了更简单及更好的性能\n编码过程非常简单，因为复杂的部分被打包到库里，这些库被开源和维护。.Net&nbsp;项目数量很低，因为使用了社区共享的部分代码。\n开发者同时使用&nbsp;2&nbsp;到&nbsp;3&nbsp;个显示器，多个屏幕可以显著提高生产效率。缓存缓存一切\n5&nbsp;个等级的缓存\n1&nbsp;级是网络级缓存，缓存在浏览器、CDN&nbsp;以及代理服务器中。\n2&nbsp;级由&nbsp;.Net&nbsp;框架&nbsp;HttpRuntime.Cache&nbsp;完成，在每台服务器的内存中。\n3&nbsp;级&nbsp;Redis，分布式内存键值存储，在多个支撑同一个站点的服务器上共享缓存项。\n4&nbsp;级&nbsp;SQL&nbsp;Server&nbsp;Cache，整个数据库，所有数据都被放到内存中。\n5&nbsp;级&nbsp;SSD。通常只在&nbsp;SQL&nbsp;Server&nbsp;预热后才生效。\n举个例子，每个帮助页面都进行了缓存，访问一个页面的代码非常简单：\n使用了静态的方法和类。从&nbsp;OOP&nbsp;角度来看确实很糟，但是非常快并有利于简洁编码。\n缓存由&nbsp;Redis&nbsp;和&nbsp;Dapper&nbsp;支撑，一个微型&nbsp;ORM\n为了解决垃圾收集问题，模板中&nbsp;1&nbsp;个类只使用&nbsp;1&nbsp;个副本，被建立和保存在缓存中。监测一切，包括&nbsp;GC&nbsp;操。据统计显示，间接层增加&nbsp;GC&nbsp;压力达到了某个程度时会显著的降低性能。\nCDN&nbsp;Hit&nbsp;。鉴于查询字符串基于文件内容进行哈希，只在有新建立时才会被再次取出。每天&nbsp;3000&nbsp;万到&nbsp;5000&nbsp;万&nbsp;Hit，带宽大约为&nbsp;300GB&nbsp;到&nbsp;600GB。\nCDN&nbsp;不是用来应对&nbsp;CPU&nbsp;或I/O负载，而是帮助用户更快的获得答案部署每天&nbsp;5&nbsp;次部署，不去建立过大的应用。主要因为\n可以直接的监视性能\n尽可能最小化建立，可以工作才是重点\n产品建立后再通过强大的脚本拷贝到各个网页层，每个服务器的步骤是：\n通过&nbsp;POST&nbsp;通知&nbsp;HAProxy&nbsp;下架某台服务器\n延迟&nbsp;IIS&nbsp;结束现有请求（大约&nbsp;5&nbsp;秒）\n停止网站（通过同一个&nbsp;PSSession&nbsp;结束所有下游）\nRobocopy&nbsp;文件\n开启网站\n通过另一个&nbsp;POST&nbsp;做&nbsp;HAProxy&nbsp;Re-enable\n几乎所有部署都是通过&nbsp;puppet&nbsp;或&nbsp;DSC，升级通常只是大幅度调整&nbsp;RAID&nbsp;阵列并通过&nbsp;PXE&nbsp;boot&nbsp;安装，这样做非常快速。协作团队\nSRE&nbsp;（System&nbsp;Reliability&nbsp;Engineering）：5&nbsp;人\nCore&nbsp;Dev（Q&amp;A&nbsp;site）6-7&nbsp;人\nCore&nbsp;Dev&nbsp;Mobile：6&nbsp;人\nCareers&nbsp;团队专门负责&nbsp;SO&nbsp;Careers&nbsp;产品开发：7&nbsp;人\nDevops&nbsp;和开发者结合的非常紧密\n团队间变化很大\n大部分员工远程工作\n办公室主要用于销售，Denver&nbsp;和&nbsp;London&nbsp;除外\n一切平等，些许偏向纽约工作者，因为面对面有助于工作交流，但是在线工作影响也并不大\n对比可以在同一个办公室办公，他们更偏向热爱产品及有才华的工程师，他们可以很好的衡量利弊\n许多人因为家庭而选择远程工作，纽约是不错，但是生活并不宽松\n办公室设立在曼哈顿，那是个人才的诞生地。数据中心不能太偏，因为经常会涉及升级\n打造一个强大团队，偏爱极客。早期的微软就聚集了大量极客，因此他们征服了整个世界\nStack&nbsp;Overflow&nbsp;社区也是个招聘的地点，他们在那寻找热爱编码、乐于助人及热爱交流的人才。编制预算预算是项目的基础。钱只花在为新项目建立基础设施上，如此低利用率的&nbsp;web&nbsp;server&nbsp;还是&nbsp;3&nbsp;年前数据中心建立时购入。测试快速迭代和遗弃\n许多测试都是发布队伍完成的。开发拥有一个同样的&nbsp;SQL&nbsp;服务器，并且运行在相同的&nbsp;Web&nbsp;层，因此性能测试并不会糟糕。\n非常少的测试。Stack&nbsp;Overflow&nbsp;并没有进行太多的单元测试，因为他们使用了大量的静态代码，还有一个非常活跃的社区。\n基础设施改变。鉴于所有东西都有双份，所以每个旧配置都有备份，并使用了一个快速故障恢复机制。比如，keepalived&nbsp;可以在负载均衡器中快速回退。\n对比定期维护，他们更愿意依赖冗余系统。SQL&nbsp;备份用一个专门的服务器进行测试，只为了可以重存储。计划做每两个月一次的全数据中心故障恢复，或者使用完全只读的第二数据中心。\n每次新功能发布都做单元测试、集成测试盒&nbsp;UI&nbsp;测试，这就意味着可以预知输入的产品功能测试后就会推送到孵化网站，即&nbsp;meta.stackexchange（原&nbsp;meta.stackoverflow）。监视/日志当下正在考虑使用&nbsp;http://logstash.net/做日志管理，目前使用了一个专门的服务将&nbsp;syslog&nbsp;UDP&nbsp;传输到&nbsp;SQL&nbsp;数据库中。网页中为计时添加&nbsp;header，这样就可以通过&nbsp;HAProxy&nbsp;来捕获并且融合到&nbsp;syslog&nbsp;传输中。\nOpserver&nbsp;和&nbsp;Realog&nbsp;用于显示测量结果。Realog&nbsp;是一个日志展示系统，由&nbsp;Kyle&nbsp;Brandt&nbsp;和&nbsp;Matt&nbsp;Jibson&nbsp;使用&nbsp;Go&nbsp;建立。\n日志通过&nbsp;HAProxy&nbsp;负载均衡器借助&nbsp;syslog&nbsp;完成，而不是&nbsp;IIS，因为其功能比&nbsp;IIS&nbsp;更丰富。关于云还是老生常谈，硬件永远比开发者和有效率的代码便宜。基于木桶效应，速度肯定受限于某个短板，现有的云服务基本上都存在容量和性能限制。\n如果从开始就使用云来建设&nbsp;SO&nbsp;说不定也会达到现在的水准。但毫无疑问的是，如果达到同样的性能，使用云的成本将远远高于自建数据中心。性能至上StackOverflow&nbsp;是个重度的性能控，主页加载的时间永远控制在&nbsp;50&nbsp;毫秒内，当下的响应时间是&nbsp;28&nbsp;毫秒。\n程序员热衷于降低页面加载时间以及提高用户体验。\n每个独立的网络提交都予以计时和记录，这种计量可以弄清楚提升性能需要修改的地方。\n如此低资源利用率的主要原因就是高效的代码。web&nbsp;server&nbsp;的&nbsp;CPU&nbsp;平均利用率在5%&nbsp;到&nbsp;15%&nbsp;之间，内存使用为&nbsp;15.5&nbsp;GB，网络传输在&nbsp;20&nbsp;Mb/s到&nbsp;40&nbsp;Mb/s。SQL&nbsp;服务器的&nbsp;CPU&nbsp;使用率在5%&nbsp;到&nbsp;10%&nbsp;之间，内存使用是&nbsp;365GB，网络传输为&nbsp;100&nbsp;Mb/s到&nbsp;200&nbsp;Mb/s。这可以带来&nbsp;3&nbsp;个好处：给升级留下很大的空间；在严重错误发生时可以保持服务可用；在需要时可以快速回档。学到的知识1.&nbsp;为什么使用&nbsp;MS&nbsp;产品的同时还使用&nbsp;Redis？什么好用用什么，不要做无必要的系统之争，比如&nbsp;C#&nbsp;在&nbsp;Windows&nbsp;机器上运行最好，我们使用&nbsp;IIS；Redis&nbsp;在Linux 机器上可以得到充分发挥，我们使用Linux。2.&nbsp;Overkill&nbsp;即策略。平常的利用率并不能代表什么，当某些特定的事情发生时，比如备份、重建等完全可以将资源使用拉满。3.&nbsp;坚固的&nbsp;SSD。所有数据库都建立在&nbsp;SSD&nbsp;之上，这样可以获得&nbsp;0&nbsp;延时。4.&nbsp;了解你的读写负载。5.&nbsp;高效的代码意味着更少的主机。只有新项目上线时才会因为特殊需求增加硬件，通常情况下是添加内存，但在此之外，高效的代码就意味着&nbsp;0&nbsp;硬件添加。所以经常只讨论两个问题：为存储增加新的&nbsp;SSD；为新项目增加硬件。6.&nbsp;不要害怕定制化。SO&nbsp;在&nbsp;Tag&nbsp;上使用复杂查询，因此专门开发了所需的&nbsp;Tag Engine。7.&nbsp;只做必须做的事情。之所以不需要测试是因为有一个活跃的社区支撑，比如，开发者不用担心出现“Square Wheel”效应，如果开发者可以制作一个更更轻量级的组件，那就替代吧。8.&nbsp;注重硬件知识，比如&nbsp;IL。一些代码使用&nbsp;IL&nbsp;而不是C#。聚焦&nbsp;SQL&nbsp;查询计划。使用&nbsp;web server&nbsp;的内存转储究竟做了些什么。探索，比如为什么一个&nbsp;split&nbsp;会产生&nbsp;2GB&nbsp;的垃圾。9.&nbsp;切勿官僚作风。总有一些新的工具是你需要的，比如，一个编辑器，新版本的&nbsp;Visual Studio，降低提升过程中的一切阻力。10.&nbsp;垃圾回收驱动编程。SO&nbsp;在减少垃圾回收成本上做了很多努力，跳过类似&nbsp;TDD&nbsp;的实践，避免抽象层，使用静态方法。虽然极端，但是确实打造出非常高效的代码。11.&nbsp;高效代码的价值远远超出你想象，它可以让硬件跑的更快，降低资源使用，切记让代码更容易被程序员理解。",
    "postDate": "2019-01-30T23:40:45.3392774+08:00",
    "email": "admin@masuit.com",
    "label": "网站优化",
    "keyword": null,
    "id": 60,
    "indexId": "Post:60"
  },
  {
    "title": "又一前端神级类库——lodash.js工具库",
    "author": "懒得勤快",
    "content": "你还在为JavaScript中的数据转换、匹配、查找等烦恼吗？一堆看似简单的foreach，却冗长无趣，可仍还在不停的DRY！也许你已经用上了Underscore.js，不错，你已经进步很大一步了。然而今天我希望你能更进一步，利用lodash替换掉Underscore。有多年开发经验的工程师，往往都会有自己的一套工具库，称为 utils、helpers、tools 等等，这套库一方面是自己的技术积累，另一方面也是对某项技术的扩展，领先于技术规范的制定和实现。Lodash 就是这样的一套工具库，它就像jquery一样，也属于是功能型的插件，它内部封装了诸多对字符串、数组、对象等常见数据类型的处理函数，其中部分是目前 ECMAScript 尚未制定的规范，但同时被业界所认可的辅助函数。目前每天使用 npm 安装 Lodash 的数量在百万级以上，这在一定程度上证明了其代码的健壮性，值得我们在项目中一试。lodash一开始是Underscore.js库的一个fork，因为和其他(Underscore.js的)贡献者意见相左。John-David Dalton的最初目标，是提供更多“一致的跨浏览器行为……，并改善性能”。之后，该项目在现有成功的基础之上取得了更大的成果。最近lodash也发布了3.5版，成为了npm包仓库中依赖最多的库。它正在摆脱屌丝身份，成为开发者的常规的选择之一。现在我们所熟知的很多开源项目都已经使用或者转到了lodash阵营之上。比如JavaScript转译器Babel、博客平台Ghost，和项目脚手架工具Yeoman。特别Ghost是从Underscore迁移到了lodash，Ghost的创始人John O’Nolan对于此曾评价到：“这是一个非常明智的选择，它几乎完全是由我们开源开发社区推动的。我们发现lodash包含更多的功能，更好的性能、恰到好处地使用了semver，并且在Node.js社区（以及其他依赖）中越来越抢眼“。模块组成Lodash 提供的辅助函数主要分为以下几类，函数列表和用法实例请查看&nbsp;Lodash 的官方文档：Array，适用于数组类型，比如填充数据、查找元素、数组分片等操作Collection，适用于数组和对象类型，部分适用于字符串，比如分组、查找、过滤等操作Function，适用于函数类型，比如节流、延迟、缓存、设置钩子等操作Lang，普遍适用于各种类型，常用于执行类型判断和类型转换Math，适用于数值类型，常用于执行数学运算Number，适用于生成随机数，比较数值与数值区间的关系Object，适用于对象类型，常用于对象的创建、扩展、类型转换、检索、集合等操作Seq，常用于创建链式调用，提高执行性能（惰性计算）String，适用于字符串类型lodash/fp&nbsp;模块提供了更接近函数式编程的开发方式，其内部的函数经过包装，具有 immutable、auto-curried、iteratee-first、data-last（官方介绍）等特点。Lodash 在&nbsp;GitHub Wiki&nbsp;中对 lodash/fp 的特点做了如下概述：Fixed Arity，固化参数个数，便于柯里化Rearragned Arguments，重新调整参数位置，便于函数之间的聚合Capped Iteratee Argument，封装 Iteratee 参数New MethodsIn functional programming, an iteratee is a composable abstraction for incrementally processing sequentially presented chunks of input data in a purely functional fashion. With iteratees, it is possible to lazily transform how a resource will emit data, for example, by converting each chunk of the input to uppercase as they are retrieved or by limiting the data to only the five first chunks without loading the whole input data into memory. Iteratees are also responsible for opening and closing resources, providing predictable resource management. ————&nbsp;iteratee, wikipedia//&nbsp;The&nbsp;`lodash/map`&nbsp;iteratee&nbsp;receives&nbsp;three&nbsp;arguments:\n//&nbsp;(value,&nbsp;index|key,&nbsp;collection)\n_.map([&#39;6&#39;,&nbsp;&#39;8&#39;,&nbsp;&#39;10&#39;],&nbsp;parseInt);\n//&nbsp;→&nbsp;[6,&nbsp;NaN,&nbsp;2]\n\n//&nbsp;The&nbsp;`lodash/fp/map`&nbsp;iteratee&nbsp;is&nbsp;capped&nbsp;at&nbsp;one&nbsp;argument:\n//&nbsp;(value)\nfp.map(parseInt)([&#39;6&#39;,&nbsp;&#39;8&#39;,&nbsp;&#39;10&#39;]);\n//&nbsp;→&nbsp;[6,&nbsp;8,&nbsp;10]\n\n\n//&nbsp;`lodash/padStart`&nbsp;accepts&nbsp;an&nbsp;optional&nbsp;`chars`&nbsp;param.\n_.padStart(&#39;a&#39;,&nbsp;3,&nbsp;&#39;-&#39;)\n//&nbsp;→&nbsp;&#39;--a&#39;\n\n//&nbsp;`lodash/fp/padStart`&nbsp;does&nbsp;not.\nfp.padStart(3)(&#39;a&#39;);\n//&nbsp;→&nbsp;&#39;&nbsp;&nbsp;a&#39;\nfp.padCharsStart(&#39;-&#39;)(3)(&#39;a&#39;);\n//&nbsp;→&nbsp;&#39;--a&#39;\n\n\n//&nbsp;`lodash/filter`&nbsp;is&nbsp;data-first&nbsp;iteratee-last:\n//&nbsp;(collection,&nbsp;iteratee)\nvar&nbsp;compact&nbsp;=&nbsp;_.partial(_.filter,&nbsp;_,&nbsp;Boolean);\ncompact([&#39;a&#39;,&nbsp;null,&nbsp;&#39;c&#39;]);\n//&nbsp;→&nbsp;[&#39;a&#39;,&nbsp;&#39;c&#39;]\n\n//&nbsp;`lodash/fp/filter`&nbsp;is&nbsp;iteratee-first&nbsp;data-last:\n//&nbsp;(iteratee,&nbsp;collection)\nvar&nbsp;compact&nbsp;=&nbsp;fp.filter(Boolean);\ncompact([&#39;a&#39;,&nbsp;null,&nbsp;&#39;c&#39;]);\n//&nbsp;→&nbsp;[&#39;a&#39;,&nbsp;&#39;c&#39;]在 React + Webpack + Babel(ES6) 的开发环境中，使用 Lodash 需要安装插件&nbsp;babel-plugin-lodash&nbsp;并更新 Babel 配置文件：npm&nbsp;install&nbsp;--save&nbsp;lodash\nnpm&nbsp;install&nbsp;--save-dev&nbsp;babel-plugin-lodash更新 Babel 的配置文件&nbsp;.babelrc:{\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;presets&quot;:&nbsp;[\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;react&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;es2015&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;stage-0&quot;\n&nbsp;&nbsp;&nbsp;&nbsp;],\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;plugins&quot;:&nbsp;[\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;lodash&quot;\n&nbsp;&nbsp;&nbsp;&nbsp;]\n}使用方式：import&nbsp;_&nbsp;from&nbsp;&#39;lodash&#39;;\nimport&nbsp;{&nbsp;add&nbsp;}&nbsp;from&nbsp;&#39;lodash/fp&#39;;\n\nconst&nbsp;addOne&nbsp;=&nbsp;add(1);\n_.map([1,&nbsp;2,&nbsp;3],&nbsp;addOne);性能lodash主要使用了延迟计算，使得lodash其性能远远超过Underscore。在lodash中延迟计算意味着在我们的链式方法在显示或隐式的value()调用之前是不会执行的。由于这种执行的延后，因此lodash可以进行shortcut fusion这样的优化，通过合并链式iteratee大大降低迭代的次数。从而大大提供其执行性能。在 Filip Zawada 的文章《How to Speed Up Lo-Dash ×100? Introducing Lazy Evaluation》&nbsp;中提到了 Lodash 提高执行速度的思路，主要有三点：Lazy Evaluation、Pipelining 和 Deferred Execution。下面两张图来自 Filip 的博客：假设有如上图所示的问题：从若干个球中取出三个面值小于 10 的球。第一步是从所有的球中取出所有面值小于 10 的球，第二步是从上一步的结果取三个球。上图是另一种解决方案，如果一个球能够通过第一步，那么就继续执行第二步，直至结束然后测试下一个球……当我们取到三个球之后就中断整个循环。Filip 称这是 Lazy Evaluation Algorithm，就个人理解这并不全面，他后续提到的 Pipelining(管道计算)，再加上一个中断循环执行的算法应该更符合这里的图示。此外，使用 Lodash 的链式调用时，只有显示或隐式调用&nbsp;.value&nbsp;方法才会对链式调用的整个操作进行取值，这种不在声明时立即求值，而在使用时求值的方式，是 Lazy Evaluation 最大的特点。九个基础实例受益于 Lodash 的普及程度，使用它可以提高多人开发时阅读代码的效率，减少彼此之间的误解（Loss of Consciousness）。在《Lodash: 10 Javascript Utility Functions That You Should Probably Stop Rewriting》一文中，作者列举了多个常用的 Lodash 函数，实例演示了使用 Lodash 的技巧。1. N 次循环//&nbsp;1.&nbsp;Basic&nbsp;for&nbsp;loop.\nfor(var&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;5;&nbsp;i++)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...\n}\n\n//&nbsp;2.&nbsp;Using&nbsp;Array&#39;s&nbsp;join&nbsp;and&nbsp;split&nbsp;methods\nArray.apply(null,&nbsp;Array(5)).forEach(function(){\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...\n});\n\n//&nbsp;Lodash\n_.times(5,&nbsp;function(){\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...\n});for&nbsp;语句是执行循环的不二选择，Array.apply&nbsp;也可以模拟循环，但在上面代码的使用场景下，_.times()&nbsp;的解决方式更加简洁和易于理解。2. 深层查找属性值//&nbsp;Fetch&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;first&nbsp;pet&nbsp;from&nbsp;each&nbsp;owner\nvar&nbsp;ownerArr&nbsp;=&nbsp;[{\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;owner&quot;:&nbsp;&quot;Colin&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;pets&quot;:&nbsp;[{&quot;name&quot;:&quot;dog1&quot;},&nbsp;{&quot;name&quot;:&nbsp;&quot;dog2&quot;}]\n},&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;owner&quot;:&nbsp;&quot;John&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;pets&quot;:&nbsp;[{&quot;name&quot;:&quot;dog3&quot;},&nbsp;{&quot;name&quot;:&nbsp;&quot;dog4&quot;}]\n}];\n\n//&nbsp;Array&#39;s&nbsp;map&nbsp;method.\nownerArr.map(function(owner){\n&nbsp;&nbsp;&nbsp;return&nbsp;owner.pets[0].name;\n});\n\n//&nbsp;Lodash\n_.map(ownerArr,&nbsp;&#39;pets[0].name&#39;);_.map&nbsp;方法是对原生&nbsp;map&nbsp;方法的改进，其中使用&nbsp;pets[0].name&nbsp;字符串对嵌套数据取值的方式简化了很多冗余的代码，非常类似使用 jQuery 选择 DOM 节点&nbsp;ul &gt; li &gt; a，对于前端开发者来说有种久违的亲切感。3. 个性化数组//&nbsp;Array&#39;s&nbsp;map&nbsp;method.\nArray.apply(null,&nbsp;Array(6)).map(function(item,&nbsp;index){\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;ball_&quot;&nbsp;+&nbsp;index;\n});\n\n//&nbsp;Lodash\n_.times(6,&nbsp;_.uniqueId.bind(null,&nbsp;&#39;ball_&#39;));\n\n//&nbsp;Lodash\n_.times(6,&nbsp;_.partial(_.uniqueId,&nbsp;&#39;ball_&#39;));\n//&nbsp;eg.&nbsp;[ball_0,&nbsp;ball_1,&nbsp;ball_2,&nbsp;ball_3,&nbsp;ball_4,&nbsp;ball_5]在上面的代码中，我们要创建一个初始值不同、长度为 6 的数组，其中&nbsp;_.uniqueId&nbsp;方法用于生成独一无二的标识符（递增的数字，在程序运行期间保持独一无二），_partial方法是对&nbsp;bind&nbsp;的封装。4. 深拷贝var&nbsp;objA&nbsp;=&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;name&quot;:&nbsp;&quot;colin&quot;\n}\n\n//&nbsp;Normal&nbsp;method?&nbsp;Too&nbsp;long.&nbsp;See&nbsp;Stackoverflow&nbsp;for&nbsp;solution:\n//&nbsp;http://stackoverflow.com/questions/4459928/how-to-deep-clone-in-javascript\n\n//&nbsp;Lodash\nvar&nbsp;objB&nbsp;=&nbsp;_.cloneDeep(objA);\nobjB&nbsp;===&nbsp;objA&nbsp;//&nbsp;falseJavaScript 没有直接提供深拷贝的函数，但我们可以用其他函数来模拟，比如&nbsp;JSON.parse(JSON.stringify(objectToClone))，但这种方法要求对象中的属性值不能是函数。Lodash 中的&nbsp;_.cloneDeep&nbsp;函数封装了深拷贝的逻辑，用起来更加简洁。5. 随机数//&nbsp;Naive&nbsp;utility&nbsp;method\nfunction&nbsp;getRandomNumber(min,&nbsp;max){\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Math.floor(Math.random()&nbsp;*&nbsp;(max&nbsp;-&nbsp;min&nbsp;+&nbsp;1))&nbsp;+&nbsp;min;\n}\n\ngetRandomNumber(15,&nbsp;20);\n\n//&nbsp;Lodash\n_.random(15,&nbsp;20);Lodash 的随机数生成函数更贴近实际开发，ECMAScript 的随机数生成函数是底层必备的接口，两者都不可或缺。此外，使用&nbsp;_.random(15, 20, true)&nbsp;还可以在 15 到 20 之间生成随机的浮点数。6. 对象扩展//&nbsp;Adding&nbsp;extend&nbsp;function&nbsp;to&nbsp;Object.prototype\nObject.prototype.extend&nbsp;=&nbsp;function(obj)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(var&nbsp;i&nbsp;in&nbsp;obj)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(obj.hasOwnProperty(i))&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this[i]&nbsp;=&nbsp;obj[i];\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n};\n\nvar&nbsp;objA&nbsp;=&nbsp;{&quot;name&quot;:&nbsp;&quot;colin&quot;,&nbsp;&quot;car&quot;:&nbsp;&quot;suzuki&quot;};\nvar&nbsp;objB&nbsp;=&nbsp;{&quot;name&quot;:&nbsp;&quot;james&quot;,&nbsp;&quot;age&quot;:&nbsp;17};\n\nobjA.extend(objB);\nobjA;&nbsp;//&nbsp;{&quot;name&quot;:&nbsp;&quot;james&quot;,&nbsp;&quot;age&quot;:&nbsp;17,&nbsp;&quot;car&quot;:&nbsp;&quot;suzuki&quot;};\n\n//&nbsp;Lodash\n_.assign(objA,&nbsp;objB);_.assign&nbsp;是浅拷贝，和 ES6 新增的&nbsp;Ojbect.assign&nbsp;函数功能一致（建议优先使用&nbsp;Object.assign）。7. 筛选属性//&nbsp;Naive&nbsp;method:&nbsp;Remove&nbsp;an&nbsp;array&nbsp;of&nbsp;keys&nbsp;from&nbsp;object\nObject.prototype.remove&nbsp;=&nbsp;function(arr)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;that&nbsp;=&nbsp;this;\n&nbsp;&nbsp;&nbsp;&nbsp;arr.forEach(function(key){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete(that[key]);\n&nbsp;&nbsp;&nbsp;&nbsp;});\n};\n\nvar&nbsp;objA&nbsp;=&nbsp;{&quot;name&quot;:&nbsp;&quot;colin&quot;,&nbsp;&quot;car&quot;:&nbsp;&quot;suzuki&quot;,&nbsp;&quot;age&quot;:&nbsp;17};\n\nobjA.remove([&#39;car&#39;,&nbsp;&#39;age&#39;]);\nobjA;&nbsp;//&nbsp;{&quot;name&quot;:&nbsp;&quot;colin&quot;}\n\n//&nbsp;Lodash\nobjA&nbsp;=&nbsp;_.omit(objA,&nbsp;[&#39;car&#39;,&nbsp;&#39;age&#39;]);\n//&nbsp;=&gt;&nbsp;{&quot;name&quot;:&nbsp;&quot;colin&quot;}\nobjA&nbsp;=&nbsp;_.omit(objA,&nbsp;&#39;car&#39;);\n//&nbsp;=&gt;&nbsp;{&quot;name&quot;:&nbsp;&quot;colin&quot;,&nbsp;&quot;age&quot;:&nbsp;17};\nobjA&nbsp;=&nbsp;_.omit(objA,&nbsp;_.isNumber);\n//&nbsp;=&gt;&nbsp;{&quot;name&quot;:&nbsp;&quot;colin&quot;};大多数情况下，Lodash 所提供的辅助函数都会比原生的函数更贴近开发需求。在上面的代码中，开发者可以使用数组、字符串以及函数的方式筛选对象的属性，并且最终会返回一个新的对象，中间执行筛选时不会对旧对象产生影响。//&nbsp;Naive&nbsp;method:&nbsp;Returning&nbsp;a&nbsp;new&nbsp;object&nbsp;with&nbsp;selected&nbsp;properties\nObject.prototype.pick&nbsp;=&nbsp;function(arr)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;_this&nbsp;=&nbsp;this;\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;obj&nbsp;=&nbsp;{};\n&nbsp;&nbsp;&nbsp;&nbsp;arr.forEach(function(key){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj[key]&nbsp;=&nbsp;_this[key];\n&nbsp;&nbsp;&nbsp;&nbsp;});\n\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;obj;\n};\n\nvar&nbsp;objA&nbsp;=&nbsp;{&quot;name&quot;:&nbsp;&quot;colin&quot;,&nbsp;&quot;car&quot;:&nbsp;&quot;suzuki&quot;,&nbsp;&quot;age&quot;:&nbsp;17};\n\nvar&nbsp;objB&nbsp;=&nbsp;objA.pick([&#39;car&#39;,&nbsp;&#39;age&#39;]);\n//&nbsp;{&quot;car&quot;:&nbsp;&quot;suzuki&quot;,&nbsp;&quot;age&quot;:&nbsp;17}\n\n//&nbsp;Lodash\nvar&nbsp;objB&nbsp;=&nbsp;_.pick(objA,&nbsp;[&#39;car&#39;,&nbsp;&#39;age&#39;]);\n//&nbsp;{&quot;car&quot;:&nbsp;&quot;suzuki&quot;,&nbsp;&quot;age&quot;:&nbsp;17}_.pick&nbsp;是&nbsp;_.omit&nbsp;的相反操作，用于从其他对象中挑选属性生成新的对象。8. 随机元素var&nbsp;luckyDraw&nbsp;=&nbsp;[&quot;Colin&quot;,&nbsp;&quot;John&quot;,&nbsp;&quot;James&quot;,&nbsp;&quot;Lily&quot;,&nbsp;&quot;Mary&quot;];\n\nfunction&nbsp;pickRandomPerson(luckyDraw){\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;index&nbsp;=&nbsp;Math.floor(Math.random()&nbsp;*&nbsp;(luckyDraw.length&nbsp;-1));\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;luckyDraw[index];\n}\n\npickRandomPerson(luckyDraw);&nbsp;//&nbsp;John\n\n//&nbsp;Lodash\n_.sample(luckyDraw);&nbsp;//&nbsp;Colin\n\n//&nbsp;Lodash&nbsp;-&nbsp;Getting&nbsp;2&nbsp;random&nbsp;item\n_.sample(luckyDraw,&nbsp;2);&nbsp;//&nbsp;[&#39;John&#39;,&#39;Lily&#39;]_.sample&nbsp;支持随机挑选多个元素并返回心的数组。9. 针对 JSON.parse 的错误处理//&nbsp;Using&nbsp;try-catch&nbsp;to&nbsp;handle&nbsp;the&nbsp;JSON.parse&nbsp;error\nfunction&nbsp;parse(str){\n&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;JSON.parse(str);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;catch(e)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n\n//&nbsp;With&nbsp;Lodash\nfunction&nbsp;parseLodash(str){\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;_.attempt(JSON.parse.bind(null,&nbsp;str));\n}\n\nparse(&#39;a&#39;);\n//&nbsp;=&gt;&nbsp;false\nparseLodash(&#39;a&#39;);\n//&nbsp;=&gt;&nbsp;Return&nbsp;an&nbsp;error&nbsp;object\n\nparse(&#39;{&quot;name&quot;:&nbsp;&quot;colin&quot;}&#39;);\n//&nbsp;=&gt;&nbsp;Return&nbsp;{&quot;name&quot;:&nbsp;&quot;colin&quot;}\nparseLodash(&#39;{&quot;name&quot;:&nbsp;&quot;colin&quot;}&#39;);\n//&nbsp;=&gt;&nbsp;Return&nbsp;{&quot;name&quot;:&nbsp;&quot;colin&quot;}如果你在使用&nbsp;JSON.parse&nbsp;时没有预置错误处理，那么它很有可能会成为一个定时炸弹，我们不应该默认接收的 JSON 对象都是有效的。try-catch&nbsp;是最常见的错误处理方式，如果项目中 Lodash，那么可以使用&nbsp;_.attmpt&nbsp;替代&nbsp;try-catch&nbsp;的方式，当解析 JSON 出错时，该方法会返回一个&nbsp;Error&nbsp;对象。随着 ES6 的普及，Lodash 的功能或多或少会被原生功能所替代，所以使用时还需要进一步甄别，建议优先使用原生函数，有关 ES6 替代 Lodash 的部分，请参考文章《10 Lodash Features You Can Replace with ES6》（中文版《10 个可用 ES6 替代的 Lodash 特性》）。其中有两处非常值得一看：//&nbsp;使用箭头函数创建可复用的路径\nconst&nbsp;object&nbsp;=&nbsp;{&nbsp;&#39;a&#39;:&nbsp;[{&nbsp;&#39;b&#39;:&nbsp;{&nbsp;&#39;c&#39;:&nbsp;3&nbsp;}&nbsp;},&nbsp;4]&nbsp;};\n\n[\n&nbsp;&nbsp;&nbsp;&nbsp;obj&nbsp;=&gt;&nbsp;obj.a[0].b.c,\n&nbsp;&nbsp;&nbsp;&nbsp;obj&nbsp;=&gt;&nbsp;obj.a[1]\n].map(path&nbsp;=&gt;&nbsp;path(object));\n\n//&nbsp;使用箭头函数编写链式调用\nconst&nbsp;pipe&nbsp;=&nbsp;functions&nbsp;=&gt;&nbsp;data&nbsp;=&gt;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;functions.reduce(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(value,&nbsp;func)&nbsp;=&gt;&nbsp;func(value),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data\n&nbsp;&nbsp;&nbsp;&nbsp;);\n};\n\nconst&nbsp;pipeline&nbsp;=&nbsp;pipe([\n&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&gt;&nbsp;x&nbsp;*&nbsp;2,\n&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&gt;&nbsp;x&nbsp;/&nbsp;3,\n&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&gt;&nbsp;x&nbsp;&gt;&nbsp;5,\n&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&gt;&nbsp;!b\n]);\n\npipeline(5);\n//&nbsp;true\npipeline(20);\n//&nbsp;false在 ES6 中，如果一个函数只接收一个形参且函数体是一个&nbsp;return&nbsp;语句，就可以使用箭头函数简化为：const&nbsp;func&nbsp;=&nbsp;p&nbsp;=&gt;&nbsp;v;\n\n//&nbsp;类似于(不完全相同)\nconst&nbsp;func&nbsp;=&nbsp;function&nbsp;(p)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;v;\n}当有多重嵌套时，可以简化为：const&nbsp;func&nbsp;=&nbsp;a&nbsp;=&gt;&nbsp;b&nbsp;=&gt;&nbsp;c&nbsp;=&gt;&nbsp;a&nbsp;+&nbsp;b&nbsp;+&nbsp;c;\nfunc(1)(2)(3);\n//&nbsp;=&gt;&nbsp;6\n\n//&nbsp;类似于\nconst&nbsp;func&nbsp;=&nbsp;function&nbsp;(a)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;function&nbsp;(b)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;function&nbsp;(e)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a&nbsp;+&nbsp;b&nbsp;+&nbsp;c;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}参考资料Lodash 官方文档Lodash中文文档Lodash FP Guidebabel-plugin-lodashHow to Speed Up Lo-Dash ×100? Introducing Lazy EvaluationLodash: 10 Javascript Utility Functions That You Should Probably Stop Rewriting10 Lodash Features You Can Replace with ES6Lodash: 10 Javascript Utility Functions That You Should Probably Stop Rewriting",
    "postDate": "2019-01-30T23:40:45.3393394+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": null,
    "id": 102,
    "indexId": "Post:102"
  },
  {
    "title": "这些年流传甚广的硬件伪知识",
    "author": "懒得勤快",
    "content": "在这个神奇的星球中，有一个笼络地球人的圈子，叫虚拟社区。匿名的性质，看热闹不怕事大的心态，让你可以畅所欲言，甚至口无遮拦。更有不少人当作你人生导师，“转了才是中国人”。于是，谣言满天飞，谁能分李逵？好了不扯远了。我们痛恨加钱党、经验党、语言艺术家、直播吃翔家，更痛恨一切误导DIY的所有理论，更痛惜那些小白们信以为真的“伪知识”。所以，有必要整理一下目前在新手中流传甚广的“伪知识”，让大家知道真相。伪知识之一：i7&gt;i5&gt;i3Intel将旗下的主流CPU分为Core i7/i5/i3三个档次，方便消费者尤其是小白玩家区分不同CPU。但是，有很多朋友都把它绝对化了。不信？看看以下的例子。先入为主者，会一定认为i7&gt;i5&gt;i3某玩家因看上了某游戏国服推出而兴致勃勃地去电脑城、逛电商，想配一台游戏性能不错的电脑。看到电商铺天盖地的游戏本广告，联想到现在火热的游戏本概念，并且一看价格还说得过去，于是掏包买下了。高高兴兴收货，看着腕托的i7标志虚荣心爆棚。殊不知，对比网上的某i5性能，却差了一大截，于是大失所望，甚是难堪。部分所谓的i7游戏本，却采用了低TDP的i7 CPU，还卖高端价格这就是Intel释放的数字陷阱。不要以为Core i7就是九五之尊、绝无敌手。要知道，笔记本CPU由于要照顾节能省电与耗能发热，所以TDP都做得比较低。目前即使是Extreme级别的移动四核CPU频率最高仅有3.1GHz默认频率，却只有现在的桌面版Core i5 CPU的水平，但是前者的价格都能买到一款LGA 2011的顶级CPU了。知道真相的你，是否觉得低TDP i7是一个骗局？此外，Core i7的另一个陷阱就是笔记本平台i7处理器包含了双核的版本，尤其是Core i7 4500U这类节能版双核四线程的CPU，实际性能只能放在桌面版的Core i3档次，甚至比上一代的i5-3210M更差。所以一旦你被所谓的超薄游戏本的美丽谎言魅惑了，那吃亏的只有你。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;低TDP不仅存在显示器，更有桌面级，需要留意当然，只考虑桌面CPU也需要注意功耗问题，因为全系列Core处理器有一种低电压，低功耗，低性能的版本，以S、T结尾，如Core i7-4790S，实际性能只和普通版本的Core i5差不多，但是价格却实实在在是i7的水平。所以，别看Core i7就是7大于5了，Intel可不会管你细节问题，还是自己做好功课最实际。点评：不要问为什么Intel放那么多数字炸弹，多关注CPU的性能评测、多看Intel官方的规格对比，自己才不会中了数字伪科学的套。伪知识之二：Haswell只支持DDR3L内存2013年Haswell平台推出之时，Intel就进行了不少变革，除了将接口改成与前任不兼容的LGA 1150外，更值得注意的一点就是DDR3内存的支持上，Haswell CPU只支持DDR3L内存，也就是电压为1.35V或者1.28V的内存。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于这个观点，大家怎么看呢？但这对于当时市面占统治地位的1.5V DDR3内存来说，岂不是吃了闭门羹了？于是网友纷纷网上咨询将来购买Haswell平台后，自己的旧1.5V标准电压是否支持。结果答案不一，而一些品牌官方、科普杂志都给出了明显的答案：“对Haswell新品而言，选择内存一定要用DDR3L标准”。实际上，这是伪知识。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小编实践，1.35V与1.5V电压是可以共存的第一，小编就曾以身试法，把自己的地球人Haswell笔记本装上了一条1.35V内存以及1.5V内存，结果从2014年10月到2015年5月的今天，从未出现一次死机、蓝屏的问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果CPU对内存的电压有严格的限制，那么内存超频怎么解释？第二，如果CPU对内存的电压有严格的限制，那么内存超频怎么解释？CPU的IMC/VTT是CPU自身内存控制器对内存的命令，但是内存本身有一套电压控制，所以在BIOS设置中我们会看到有VTT以及内存的两种设置。所以，内存加压超频，就是看自己电压，并不看IMC/VTT，这只是内存控制器对内存发出的频率、电压等指令而已。所以，内存加压只要在内存自身体质范围内，怎么调也没问题，Haswell严格控制内存电压是不可能的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上内存电压受SPD以及主板决定第三，内存的电压支持，是受主板的内存决定的。内存本身的SPD是有一套电压控制指令，遇到什么类型的平台就会自适应不同电压。如1.35V内存在旧平台会自动适应到1.5V。而如果主板对1.35V的支持不足，比如某些很旧的主板，如果BIOS没有支持1.35V的支持的指令，那才会出现兼容性问题。但实际上，这种情况对于现在的笔记本或者桌面平台来讲，已经比较罕见。点评：我们在装机时，不需要纠结于内存电压问题，本来现在PC的兼容性已经做得很好。我们更应当注意不同DDR3内存之间的频率问题，避免出现1333与1600混插的情况。伪知识之三：128bit反人类&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于GTX960的128bit显存位宽的吐槽作为新一代的“甜点产品”，GTX960诞生以来虽然获得了相当不错的销售成绩，但是关于其128bit显存位宽的各种争论始终没有停息过，绝大多数网友的都是表示吃惊和愤怒的，在他们看来，128bit等于反人类，尤其是千元级别的产品。很多人还拿对手的R9 280来对比，一比显卡位宽数值上的差距就更加明显了。GTX960的规格难道NV真的这么明目张胆的削减？而且还是每一代整个系列中最重要的X60产品？如果我们拿GTX960的规格和上一代的GTX760做对比的话，位宽大小的差距就更加明显了，难道像网友所说的这真的是个瓶颈？我们之前做了一次测试，假设显存带宽大小成为了瓶颈，那么显存带宽的大小势必会成为直接左右成绩的因素，也就是说显存频率提升10%，那么你成绩的提升幅度至少要在8-10%左右才比较合理。而目前的差距只有3%，这个成绩与其他显卡，甚至是竞争对手的显卡相比也是不相上下的，最终我们可以得出一个结论：128bit显存位宽并不是GTX960的性能瓶颈。那么为什么GTX960只配128bit？原因只有三个字——够用了，芯片的设计之初就已经将核心在运算时对于显存带宽的需求进行了计算（理论值）。这种计算都是严格而精准的，紧接着他们就会根据目前显存的种类和频率，最终决定核心的位宽。简而言之，位宽的大小在制定之初就是以满足核心为目标的。上一代的760既然都256bit了，那GTX960能够只用上一代一半的位宽呢，这一点我们还是要看看两个NV应用在Maxwell上面的最新技术——显存数据压缩&amp;核心显存读取架构优化。更加先进的显存使用技术的应用使得原来仅为7Gbps的显存芯片可以取得9.3Gbps的等效工作效果，提升幅度已然接近30%，对于显卡性能的充分发挥的作用可想而知。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你纠结一个非最重要的性能参数，那你就输了点评：显存位宽只是决定显存带宽的一个因素，显存容量、频率也是决定性因素，我们很多时候就是为了骂而找话题骂，从来不考虑主次问题。GTX960优秀的显卡架构尤其是完美的性能功耗比，以及丰富的超高频或者4GB大显存非公版，为我们提供了多样化的选择，完全能让128bit的不足抹掉。伪知识之四：“无边框”等于无边框&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今年成为大热的无边框手机在这个炒作的社会，“无边框”成为了今年手机、笔记本电脑、DIY硬件显示器的重点。在性能的竞争、大屏的竞争后，无边框成为了品牌商撕心裂肺的宣传重点。于是，无边框的含义被人为地放大。首先，无边框的确能给人一种耳目而新的视觉效果，很有一种进入未来的感觉，尤其是透明触控的体验让人对无边框手机翘首以待。但是，小编跟你说，无边框的显示器，在目前液晶显示的技术条件下，是不存在的。但凡你使用液晶显示屏，就必定有边框。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;液晶材质必须有有边沿进行封闭为什么？液晶屏幕的本质就是液态的结晶，具有流动性，因此必定要用一定界限的空间限制液晶的流动，必须要有边沿进行封闭，而诸如点胶等技术也被应用到屏幕边框中，其能够把边框收窄的同时减低碎屏的风险。只要是液晶屏幕，那么边缘必定不能少，哪怕是把边框收窄到近乎无边框的效果，边框依然存在，纵使是零点几毫米。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;触摸屏对于屏幕边框是有所依赖的对于触摸屏，都内置了两个单独的电容层来实现手指的精确检测，一个在X轴，一个则在Y轴，对于多点触摸的操作尤为重要。而这种技术对于屏幕边框是有所依赖的，因为需要检测电流变化，需要额外的线路设计在屏幕边框周围，从而实现精确的操作效果，这就是为什么“无边框屏幕”实际上是一种非常困难的技术。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓的无边框显示屏都采用了“视觉欺骗”的方式实际上，目前所谓的无边框显示屏，都采用了“视觉欺骗”的方式来营造“无边框”的视觉效果。如夏普AQUOS CRYSTAL无边框手机利用折射原理，在手机的屏幕面板的边缘进行斜面特殊切割，产生了“镜头”效果，通过光线的折射把玻璃下方面板的黑边“隐藏”起来。这样一来，玻璃的边缘就可以完全覆盖手机的正面，从视觉上给人一种“无边框”的感觉。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与其说无边框，不如说“超超超级窄边框”最近炒得很火的努比亚无边框手机也是采用了类似的原理，只是改成了弧形的设计。但是这类无边框手机，带来的成本提升是不用质疑的，所以这类手机往往带来的是关注度而不是销量。至于PC的液晶显示器，无边框技术在目前是难以实现的，所以黑边的存在是必然的，真正的无边框拼接，只能在睡梦中期待吧。点评：在目前液晶材料的限制下，真正的无边框是不能实现的。“无边框”只是品牌炒作而已。只有新材料的突破，如柔性材料在显示的运用，也许完美的无边框时代才会真的到来。伪知识之五：机械键盘只选樱桃轴&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;樱桃轴长期统治着机械键盘机械轴我们都知道，来自德国的樱桃（Cherry）创造了机械键盘，旗下的黑、红、青、茶四大天王轴体为主体，成为了机械键盘的象征。但随着机械键盘的平民化，越来越多厂商尝试低成本的非樱桃轴。可能是低价带来的既视感，很多玩家都对非樱桃轴机械键盘嗤之以鼻，叫嚣“机械键盘只选樱桃轴”。诚然，在过去那段机械键盘开始普及的阶段。樱桃轴的机械键盘的价格高高在上，而低价的国产轴机械键盘由于各种各样的问题，导致经常出现卡键、失灵、手感有差别等问题。也许是被国产厂商“伤害”过，但网络中有很多人，对于国产产品的黑劲是无穷无尽的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;曾几何时，采用樱桃机械轴是一种荣耀至于樱桃轴本身，由于国人对德国有一种莫名的崇拜，加上Cherry也是原本超过90%的机械键盘轴体的供应商，在机械键盘市场上有着绝对的话语权。所以才让大家有一种机械键盘等于樱桃轴的感觉。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，当樱桃限制输出，外设厂商何去何从然而，2014年开始，Cherry作出了限量供应樱桃轴的决定。既然能闷声发大财，为何樱桃自断财路呢？原因无非是产能问题以及利润控制，还有对自家MX-Board的保护，大家都知道樱桃新一代的6.0机械键盘的推出就是樱桃加强自家技术、轴体、产品一条龙的策略。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;独立自主道路才是王道面对樱桃突如其来的收紧政策，让各大外设厂商一时之间束手无措。但为了自身生存，既然现实已定，再也不能过寄人篱下的生活，那就只能自力更生了。雷蛇携手橙轴和绿轴、罗技携手欧姆龙轴纷纷推出新旗舰。从实际使用体验上看，打破了人们对于樱桃轴只等于高质的迷信。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不断进步的国产轴同时，国产轴体的机械键盘拥有着超高的性价比，而且价格异常实惠，以凯华轴为例，在初期的表现平平，但发展至今，玩家们也是能够看到凯华轴的转变，如今的凯华轴手感相当出色，虽然相比于Cherry还是有些区别，但已经相当接近与Cherry轴，如红轴、黑轴这些无段落感的轴体，体验感受已经不是吴下阿蒙。血手幽灵推出光轴机械键盘则改变了轴体的工作原理，提升轴体的使用寿命同时在手感方面也改变了不少。点评：世事无绝对，随着机械键盘的平民化，机械轴的技术已经十分成熟，加上樱桃自身的限制出口策略，所以我们不需要再对樱桃轴产生迷信。连外设大牌都采用非樱桃轴了，你还想有信仰？赶快看你多少预算就买多少价格的机械键盘吧。伪知识之六：买电源要大功率一步到位以前PC性能还处在高功耗高发热还高性能时，我们就一直被洗脑，电源功率越大越好，功率低的电源就是低质劣质的代名词。一步到位选择大功率电源让你省心，不在担心CPU、主板、显卡的供电问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时代在变，我们的观念也应当变化时代在变，我们的观念也应当变化。比如现在的小核心GPU也能实现多倍于上一代的3D性能，同时获得了不俗的功耗控制效果，打破了大核心的一贯观念。电源的选择也是如此。现在PC走小型化、节能化的道路，所以在电源的选择上，我们更应该复合节能、实用的需求。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;游戏平台再也不是以高功耗为代价整机的电源需要多少瓦，应该要考虑使用者应用电脑的主要用途。一套一模一样的家用主流Core i3或者i5+GTX960配置，平时上网看看在线视频时平台功耗75都不用，而看高清解码的视频也就100W左右，玩大型游戏也不过200W，只有那些骨灰级玩家进行CPU以及GPU百分百满载时才用到最高的功率，但这种情况对于普通玩家来讲是少之又少的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并不需要一味的选择超大功率的电源所以，我们需要根据不同的适用人群来选择不同的电源。我们并不需要一味的选择超大功率的电源，以免大材小用。并且，目前的芯片走节能的道理，我们也不需要担心将来升级硬件可能出现的功率提升的问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选择电源时候更加应该考虑电源自身的质量反而，选择电源时候更加应该考虑电源自身的质量，如认证电源、主动PFC、内部用料等方面才是购买电源管家需要关注的。如果你对这些参数不熟悉，那么选择品牌信誉度高的电源，是一个省心的选择。点评：如果你有钱可以任性，那么大功率的电源你可以随便选。不过如果你是一个精打细算的DIYer，那么就要好好考量电源选择的技巧了。伪知识之七：电脑的电池容量比手机的小随着时代的发展，移动充电设备也进入了人们的生活，随之也有了笔记本的移动电源，很多人都很看重移动电源的容量这个参数，但是，你觉得容量是衡量移动电源能量的一个标准吗？对于这个问题，很多人以为自己学了点物理，在买笔记本的时候，看到笔记本的电池容量才2000多mAh，自己的手机电池容量都3000多mAh，就一口咬定笔记本的电池还没得手机的电池大！总爱咬着不放。小编我在此就先给大家纠正一下这个问题，然后再进行详解，电池的容量就是存储电能的多少，不是电荷量，电荷量是衡量电容这个元器件的，不是衡量电池的；电池容量的标准单位理论上应该是W·h，而不应该是mAh，只是我们日常惯用mAh来衡量电池容量而已。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;华硕a550JK4710电池信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;魅族MX5电池信息而今手机电脑都普及了，我觉得电池容量的单位也应该标注为W·h而不应该再用mAh了。现在，我就带大家来详细的探讨一下这个问题。首先还是给你们补习一下初中物理知识：计算电能和电功率的基本公式：其中：W代表的是电能，单位是焦耳，符号J；P代表的是功率，单位是瓦特，符号W；U代表的是电源的电压，单位是伏特，符号V；I代表的是输送的电流强度，单位是安培(毫安)，符号A(mA)；t代表的是输送电能的时间，单位是小时(*)，符号h。(*)&nbsp;&nbsp;这里用小时做单位方便于计算，探究这个问题这里就不用国际单位秒了。也就是说，电能的基本单位是：伏安时(V·A·h),而伏安(V·A)又恰好是瓦(W)，所以电能的基本单位又可以表示成瓦·时(W·h)。而我们经常所说的毫安·时(mAh)呢，别急，先来解析一下这个单位，mA代表的是电流I，h代表的是时间t，也就是说这个单位的原公式是I·t，我想请问，I·t到底是计算什么的？q=I·t计算电荷量的啊，亲，不代表电池的容量，计算电池容量怎么能少了电压U呢？！笔记本的电压和手机是不一样的，笔记本是19V啊，手机才5V啊。先拿一个移动电源来说，我有一个50000mAh的笔记本和手机两用的移动电源，那么，你要算具体对手机或电脑供电的时间的话，用这个50000mAh来计算是不正确的，这个50000mAh仅仅是对于5V输出而言的，也就是说这个移动电源按5V-50A输出的话，1个小时电能耗尽；对于电脑，就不一样了如果对电脑你还是按这个来算的话，算出来的结果有点惊人，大概估一下，对电脑供电8个小时，你觉得可能吗？！说的不好听一点，就是移动电源制造商对我们老百姓耍的又一个数字游戏。要计算移动电源的供电，首先，你得明确你手机的电压(5V不用说)和电流，你电脑的电压和输入功率，对于手机，假如你的手机是USB输入2A的电流，那么你手机输入功率就是10W，又假如你的电脑的电压是19V，输入功率为120W，现在先来计算一下移动电源的电能：W=UIt=5V&nbsp;x&nbsp;50A&nbsp;x&nbsp;1h=250W·h，也就是，这个移动电源按250W的恒定功率输出，1个小时电量就耗尽。好，现在分别来计算给手机和电脑的供电：对手机：t=W/P=250W·h&nbsp;÷&nbsp;10W≈25h对电脑：t=W/P=250W·h&nbsp;÷&nbsp;120W≈2h为什么我都要用约等而不用等号，是因为移动电源在供电的过程中本身有电能损耗和它自身需要保留一定的电能底限以延长使用寿命，实际供电不会达到上面的理想值，能量的转化大概只有80%。对于机器内置的电池而言呢，假如你手机的电池是3000mAh，你电脑的电池是2600mAh，现在来比较一下它们的容量：手机：W=UIt=3.7V x 3A x 1h=11.1W·h电脑：W=UIt=19V x 2.6A x 1h=49.4W·h看了这个计算结果，你还会不会说电脑的电池容量没你手机的大了？！当然，有人又要钻牛角尖，说电脑120W，电池才这么点，那不是用半个小时就没电了，为什么我实际用的时候却能坚持2个小时？！至于为什么，我要说明，笔记本在接外接电源的时候和使用内置电池的时候，它们的功率是不一样的，主板会自动检测，当你使用内置电池的时候，会尽可能地降低计算机性能而达到节能，所以笔记本在接外接电源耍的时候，所产生的热量也比较大，这也是为什么很多追求更好性能的人更喜欢接外接电源玩电脑的原因了，手机也同样的道理。点评：如果这样了你都还去纠结电池容量这个问题，我觉得那就真没什么意思了哈。总结所谓DIY伪知识，无非就是让你第一感觉很有道理，并且长时间占据你印象流的DIY装机知识。不过，实际上，很多时候当你经过思考以及实证后，却发现有很多商榷的地方。所谓没有实践就没有发言权，就是这个道理。",
    "postDate": "2019-01-30T23:40:45.3394009+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": null,
    "id": 94,
    "indexId": "Post:94"
  },
  {
    "title": "经典面试题之——如何自由转换两个没有继承关系的字段及类型相同的实体模型",
    "author": "懒得勤快",
    "content": "相信很多童鞋们都被问到过这个问题，不管是在面试的时候被问过，还是笔试题里考过，甚至有些童鞋们找我要学习资料的时候我也考过这个问题，包括博主我自己，也曾被问过，而且博主现在有时作为公司的面试官，也喜欢问应试者这样的问题。这确实是一道基础题，不管是在java里面还是在C#里面，都属于一道非常基础的题，但很多童鞋竟然说没遇到过这样的场景，或者说学习基础的时候没重视过，所以自然不会了，那行，今天博主在这里就针对这个问题，做出详细的解释并由这个问题，同时，也给大家做个扩展学习吧。在实际的项目当中，这是个非常非常需要的，我们经常需要在不同用途的实体之间相互转换进行数据传输，最典型的当然就是Entity和DTO之间的相互转换咯(不懂什么是DTO的自己去科普下，或者在这儿你看成是ViewModel也行，这无所谓)。当然，开这篇文章肯定不是只讲简简单单反射这么简单，那我写这篇文章可能有点大动干戈了，所以，你们赚了，除了讲反射，自然也就引出了各种创建对象的效率问题，以及除了反射还有哪些方式可以转换实体。首先说一下，我听到的最多的答案，就是：1. new一个目标实体出来，然后把对应字段的值赋值上就好了2. 通过反射获取对象的属性，然后挨个循环属性，把对应属性名赋值到另一个对象里面3. 使用AutoMapper完成不同实体的转换。上面这几个答案都是对的，只是答案1的童鞋钻漏子勉强回答对了，而答案2的通用性比较高了，答案3的就是拿来主义，有现成的直接用就好了，底层怎么实现的不知道…。可能有些童鞋以前答不上来的时候看到这些答案就恍然大悟了，而有的童鞋可能还是有点懵，这样的话确实应该回头再学一遍基础了。好吧，来点实际的吧。那就从上面三个答案开始吧。先准备两个实体吧：&nbsp;&nbsp;&nbsp; public class Person&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public string Name { get; set; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public int Age { get; set; }&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; public class PersonDto&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public string Name { get; set; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public int Age { get; set; }&nbsp;&nbsp;&nbsp; }1. 硬编码实现实体的相互转换最简单粗暴的方法也就是这样的咯，但如果面试这样回答，基本上不会加分。Person p = new Person(){&nbsp;&nbsp;&nbsp; Age = 10,&nbsp;&nbsp;&nbsp; Name = &quot;张三&quot;};PersonDto pd = new PersonDto(){&nbsp;&nbsp;&nbsp; Name = p.Name,&nbsp;&nbsp;&nbsp; Age = p.Age};这样做，也不是不可以，毕竟效率是最高的，但是，通用性不强，如果要转换其他实体，每个都必须重新手写，不可复用，如果一个实体属性达到了几十上百个呢？这样写你不嫌手累嘛，看上去也不优雅是不。那下面这个，看上去稍微优雅点的：2. 委托实现实体的相互转换相比之上，稍微优雅了一点点，但，还是硬编码，面试这样回答的可能会加分；Person p = new Person(){&nbsp;&nbsp;&nbsp; Age = 10,&nbsp;&nbsp;&nbsp; Name = &quot;张三&quot;};Func&lt;Person, PersonDto&gt; func = c =&gt; new PersonDto(){&nbsp;&nbsp;&nbsp; Age = c.Age,&nbsp;&nbsp;&nbsp; Name = c.Name};PersonDto pd = func(p);这里直接写了个Func类型的委托，在委托里面硬编码给DTO实体的字段挨个赋值，看上去稍微优雅点了，毕竟用上了委托，哈哈……那好，又优雅又不是硬编码的来了。3. 使用AutoMapper完成不同实体的转换当然，这拿来主义在实际项目中确实也用得非常多，包括博主我自己，在项目中也是用AutoMapper居多，毕竟人家实体转换效率还是蛮高的，面试中可能会加分。Person p = new Person() { Age = 10, Name = &quot;张三&quot; };Mapper.Initialize(m =&gt; m.CreateMap&lt;Person, PersonDto&gt;());PersonDto pd = Mapper.Map&lt;PersonDto&gt;(p);这代码，看上去确实很简单就完成了，拿来主义嘛，那要是就不准让你用AutoMapper，又要达到它这样的高性能，你咋办？！那好，后面有终极武器，比AutoMapper的转换效率更高效，所以看到这篇文章的童鞋们，你们赚大了！4. 通过反射实现实体的相互转换可能这样回答的人基础都是比较好的了，面试都会加分的。首先准备一个方法，专门对实体进行映射：/// &lt;summary&gt;/// 实体映射/// &lt;/summary&gt;/// &lt;typeparam name=&quot;TDestination&quot;&gt;目标实体&lt;/typeparam&gt;/// &lt;param name=&quot;source&quot;&gt;源实体&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static TDestination MapTo&lt;TDestination&gt;(object source) where TDestination : new(){&nbsp;&nbsp;&nbsp; TDestination dest = new TDestination();//创建目标实体对象&nbsp;&nbsp;&nbsp; foreach (var p in dest.GetType().GetProperties())//获取源实体所有的属性&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p.SetValue(dest, source.GetType().GetProperty(p.Name)?.GetValue(source));//挨个为目标实体对应字段名进行赋值&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; return dest;}然后在需要进行实体转换的地方直接调这个方法就OK了；Person p = new Person() { Age = 10, Name = &quot;张三&quot; };PersonDto pd = MapTo&lt;PersonDto&gt;(p);很好，这很优雅，但是，博主我觉得，还不够优雅，毕竟，可能好多人没看懂？那好，来个更简单更直接的办法：反序列化进行实体转换；5. 通过Json反序列化实现实体的相互转换到这儿为止，很多童鞋就想不到了，实体转换还能通过json来进行；确实可以的，这也方便，而且还自带支持多成实体的映射转换，比如实体里面还包含List这样的数据结构；一句话就能搞定实体映射，不信你看：首先通过nuget把Newtonsoft.Json引进来，然后coding...Person p = new Person() { Age = 10, Name = &quot;张三&quot; };PersonDto pd = JsonConvert.DeserializeObject&lt;PersonDto&gt;(JsonConvert.SerializeObject(p));卧槽，居然这就搞定了，还能这么优雅？！那你试试吧。上面这几种方式都是经常用到的，但是，当你进行超大批量的实体转换时，你会发现，反射和反序列化的方式出现瓶颈了，那有没有办法来优化呢，肯定有啊，不能优化的话那怎么去支撑千万级数据？！那你想到的是什么？表达式树？emit？既然反射效率那么低，那是不是就不能用反射了？还是离不开反射，前方带你弯道超车，还请各位站稳扶好！如果你在面试当中用到了下面这几种方式，那么，可能面试官都会膜拜你了，最后的可能，就是你选公司而不是公司选你了，哈哈…，当然，可能有点夸大其词，毕竟面试你的也不是什么技术菜鸟，至少会给你的面试大大加分！6. 表达式树实现实体的相互转换来吧，拼接表达式，走起！Person p = new Person() { Age = 10, Name = &quot;张三&quot; };ParameterExpression parameterExpression = Expression.Parameter(typeof(Person), &quot;p&quot;);List&lt;MemberBinding&gt; memberBindingList = new List&lt;MemberBinding&gt;();//表示绑定的类派生自的基类，这些绑定用于对新创建对象的成员进行初始化(vs的注解。太生涩了，我这样的小白解释不了，大家将就着看)foreach (var item in typeof(PersonDto).GetProperties()) //遍历目标类型的所有属性{&nbsp;&nbsp;&nbsp; MemberExpression property = Expression.Property(parameterExpression, typeof(Person).GetProperty(item.Name));//获取到对应的属性&nbsp;&nbsp;&nbsp; MemberBinding memberBinding = Expression.Bind(item, property);//初始化这个属性&nbsp;&nbsp;&nbsp; memberBindingList.Add(memberBinding);}foreach (var item in typeof(PersonDto).GetFields())//遍历目标类型的所有字段{&nbsp;&nbsp;&nbsp; MemberExpression property = Expression.Field(parameterExpression, typeof(Person).GetField(item.Name));//获取到对应的字段&nbsp;&nbsp;&nbsp; MemberBinding memberBinding = Expression.Bind(item, property);//同上&nbsp;&nbsp;&nbsp; memberBindingList.Add(memberBinding);}MemberInitExpression memberInitExpression = Expression.MemberInit(Expression.New(typeof(PersonDto)), memberBindingList.ToArray());//初始化创建新对象Expression&lt;Func&lt;Person, PersonDto&gt;&gt; lambda = Expression.Lambda&lt;Func&lt;Person, PersonDto&gt;&gt;(memberInitExpression, parameterExpression);PersonDto pd = lambda.Compile()(p);卧槽，看起来好复杂，不明觉厉啊！那，自己慢慢摸索下吧，都说了要站稳扶好的，这就不怪老司机了哈！结果如上图所示，但是问题又来了，我们不可能只有一个类，也不可能只有一个Dto，那我们应该怎么实现呢？ 对 ，可以用泛型来实现。但是，博主我觉得还不够，每次转换还得写这么一大坨看不懂的东西，封装一下岂不更好用？那好，开始封装吧；7. 表达式树的封装实现通用实体的相互转换public static TDestination ExpressionTreeMapper&lt;TSource, TDestination&gt;(TSource source){&nbsp;&nbsp;&nbsp; ParameterExpression parameterExpression = Expression.Parameter(typeof(TSource), &quot;p&quot;);&nbsp;&nbsp;&nbsp; List&lt;MemberBinding&gt; memberBindingList = new List&lt;MemberBinding&gt;();//表示绑定的类派生自的基类，这些绑定用于对新创建对象的成员进行初始化(vs的注解。太生涩了，我这样的小白解释不了，大家将就着看)&nbsp;&nbsp;&nbsp; foreach (var item in typeof(TDestination).GetProperties()) //遍历目标类型的所有属性&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemberExpression property = Expression.Property(parameterExpression, typeof(TSource).GetProperty(item.Name));//获取到对应的属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemberBinding memberBinding = Expression.Bind(item, property);//初始化这个属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memberBindingList.Add(memberBinding);&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; foreach (var item in typeof(TDestination).GetFields())//遍历目标类型的所有字段&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemberExpression property = Expression.Field(parameterExpression, typeof(TSource).GetField(item.Name));//获取到对应的字段&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemberBinding memberBinding = Expression.Bind(item, property);//同上&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memberBindingList.Add(memberBinding);&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; MemberInitExpression memberInitExpression = Expression.MemberInit(Expression.New(typeof(TDestination)), memberBindingList.ToArray());//初始化创建新对象&nbsp;&nbsp;&nbsp; Expression&lt;Func&lt;TSource, TDestination&gt;&gt; lambda = Expression.Lambda&lt;Func&lt;TSource, TDestination&gt;&gt;(memberInitExpression, parameterExpression);&nbsp;&nbsp;&nbsp; return lambda.Compile()(source); //拼装是一次性的}封装之后，调用倒是方便了，但我觉得没区别，封装之后每次调用这个方法不也得走一遍编译表达式树的过程，这个过程岂不多余了？这个过程性能瓶颈很大。那好，能不能把编译之后的表达式树缓存起来？答案是肯定可以的，继续优化，走起；8. 表达式树缓存实现通用实体的相互转换实现思路：把每次编译后的表达式树缓存起来，如果存在，直接拿现成的编译好的表达式树调用就好了/// &lt;summary&gt;/// 生成表达式目录树。字典缓存/// &lt;/summary&gt;public class ExpressionMapper{&nbsp;&nbsp;&nbsp; private static Dictionary&lt;string, object&gt; _dic = new Dictionary&lt;string, object&gt;();//缓存字典，缓存后的就是硬编码所以性能高。&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;&nbsp;&nbsp;&nbsp; /// 字典缓存表达式树&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;&nbsp;&nbsp;&nbsp; /// &lt;typeparam name=&quot;TSource&quot;&gt;&lt;/typeparam&gt;&nbsp;&nbsp;&nbsp; /// &lt;typeparam name=&quot;TDestination&quot;&gt;&lt;/typeparam&gt;&nbsp;&nbsp;&nbsp; /// &lt;param name=&quot;source&quot;&gt;&lt;/param&gt;&nbsp;&nbsp;&nbsp; /// &lt;returns&gt;&lt;/returns&gt;&nbsp;&nbsp;&nbsp; public static TDestination Map&lt;TSource, TDestination&gt;(TSource source)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string key = $&quot;funckey_{typeof(TSource).FullName}_{typeof(TDestination).FullName}&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!_dic.ContainsKey(key)) //如果该表达式不存在，则走一遍编译过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ParameterExpression parameterExpression = Expression.Parameter(typeof(TSource), &quot;p&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List&lt;MemberBinding&gt; memberBindingList = new List&lt;MemberBinding&gt;();//表示绑定的类派生自的基类，这些绑定用于对新创建对象的成员进行初始化(vs的注解。太生涩了，我这样的小白解释不了，大家将就着看)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var item in typeof(TDestination).GetProperties()) //遍历目标类型的所有属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemberExpression property = Expression.Property(parameterExpression, typeof(TSource).GetProperty(item.Name));//获取到对应的属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemberBinding memberBinding = Expression.Bind(item, property);//初始化这个属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memberBindingList.Add(memberBinding);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var item in typeof(TDestination).GetFields())//遍历目标类型的所有字段&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemberExpression property = Expression.Field(parameterExpression, typeof(TSource).GetField(item.Name));//获取到对应的字段&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemberBinding memberBinding = Expression.Bind(item, property);//同上&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memberBindingList.Add(memberBinding);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemberInitExpression memberInitExpression = Expression.MemberInit(Expression.New(typeof(TDestination)), memberBindingList.ToArray());//初始化创建新对象&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Expression&lt;Func&lt;TSource, TDestination&gt;&gt; lambda = Expression.Lambda&lt;Func&lt;TSource, TDestination&gt;&gt;(memberInitExpression, parameterExpression);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dic[key] = lambda.Compile(); //拼装是一次性的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((Func&lt;TSource, TDestination&gt;)_dic[key]).Invoke(source);&nbsp;&nbsp;&nbsp; }}恩，这样缓存起来，再执行重复类型的转换，就直接取缓存好的表达式树进行调用了，性能貌似提升了，非常棒！但博主我认为，这还有优化的余地，既然有了缓存，那我干脆直接把泛型搬到整个类上面，进行缓存起来，好的，走起；9. 表达式树泛型缓存实现通用实体的相互转换/// &lt;summary&gt;/// 生成表达式目录树&nbsp; 泛型缓存/// &lt;/summary&gt;public class ExpressionGenericMapper{&nbsp;&nbsp;&nbsp; private static object func;&nbsp;&nbsp;&nbsp; public static TDestination Map&lt;TSource, TDestination&gt;(TSource source)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (func is null)//如果表达式不存在，则走一遍编译过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ParameterExpression parameterExpression = Expression.Parameter(typeof(TSource), &quot;p&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var memberBindingList = new List&lt;MemberBinding&gt;();//表示绑定的类派生自的基类，这些绑定用于对新创建对象的成员进行初始化(vs的注解。太生涩了，我这样的小白解释不了，大家将就着看)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var item in typeof(TDestination).GetProperties()) //遍历目标类型的所有属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemberExpression property = Expression.Property(parameterExpression, typeof(TSource).GetProperty(item.Name));//获取到对应的属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemberBinding memberBinding = Expression.Bind(item, property);//初始化这个属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memberBindingList.Add(memberBinding);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var item in typeof(TDestination).GetFields())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemberExpression property = Expression.Field(parameterExpression, typeof(TSource).GetField(item.Name));//获取到对应的字段&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemberBinding memberBinding = Expression.Bind(item, property);//同上&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memberBindingList.Add(memberBinding);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemberInitExpression memberInitExpression = Expression.MemberInit(Expression.New(typeof(TDestination)), memberBindingList.ToArray());//初始化创建新对象&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Expression&lt;Func&lt;TSource, TDestination&gt;&gt; lambda = Expression.Lambda&lt;Func&lt;TSource, TDestination&gt;&gt;(memberInitExpression, parameterExpression);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; func = lambda.Compile();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((Func&lt;TSource, TDestination&gt;)func)(source); //拼装是一次性的&nbsp;&nbsp;&nbsp; }}10. 最后，来个性能测试吧我们挨个用这些方法，都循环映射1,000,000次，看谁跑得最快！单线程测试代码：static void Main(string[] args){&nbsp;&nbsp;&nbsp; Person p = new Person() { Age = 10, Name = &quot;张三&quot; };&nbsp;&nbsp;&nbsp; Stopwatch sw = new Stopwatch();&nbsp;&nbsp;&nbsp; sw.Start();&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 1_000_000; i++)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PersonDto pd = new PersonDto() { Name = p.Name, Age = p.Age };&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; sw.Stop();&nbsp;&nbsp;&nbsp; Console.WriteLine($&quot;使用硬编码映射1000000次耗时{sw.Elapsed.TotalMilliseconds}ms&quot;);&nbsp;&nbsp;&nbsp; Func&lt;Person, PersonDto&gt; func = c =&gt; new PersonDto()&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Age = c.Age,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Name = c.Name&nbsp;&nbsp;&nbsp; };&nbsp;&nbsp;&nbsp; sw.Restart();&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 1_000_000; i++)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PersonDto pd = func(p);&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; sw.Stop();&nbsp;&nbsp;&nbsp; Console.WriteLine($&quot;使用委托映射1000000次耗时{sw.Elapsed.TotalMilliseconds}ms&quot;);&nbsp;&nbsp;&nbsp; sw.Restart();&nbsp;&nbsp;&nbsp; Mapper.Initialize(m =&gt; m.CreateMap&lt;Person, PersonDto&gt;());&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 1_000_000; i++)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PersonDto pd = Mapper.Map&lt;PersonDto&gt;(p);&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; sw.Stop();&nbsp;&nbsp;&nbsp; Console.WriteLine($&quot;使用AutoMapper映射1000000次耗时{sw.Elapsed.TotalMilliseconds}ms&quot;);&nbsp;&nbsp;&nbsp; sw.Restart();&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 1_000_000; i++)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PersonDto pd = MapTo&lt;PersonDto&gt;(p);&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; sw.Stop();&nbsp;&nbsp;&nbsp; Console.WriteLine($&quot;使用反射映射1000000次耗时{sw.Elapsed.TotalMilliseconds}ms&quot;);&nbsp;&nbsp;&nbsp; sw.Restart();&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 1_000_000; i++)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PersonDto pd = JsonConvert.DeserializeObject&lt;PersonDto&gt;(JsonConvert.SerializeObject(p));&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; sw.Stop();&nbsp;&nbsp;&nbsp; Console.WriteLine($&quot;使用Json反序列化映射1000000次耗时{sw.Elapsed.TotalMilliseconds}ms&quot;);&nbsp;&nbsp;&nbsp; sw.Restart();&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 1_000_000; i++)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PersonDto pd = ExpressionTreeMapper&lt;Person, PersonDto&gt;(p);&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; sw.Stop();&nbsp;&nbsp;&nbsp; Console.WriteLine($&quot;使用编译表达式树映射1000000次耗时{sw.Elapsed.TotalMilliseconds}ms&quot;);&nbsp;&nbsp;&nbsp; sw.Restart();&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 1_000_000; i++)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PersonDto pd = ExpressionMapper.Trans&lt;Person,PersonDto&gt;(p);&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; sw.Stop();&nbsp;&nbsp;&nbsp; Console.WriteLine($&quot;使用缓存编译表达式树映射1000000次耗时{sw.Elapsed.TotalMilliseconds}ms&quot;);&nbsp;&nbsp;&nbsp; sw.Restart();&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 1_000_000; i++)&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PersonDto pd = ExpressionGenericMapper.Map&lt;Person,PersonDto&gt;(p);&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; sw.Stop();&nbsp;&nbsp;&nbsp; Console.WriteLine($&quot;使用泛型缓存编译表达式树映射1000000次耗时{sw.Elapsed.TotalMilliseconds}ms&quot;);&nbsp;&nbsp;&nbsp; sw.Restart();&nbsp;&nbsp;&nbsp; Console.ReadKey();}测试结果：并行计算测试代码：static void Main(string[] args){&nbsp;&nbsp;&nbsp; Person p = new Person() { Age = 10, Name = &quot;张三&quot; };&nbsp;&nbsp;&nbsp; Stopwatch sw = new Stopwatch();&nbsp;&nbsp;&nbsp; sw.Start();&nbsp;&nbsp;&nbsp; Parallel.For(0, 1_000_000, (l, state) =&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PersonDto pd = new PersonDto() { Name = p.Name, Age = p.Age };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });&nbsp;&nbsp;&nbsp; sw.Stop();&nbsp;&nbsp;&nbsp; Console.WriteLine($&quot;使用硬编码映射1000000次耗时{sw.Elapsed.TotalMilliseconds}ms&quot;);&nbsp;&nbsp;&nbsp; Func&lt;Person, PersonDto&gt; func = c =&gt; new PersonDto()&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Age = c.Age,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Name = c.Name&nbsp;&nbsp;&nbsp; };&nbsp;&nbsp;&nbsp; sw.Restart();&nbsp;&nbsp;&nbsp; Parallel.For(0, 1_000_000, (l, state) =&gt;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PersonDto pd = func(p);&nbsp;&nbsp;&nbsp; });&nbsp;&nbsp;&nbsp; sw.Stop();&nbsp;&nbsp;&nbsp; Console.WriteLine($&quot;使用委托映射1000000次耗时{sw.Elapsed.TotalMilliseconds}ms&quot;);&nbsp;&nbsp;&nbsp; sw.Restart();&nbsp;&nbsp;&nbsp; Mapper.Initialize(m =&gt; m.CreateMap&lt;Person, PersonDto&gt;());&nbsp;&nbsp;&nbsp; Parallel.For(0, 1_000_000, (l, state) =&gt;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PersonDto pd = Mapper.Map&lt;PersonDto&gt;(p);&nbsp;&nbsp;&nbsp; });&nbsp;&nbsp;&nbsp; sw.Stop();&nbsp;&nbsp;&nbsp; Console.WriteLine($&quot;使用AutoMapper映射1000000次耗时{sw.Elapsed.TotalMilliseconds}ms&quot;);&nbsp;&nbsp;&nbsp; sw.Restart();&nbsp;&nbsp;&nbsp; Parallel.For(0, 1_000_000, (l, state) =&gt;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PersonDto pd = MapTo&lt;PersonDto&gt;(p);&nbsp;&nbsp;&nbsp; });&nbsp;&nbsp;&nbsp; sw.Stop();&nbsp;&nbsp;&nbsp; Console.WriteLine($&quot;使用反射映射1000000次耗时{sw.Elapsed.TotalMilliseconds}ms&quot;);&nbsp;&nbsp;&nbsp; sw.Restart();&nbsp;&nbsp;&nbsp; Parallel.For(0, 1_000_000, (l, state) =&gt;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PersonDto pd = JsonConvert.DeserializeObject&lt;PersonDto&gt;(JsonConvert.SerializeObject(p));&nbsp;&nbsp;&nbsp; });&nbsp;&nbsp;&nbsp; sw.Stop();&nbsp;&nbsp;&nbsp; Console.WriteLine($&quot;使用Json反序列化映射1000000次耗时{sw.Elapsed.TotalMilliseconds}ms&quot;);&nbsp;&nbsp;&nbsp; sw.Restart();&nbsp;&nbsp;&nbsp; Parallel.For(0, 1_000_000, (l, state) =&gt;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PersonDto pd = ExpressionTreeMapper&lt;Person, PersonDto&gt;(p);&nbsp;&nbsp;&nbsp; });&nbsp;&nbsp;&nbsp; sw.Stop();&nbsp;&nbsp;&nbsp; Console.WriteLine($&quot;使用编译表达式树映射1000000次耗时{sw.Elapsed.TotalMilliseconds}ms&quot;);&nbsp;&nbsp;&nbsp; sw.Restart();&nbsp;&nbsp;&nbsp; Parallel.For(0, 1_000_000, (l, state) =&gt;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PersonDto pd = ExpressionMapper.Trans&lt;Person, PersonDto&gt;(p);&nbsp;&nbsp;&nbsp; });&nbsp;&nbsp;&nbsp; sw.Stop();&nbsp;&nbsp;&nbsp; Console.WriteLine($&quot;使用缓存编译表达式树映射1000000次耗时{sw.Elapsed.TotalMilliseconds}ms&quot;);&nbsp;&nbsp;&nbsp; sw.Restart();&nbsp;&nbsp;&nbsp; Parallel.For(0, 1_000_000, (l, state) =&gt;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PersonDto pd = ExpressionGenericMapper.Map&lt;Person, PersonDto&gt;(p);&nbsp;&nbsp;&nbsp; });&nbsp;&nbsp;&nbsp; sw.Stop();&nbsp;&nbsp;&nbsp; Console.WriteLine($&quot;使用泛型缓存编译表达式树映射1000000次耗时{sw.Elapsed.TotalMilliseconds}ms&quot;);&nbsp;&nbsp;&nbsp; sw.Restart();&nbsp;&nbsp;&nbsp; Console.ReadKey();}测试结果：很显然，不管是串行代码还是并行代码，硬编码效率肯定是最高的，至于为什么直接new的硬编码在并行的时候似乎慢了点，这就需要你们从多线程和内存的角度考虑下了，Newtonsoft.Json虽然是高性能的序列化插件，但是使用不当也会造成性能瓶颈的，你们如果用JavascriptSerializer序列化，估计看出来的差距更大了，所以一开始我也就选择Newtonsoft.Json来做本次的评测，也能看出来，表达式树不缓存的时候也是非常耗性能的，毕竟每次都要走一遍编译过程，所以就慢了，而一旦加上了缓存机制，就得到了质的飞跃，而最后的表达式树泛型缓存的写法，性能最接近硬编码的写法，所以，优化无止境！至于为什么AutoMapper的性能还没有表达式树高，有兴趣的童鞋可以去github研究下它的源码，它的底层实现其实是用的emit写法，这篇文章就不准备再讲emit了，估计这个更容易把你们给搞晕，毕竟涉及到很多中间语言代码（MSIL），所以，有兴趣的你，可以作为扩展研究。",
    "postDate": "2019-01-30T23:40:45.3394635+08:00",
    "email": "admin@masuit.com",
    "label": ".NET,面试",
    "keyword": null,
    "id": 170,
    "indexId": "Post:170"
  },
  {
    "title": "深入理解C#中的IDisposable接口",
    "author": "懒得勤快",
    "content": "写在前面在开始之前，我们需要明确什么是C#(或者说.NET)中的资源，打码的时候我们经常说释放资源，那么到底什么是资源，简单来讲，C#中的每一种类型都是一种资源，而资源又分为托管资源和非托管资源，那这又是什么？！托管资源：由CLR管理分配和释放的资源，也就是我们直接new出来的对象；非托管资源：不受CLR控制的资源，也就是不属于.NET本身的功能，往往是通过调用跨平台程序集(如C++)或者操作系统提供的一些接口，比如Windows内核对象、文件操作、数据库连接、socket、Win32API、网络等。我们下文讨论的，主要也就是非托管资源的释放，而托管资源.NET的垃圾回收已经帮我们完成了。其实非托管资源有部分.NET的垃圾回收也帮我们实现了，那么如果要让.NET垃圾回收帮我们释放非托管资源，该如何去实现。如何正确的显式释放资源假设我们要使用FileStream，我们通常的做法是将其using起来，或者是更老式的try…catch…finally…这种做法，因为它的实现调用了非托管资源，所以我们必须用完之后要去显式释放它，如果不去释放它，那么可能就会造成内存泄漏。这听上去貌似很简单，但我们编码的时候可能很多时候会忽略掉释放资源这个问题，.NET的垃圾回收又如何帮我们释放非托管资源，接下来我们一探究竟吧，一个标准的释放非托管资源的类应该去实现IDisposable接口：public&nbsp;class&nbsp;MyClass:IDisposable\n{\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;执行与释放或重置非托管资源关联的应用程序定义的任务。&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Dispose()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}我们实例化的时候就可以将这个类using起来：using(var&nbsp;mc&nbsp;=&nbsp;new&nbsp;MyClass())\n{\n}看上去很简单嘛，但是，要是就这么简单的话，也没有这篇文章的必要了。如果要实现IDisposable接口，我们其实应该这样做：实现Dispose方法；提取一个受保护的Dispose虚方法，在该方法中实现具体的释放资源的逻辑；添加析构函数；添加一个私有的bool类型的字段，作为释放资源的标记接下来，我们来实现这样的一个Dispose模式：public&nbsp;class&nbsp;MyClass&nbsp;:&nbsp;IDisposable\n{\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;模拟一个非托管资源\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;IntPtr&nbsp;NativeResource&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}&nbsp;=&nbsp;Marshal.AllocHGlobal(100);\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;模拟一个托管资源\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Random&nbsp;ManagedResource&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}&nbsp;=&nbsp;new&nbsp;Random();\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;释放标记\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;bool&nbsp;disposed;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;为了防止忘记显式的调用Dispose方法\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;~MyClass()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//必须为false\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dispose(false);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;执行与释放或重置非托管资源关联的应用程序定义的任务。&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Dispose()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//必须为true\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dispose(true);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//通知垃圾回收器不再调用终结器\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GC.SuppressFinalize(this);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;非必需的，只是为了更符合其他语言的规范，如C++、java\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Close()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dispose();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;非密封类可重写的Dispose方法，方便子类继承时可重写\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;param&nbsp;name=&quot;disposing&quot;&gt;&lt;/param&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;virtual&nbsp;void&nbsp;Dispose(bool&nbsp;disposing)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(disposed)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//清理托管资源\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(disposing)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ManagedResource&nbsp;!=&nbsp;null)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ManagedResource&nbsp;=&nbsp;null;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//清理非托管资源\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(NativeResource&nbsp;!=&nbsp;IntPtr.Zero)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Marshal.FreeHGlobal(NativeResource);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NativeResource&nbsp;=&nbsp;IntPtr.Zero;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//告诉自己已经被释放\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disposed&nbsp;=&nbsp;true;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}这里面每行代码都有它独自的含义，文章里不可能每句话都讲解透彻，为了突出重点，所以接下来就挑出几个重要的地方逐一解释咯，当然截止现在，我们只需要记住：如果类型需要显式的释放资源，那么就一定要实现IDisposable接口。实现IDisposable接口其实也是为了方便使用using这个语法糖，以方便编译器帮我们自动生成Dispose的IL代码：using(var&nbsp;mc&nbsp;=&nbsp;new&nbsp;MyClass())\n{\n}就相当于：MyClass&nbsp;mc&nbsp;=&nbsp;null;\ntry\n{\n&nbsp;&nbsp;&nbsp;&nbsp;mc&nbsp;=&nbsp;new&nbsp;MyClass();\n}\nfinally\n{\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(mc&nbsp;!=&nbsp;null)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mc.Dispose();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}如果要同时管理多个相同类型的对象：using(MyClass&nbsp;mc1=new&nbsp;MyClass(),mc2=new&nbsp;MyClass())\n{\n}如果类型不一致：using(var&nbsp;client&nbsp;=&nbsp;new&nbsp;HttpClient())\n{\n&nbsp;&nbsp;&nbsp;&nbsp;using(var&nbsp;stream&nbsp;=&nbsp;File.Create(&quot;&quot;))\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}为什么需要析构方法？在之前我们实现的更标准的Dispose模式中，我们注意到了，类里面包含了一个~开头的析构方法：~MyClass()\n{\n&nbsp;&nbsp;&nbsp;&nbsp;//必须为false\n&nbsp;&nbsp;&nbsp;&nbsp;Dispose(false);\n}这个析构方法更规范的说法叫做终结器，它的意义在于，如果我们忘记了显式调用Dispose方法，垃圾回收器在扫描内存的时候，会作为释放资源的一种补救措施。为什么加了析构方法就会有这种效果，我们知道在new对象的时候，CLR会为对象创建一块内存空间，一旦对象不再被引用，就会被垃圾回收器回收掉，对于没有实现IDisposable接口的类来说，垃圾回收时将直接回收掉这片内存空间，而对于实现了IDisposable接口的类来说，由于析构方法的存在，在创建对象之初，CLR会将该对象的一个指针放到终结器列表中，在GC回收内存之前，会首先将终结器列表中的指针放到一个freachable队列中，同时，CLR还会分配专门的内存空间来读取freachable队列，并调用对象的终结器，只有在这个时候，对象才被真正的被标识为垃圾，在下一次垃圾回收的时候才回收这个对象所占用的内存空间。那么，实现了IDisposable接口的对象在回收时要经过两次GC才能被真正的释放掉，因为GC要先安排CLR调用终结器，基于这个特点，如果我们显式调用了Dispose方法，那么GC就不会再进行第二次垃圾回收了，当然，如果忘记了Dispose，也避免了忘记调用Dispose方法造成的内存泄漏。提示：析构方法是在C++中的一种说法，因为终结器和析构方法两者特点很像，为了沿袭C++的叫法，称之为析构方法也没有什么不妥，但它们又不完全一致，所以微软后来又确定它叫终结器。还有一点我们也注意到了，如果已经显式的调用了Dispose方法，那么隐式释放资源就再没必要运行了，GC的SuppressFinalize方法就是通知GC的这一点：public&nbsp;void&nbsp;Dispose()\n{\n&nbsp;&nbsp;&nbsp;&nbsp;//必须为true\n&nbsp;&nbsp;&nbsp;&nbsp;Dispose(true);\n&nbsp;&nbsp;&nbsp;&nbsp;//通知垃圾回收器不再调用终结器\n&nbsp;&nbsp;&nbsp;&nbsp;GC.SuppressFinalize(this);\n}所以在实现的Dispose方法中先调用我们正常的资源释放代码，再通知GC不要调用终结器了。为什么需要提供一个Dispose虚方法？我们注意到了，实现自Idisposable接口的Dispose方法并没有做实际的清理工作，而是调用了我们这个受保护的Dispose虚方法：protected&nbsp;virtual&nbsp;void&nbsp;Dispose(bool&nbsp;disposing)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(disposed)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;//清理托管资源\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(disposing)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ManagedResource&nbsp;!=&nbsp;null)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ManagedResource&nbsp;=&nbsp;null;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;//清理非托管资源\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(NativeResource&nbsp;!=&nbsp;IntPtr.Zero)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Marshal.FreeHGlobal(NativeResource);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NativeResource&nbsp;=&nbsp;IntPtr.Zero;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;//告诉自己已经被释放\n&nbsp;&nbsp;&nbsp;&nbsp;disposed&nbsp;=&nbsp;true;\n}之所以是虚方法，就是考虑到它如果被其他类继承时，子类也实现了Dispose模式，这个虚方法可以提醒子类，清理的时候要注意到父类的清理工作，即如果子类重新该方法，必须调用base.Dispose方法，假设现在我们有个子类，继承自MyClass：public&nbsp;class&nbsp;MyClassChild&nbsp;:&nbsp;MyClass\n{\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;模拟一个非托管资源\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;IntPtr&nbsp;NativeResource&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}&nbsp;=&nbsp;Marshal.AllocHGlobal(100);\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;模拟一个托管资源\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Random&nbsp;ManagedResource&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}&nbsp;=&nbsp;new&nbsp;Random();\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;释放标记\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;bool&nbsp;disposed;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;非密封类可重写的Dispose方法，方便子类继承时可重写\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;param&nbsp;name=&quot;disposing&quot;&gt;&lt;/param&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;override&nbsp;void&nbsp;Dispose(bool&nbsp;disposing)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(disposed)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//清理托管资源\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(disposing)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ManagedResource&nbsp;!=&nbsp;null)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ManagedResource&nbsp;=&nbsp;null;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//清理非托管资源\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(NativeResource&nbsp;!=&nbsp;IntPtr.Zero)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Marshal.FreeHGlobal(NativeResource);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NativeResource&nbsp;=&nbsp;IntPtr.Zero;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;base.Dispose(disposing);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}如果不是虚方法，那么就很有可能让开发者在子类继承的时候忽略掉父类的清理工作，所以，基于继承体系的原因，我们要提供这样的一个虚方法。其次，提供的这个虚方法是一个带bool参数的，带这个参数的目的，是为了释放资源时区分对待托管资源和非托管资源，而实现自IDisposable的Dispose方法调用时，传入的是true，而终结器调用的时候，传入的是false，当传入true时代表要同时处理托管资源和非托管资源；而传入false则只需要处理非托管资源即可。那为什么要区别对待托管资源和非托管资源？在这个问题之前，其实我们应该先弄明白：托管资源需要手动清理吗？不妨将C#的类型分为两类：一类实现了IDisposable，另一类则没有。前者我们定义为非普通类型，后者为普通类型。非普通类型包含了非托管资源，实现了IDisposable，但又包含有自身是托管资源，所以不普通，对于我们刚才的问题，答案就是：普通类型不需要手动清理，而非普通类型需要手动清理。而我们的Dispose模式设计思路在于：如果显式调用Dispose，那么类型就该按部就班的将自己的资源全部释放，如果忘记了调用Dispose，那就假定自己的所有资源(哪怕是非普通类型)都交给GC了，所以不需要手动清理，所以这就理解为什么实现自IDisposable的Dispose中调用虚方法是传true，终结器中传false了。同时我们还注意到了，虚方法首先判断了disposed字段，这个字段用于判断对象的释放状态，这意味着多次调用Dispose时，如果对象已经被清理过了，那么清理工作就不用再继续。但Dispose并不代表把对象置为了null，且已经被回收彻底不存在了。但事实上，对象的引用还可能存在的，只是不再是正常的状态了，所以我们明白有时候我们调用数据库上下文有时候为什么会报“数据库连接已被释放”之类的异常了。所以，disposed字段的存在，用来表示对象是否被释放过。如果对象包含非托管类型的字段或属性的类型应该是可释放的这句话读起来可能有点绕啊，也就是说，如果对象的某些字段或属性是IDisposable的子类，比如FileStream，那么这个类也应该实现IDisposable。之前我们说过C#的类型分为普通类型和非普通类型，非普通类型包含普通的自身和非托管资源。那么，如果类的某个字段或属性的类型是非普通类型，那么这个类型也应该是非普通类型，应该也要实现IDisposable接口。举个栗子，如果一个类型，组合了FileStream，那么它应该实现IDisposable接口，代码如下：public&nbsp;class&nbsp;MyClass2&nbsp;:&nbsp;IDisposable\n{\n&nbsp;&nbsp;&nbsp;&nbsp;~MyClass2()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dispose(false);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;FileStream&nbsp;FileStream&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;释放标记\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;bool&nbsp;disposed;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;执行与释放或重置非托管资源关联的应用程序定义的任务。&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Dispose()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dispose(true);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GC.SuppressFinalize(this);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;非密封类可重写的Dispose方法，方便子类继承时可重写\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;param&nbsp;name=&quot;disposing&quot;&gt;&lt;/param&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;virtual&nbsp;void&nbsp;Dispose(bool&nbsp;disposing)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(disposed)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//清理托管资源\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(disposing)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//todo\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//清理非托管资源\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(FileStream&nbsp;!=&nbsp;null)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileStream.Dispose();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileStream&nbsp;=&nbsp;null;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//告诉自己已经被释放\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disposed&nbsp;=&nbsp;true;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}因为类型包含了FileStream类型的字段，所以它包含了非普通类型，我们仍旧需要为这个类型实现IDisposable接口。及时释放资源可能很多人会问啊，GC已经帮我们隐式的释放了资源，为什么还要主动地释放资源，我们先来看一个例子：private&nbsp;void&nbsp;button6_Click(object&nbsp;sender,&nbsp;EventArgs&nbsp;e)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;fs&nbsp;=&nbsp;new&nbsp;FileStream(@&quot;C:\\1.txt&quot;,FileMode.OpenOrCreate,FileAccess.ReadWrite);\n}\nprivate&nbsp;void&nbsp;button7_Click(object&nbsp;sender,&nbsp;EventArgs&nbsp;e)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;GC.Collect();\n}上面的代码在WinForm程序中，单击按钮6，打开一个文件流，单击按钮7执行GC回收所有“代”(下文将指出代的概念)的垃圾，如果连续单击两次按钮6，将会抛异常：如果单击按钮6再单击按钮7，然后再单击按钮6则不会出现这个问题。我们来分析一下：在单击按钮6的时候打开一个文件，方法已经执行完毕，fs已经没有被任何地方引用了，所以被标记为了垃圾，那么什么时候被回收呢，或者GC什么时候开始工作？微软官方的解释是，当满足以下条件之一时，GC才会工作：系统具有较低的物理内存；由托管堆上已分配的对象使用的内存超出了可接受的范围；手动调用GC.Collect方法，但几乎所有的情况下，我们都不必调用，因为垃圾回收器会自动调用它，但在上面的例子中，为了体验一下不及时回收垃圾带来的危害，所以手动调用了GC.Collect，大家也可以仔细体会一下运行这个方法带来的不同。GC还有个“代”的概念，一共分3代：0代、1代、2代。而这三代，相当于是三个队列容器，第0代包含的是一些短期生存的对象，上面的例子fs就是个短期对象，当方法执行完后，fs就被丢到了GC的第0代，但不进行垃圾回收，只有当第0代满了的时候，系统认为此时满足了低内存的条件，才会触发垃圾回收事件。所以我们永远不知道fs什么时候被回收掉，在回收之前，它实际上已经没有用处了，但始终占着系统资源不放(占着茅坑不拉屎)，这对系统来说是种极大的浪费，而且这种浪费还会干扰整个系统的运行，比如我们的例子，由于它始终占着资源，就导致了我们不能再对文件进行访问了。不及时释放资源还会带来另外的一个问题，虽然之前我们说实现IDisposable接口的类，GC可以自动帮我们释放，但这个过程被延长了，因为它不是在一次回收中完成所有的清理工作，即使GC自动帮我们释放了，那也是先调用FileStream的终结器，在下一次的垃圾回收时才会真正的被释放。了解到危害后，我们在打码过程中，如果我们明知道它应该被using起来时，一定要using起来：using&nbsp;(var&nbsp;fs&nbsp;=&nbsp;new&nbsp;FileStream(@&quot;C:\\1.txt&quot;,&nbsp;FileMode.OpenOrCreate,&nbsp;FileAccess.ReadWrite))\n{\n}需不需要将不再使用的对象置为null在上文的内容中，我们都提到要释放资源，但并没有说明需不需要将不再使用的对象置为null，而这个问题也是一直以来争议很大的问题，有人认为将对象置为null能让GC更早地发现垃圾，也有人认为这并没有什么卵用。其实这个问题首先是从方法的内部被提起的，为了更好的说明这个问题，我们先来段代码来检验一下：private&nbsp;void&nbsp;button6_Click(object&nbsp;sender,&nbsp;EventArgs&nbsp;e)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;mc1&nbsp;=&nbsp;new&nbsp;MyClass()&nbsp;{&nbsp;Name&nbsp;=&nbsp;&quot;mc1&quot;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;mc2&nbsp;=&nbsp;new&nbsp;MyClass()&nbsp;{&nbsp;Name&nbsp;=&nbsp;&quot;mc2&quot;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;mc1&nbsp;=&nbsp;null;\n}\nprivate&nbsp;void&nbsp;button7_Click(object&nbsp;sender,&nbsp;EventArgs&nbsp;e)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;GC.Collect();\n}\npublic&nbsp;class&nbsp;MyClass\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;~MyClass()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageBox.Show(Name&nbsp;+&nbsp;&quot;被销毁了&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}单击按钮6，再单击按钮7，我们发现：没有置为null的mc2会先被释放，虽然它在mc1被置为null之后；在CLR托管的应用程序中，有一个“根”的概念，类型的静态字段、方法参数以及局部变量都可以被作为“根”存在（值类型不能作为“根”，只有引用类型才能作为“根”）。上面的代码中，mc1和mc2在代码运行过程中分别会在内存中创建一个“根”。在垃圾回收的过程中，GC会沿着线程栈扫描“根”(栈的特点先进后出，也就是mc2在mc1之后进栈，但mc2比mc1先出栈)，检查完毕后还会检查所有引用类型的静态字段的集合，当检查到方法内存在“根”时，如果发现没有任何一个地方引用这个局部变量的时候，不管你是否已经显式的置为null这都意味着“根”已经被停止，然后GC就会发现该根的引用为空，就会被标记为可被释放，这也代表着mc1和mc2的内存空间可以被释放，所以上面的代码mc1=null没有任何意义(方法的参数变量也是如此)。其实.NET的JIT编译器是一个优化过的编译器，所以如果我们代码里面将局部变量置为null，这样的语句会被忽略掉：s=null;如果我们的项目是在Release配置下的，上面的代码压根就不会被编译到dll，正是由于我们上面的分析，所以很多人都会认为将对象赋值为null完全没有必要，但是，在另一种情况下，就完全有必要将对象赋值为null，那就是静态字段或属性，但这斌不意味着将对象赋值为null就是将它的静态字段赋值为null：private&nbsp;void&nbsp;button6_Click(object&nbsp;sender,&nbsp;EventArgs&nbsp;e)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;mc&nbsp;=&nbsp;new&nbsp;MyClass()&nbsp;{&nbsp;Name&nbsp;=&nbsp;&quot;mc&quot;&nbsp;};\n}\nprivate&nbsp;void&nbsp;button7_Click(object&nbsp;sender,&nbsp;EventArgs&nbsp;e)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;GC.Collect();\n}\npublic&nbsp;class&nbsp;MyClass\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;MyClass2&nbsp;MyClass2&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}&nbsp;=&nbsp;new&nbsp;MyClass2();\n&nbsp;&nbsp;&nbsp;&nbsp;~MyClass()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//MyClass2&nbsp;=&nbsp;null;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageBox.Show(Name&nbsp;+&nbsp;&quot;被销毁了&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\npublic&nbsp;class&nbsp;MyClass2\n{\n&nbsp;&nbsp;&nbsp;&nbsp;~MyClass2()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageBox.Show(&quot;MyClass2被释放&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}上面的代码运行我们会发现，当mc被回收时，它的静态属性并没有被GC回收，而我们将MyClass终结器中的MyClass2=null的注释取消，再运行，当我们两次点击按钮7的时候，属性MyClass2才被真正的释放，因为第一次GC的时候只是在终结器里面将MyClass属性置为null，在第二次GC的时候才当作垃圾回收了，之所以静态变量不被释放(即使赋值为null也不会被编译器优化)，是因为类型的静态字段一旦被创建，就被作为“根”存在，基本上不参与GC，所以GC始终不会认为它是个垃圾，而非静态字段则不会有这样的问题。所以在实际工作当中，一旦我们感觉静态变量所占用的内存空间较大的时候，并且不会再使用，便可以将其置为null，最典型的案例就是缓存的过期策略的实现了，将静态变量置为null这或许不是很有必要，但这绝对是一个好的习惯，试想一个项目中，如果将某个静态变量作为全局的缓存，如果没有做过期策略，一旦项目运行，那么它所占的内存空间只增不减，最终顶爆机器内存，所以，有个建议就是：尽量地少用静态变量。",
    "postDate": "2019-01-30T23:40:45.3395267+08:00",
    "email": "admin@masuit.com",
    "label": ".NET",
    "keyword": null,
    "id": 1202,
    "indexId": "Post:1202"
  },
  {
    "title": "用C#实现求有向图的最长路径和最短路径",
    "author": "懒得勤快",
    "content": "最近两天心血来潮，在研究数据结构，研究有向无环图如何求最短路径和最长路径，可是翻阅了一些资料，都没咋看懂，网上也没有找到什么这方面的解决方案，于是，自己实现一下这个算法吧。自己的大致实现思路：从终点开始往前找，把每一条从起点开始的路都找出来，最后进行路程的比较，便可以得到相应的最短路径和最长路径。测试示例如下图：实现目标：最短路径：A-B-D-E，路程为8最长路径：A-B-C-D-E，路程为12开始撸代码准备两个实体类Node和Route，Node即每个节点，Route用于保存两个节点间的距离：&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;路由\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;typeparam&nbsp;name=&quot;T&quot;&gt;&lt;/typeparam&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;Route&lt;T&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Route(Node&lt;T&gt;&nbsp;src,&nbsp;Node&lt;T&gt;&nbsp;dest,&nbsp;int&nbsp;distance)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Source&nbsp;=&nbsp;src;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dest&nbsp;=&nbsp;dest;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Distance&nbsp;=&nbsp;distance;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;开始节点\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Node&lt;T&gt;&nbsp;Source&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;结束节点\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Node&lt;T&gt;&nbsp;Dest&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;距离\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;Distance&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;节点\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;typeparam&nbsp;name=&quot;T&quot;&gt;&lt;/typeparam&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;Node&lt;T&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Node(string&nbsp;name)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;=&nbsp;name;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prevs&nbsp;=&nbsp;new&nbsp;Dictionary&lt;Node&lt;T&gt;,&nbsp;int&gt;();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;节点名\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;前面的节点以及到前一个节点需要的距离\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Dictionary&lt;Node&lt;T&gt;,&nbsp;int&gt;&nbsp;Prevs&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}先初始化这5个节点的数据：Node&lt;string&gt;&nbsp;a&nbsp;=&nbsp;new&nbsp;Node&lt;string&gt;(&quot;A&quot;);\nNode&lt;string&gt;&nbsp;b&nbsp;=&nbsp;new&nbsp;Node&lt;string&gt;(&quot;B&quot;);\nNode&lt;string&gt;&nbsp;c&nbsp;=&nbsp;new&nbsp;Node&lt;string&gt;(&quot;C&quot;);\nNode&lt;string&gt;&nbsp;d&nbsp;=&nbsp;new&nbsp;Node&lt;string&gt;(&quot;D&quot;);\nNode&lt;string&gt;&nbsp;e&nbsp;=&nbsp;new&nbsp;Node&lt;string&gt;(&quot;E&quot;);\nSetRoutePath(a,&nbsp;b,&nbsp;1);\nSetRoutePath(b,&nbsp;c,&nbsp;2);\nSetRoutePath(a,&nbsp;c,&nbsp;2);\nSetRoutePath(b,&nbsp;d,&nbsp;3);\nSetRoutePath(c,&nbsp;d,&nbsp;5);\nSetRoutePath(b,&nbsp;e,&nbsp;9);\nSetRoutePath(d,&nbsp;e,&nbsp;4);\nList&lt;Node&lt;string&gt;&gt;&nbsp;nodes&nbsp;=&nbsp;new&nbsp;List&lt;Node&lt;string&gt;&gt;()\n{\n&nbsp;&nbsp;&nbsp;&nbsp;a,\n&nbsp;&nbsp;&nbsp;&nbsp;b,\n&nbsp;&nbsp;&nbsp;&nbsp;c,\n&nbsp;&nbsp;&nbsp;&nbsp;d,\n&nbsp;&nbsp;&nbsp;&nbsp;e\n};设置节点路由信息的方法：private&nbsp;static&nbsp;void&nbsp;SetRoutePath(Node&lt;string&gt;&nbsp;start,&nbsp;Node&lt;string&gt;&nbsp;end,&nbsp;int&nbsp;distance)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;end.Prevs.Add(start,&nbsp;distance);\n}真正的核心业务代码：&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;路由计算引擎\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;typeparam&nbsp;name=&quot;T&quot;&gt;&lt;/typeparam&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;RouteEngine&lt;T&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;节点信息\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;List&lt;Node&lt;T&gt;&gt;&nbsp;Nodes&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;路由结果\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Dictionary&lt;string,&nbsp;int&gt;&nbsp;RouteList&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}&nbsp;=&nbsp;new&nbsp;Dictionary&lt;string,&nbsp;int&gt;();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;RouteEngine(List&lt;Node&lt;T&gt;&gt;&nbsp;nodes)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nodes&nbsp;=&nbsp;nodes;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;递归将每条路都计算出来\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;param&nbsp;name=&quot;node&quot;&gt;&lt;/param&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;param&nbsp;name=&quot;route&quot;&gt;&lt;/param&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;param&nbsp;name=&quot;dis&quot;&gt;&lt;/param&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;InterateRoute(Node&lt;T&gt;&nbsp;node,&nbsp;string&nbsp;route,&nbsp;int&nbsp;dis)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(node.Prevs.Any())\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(var&nbsp;prev&nbsp;in&nbsp;node.Prevs)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RouteList[prev.Key.Name&nbsp;+&nbsp;&quot;,&quot;&nbsp;+&nbsp;route]&nbsp;=&nbsp;dis&nbsp;+&nbsp;prev.Value;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InterateRoute(prev.Key,&nbsp;prev.Key.Name&nbsp;+&nbsp;&quot;,&quot;&nbsp;+&nbsp;route,&nbsp;dis&nbsp;+&nbsp;prev.Value);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;获得路径\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;param&nbsp;name=&quot;start&quot;&gt;&lt;/param&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;param&nbsp;name=&quot;end&quot;&gt;&lt;/param&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;param&nbsp;name=&quot;shortest&quot;&gt;&lt;/param&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;returns&gt;&lt;/returns&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;(List&lt;Route&lt;T&gt;&gt;,&nbsp;HashSet&lt;Node&lt;T&gt;&gt;)&nbsp;GetRoutes(Node&lt;T&gt;&nbsp;start,&nbsp;Node&lt;T&gt;&nbsp;end,&nbsp;bool&nbsp;shortest)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InterateRoute(end,&nbsp;end.Name,&nbsp;0);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;list&nbsp;=&nbsp;new&nbsp;List&lt;Route&lt;T&gt;&gt;();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;nodes&nbsp;=&nbsp;new&nbsp;HashSet&lt;Node&lt;T&gt;&gt;();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;routes&nbsp;=&nbsp;RouteList.Where(k&nbsp;=&gt;&nbsp;k.Key.StartsWith(start.Name)&nbsp;&amp;&amp;&nbsp;k.Key.EndsWith(end.Name));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;route&nbsp;=&nbsp;(shortest&nbsp;?&nbsp;routes.OrderBy(x&nbsp;=&gt;&nbsp;x.Value)&nbsp;:&nbsp;routes.OrderByDescending(x&nbsp;=&gt;&nbsp;x.Value)).FirstOrDefault().Key;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string[]&nbsp;strs&nbsp;=&nbsp;route.Split(&#39;,&#39;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(var&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;strs.Length&nbsp;-&nbsp;1;&nbsp;i++)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&lt;T&gt;&nbsp;src&nbsp;=&nbsp;Nodes.Find(n&nbsp;=&gt;&nbsp;n.Name.Equals(strs[i]));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&lt;T&gt;&nbsp;dest&nbsp;=&nbsp;Nodes.Find(n&nbsp;=&gt;&nbsp;n.Name.Equals(strs[i&nbsp;+&nbsp;1]));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.Add(new&nbsp;Route&lt;T&gt;(src,&nbsp;dest,&nbsp;dest.Prevs[src]));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodes.Add(src);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodes.Add(dest);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(list,&nbsp;nodes);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}通过递归，把每个节点到起点的路径都找出来存到RouteList中，最后筛选出起点到终点的最短和最长路径。运行结果：完整代码：&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;路由计算引擎\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;typeparam&nbsp;name=&quot;T&quot;&gt;&lt;/typeparam&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;RouteEngine&lt;T&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;节点信息\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;List&lt;Node&lt;T&gt;&gt;&nbsp;Nodes&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;路由结果\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Dictionary&lt;string,&nbsp;int&gt;&nbsp;RouteList&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}&nbsp;=&nbsp;new&nbsp;Dictionary&lt;string,&nbsp;int&gt;();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;RouteEngine(List&lt;Node&lt;T&gt;&gt;&nbsp;nodes)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nodes&nbsp;=&nbsp;nodes;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;递归将每条路都计算出来\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;param&nbsp;name=&quot;node&quot;&gt;&lt;/param&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;param&nbsp;name=&quot;route&quot;&gt;&lt;/param&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;param&nbsp;name=&quot;dis&quot;&gt;&lt;/param&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;InterateRoute(Node&lt;T&gt;&nbsp;node,&nbsp;string&nbsp;route,&nbsp;int&nbsp;dis)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(node.Prevs.Any())\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(var&nbsp;prev&nbsp;in&nbsp;node.Prevs)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RouteList[prev.Key.Name&nbsp;+&nbsp;&quot;,&quot;&nbsp;+&nbsp;route]&nbsp;=&nbsp;dis&nbsp;+&nbsp;prev.Value;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InterateRoute(prev.Key,&nbsp;prev.Key.Name&nbsp;+&nbsp;&quot;,&quot;&nbsp;+&nbsp;route,&nbsp;dis&nbsp;+&nbsp;prev.Value);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;获得路径\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;param&nbsp;name=&quot;start&quot;&gt;&lt;/param&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;param&nbsp;name=&quot;end&quot;&gt;&lt;/param&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;param&nbsp;name=&quot;shortest&quot;&gt;&lt;/param&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;returns&gt;&lt;/returns&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;(List&lt;Route&lt;T&gt;&gt;,&nbsp;HashSet&lt;Node&lt;T&gt;&gt;)&nbsp;GetRoutes(Node&lt;T&gt;&nbsp;start,&nbsp;Node&lt;T&gt;&nbsp;end,&nbsp;bool&nbsp;shortest)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InterateRoute(end,&nbsp;end.Name,&nbsp;0);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;list&nbsp;=&nbsp;new&nbsp;List&lt;Route&lt;T&gt;&gt;();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;nodes&nbsp;=&nbsp;new&nbsp;HashSet&lt;Node&lt;T&gt;&gt;();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;routes&nbsp;=&nbsp;RouteList.Where(k&nbsp;=&gt;&nbsp;k.Key.StartsWith(start.Name)&nbsp;&amp;&amp;&nbsp;k.Key.EndsWith(end.Name));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;route&nbsp;=&nbsp;(shortest&nbsp;?&nbsp;routes.OrderBy(x&nbsp;=&gt;&nbsp;x.Value)&nbsp;:&nbsp;routes.OrderByDescending(x&nbsp;=&gt;&nbsp;x.Value)).FirstOrDefault().Key;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string[]&nbsp;strs&nbsp;=&nbsp;route.Split(&#39;,&#39;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(var&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;strs.Length&nbsp;-&nbsp;1;&nbsp;i++)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&lt;T&gt;&nbsp;src&nbsp;=&nbsp;Nodes.Find(n&nbsp;=&gt;&nbsp;n.Name.Equals(strs[i]));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&lt;T&gt;&nbsp;dest&nbsp;=&nbsp;Nodes.Find(n&nbsp;=&gt;&nbsp;n.Name.Equals(strs[i&nbsp;+&nbsp;1]));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.Add(new&nbsp;Route&lt;T&gt;(src,&nbsp;dest,&nbsp;dest.Prevs[src]));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodes.Add(src);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodes.Add(dest);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(list,&nbsp;nodes);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;路由\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;typeparam&nbsp;name=&quot;T&quot;&gt;&lt;/typeparam&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;Route&lt;T&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Route(Node&lt;T&gt;&nbsp;src,&nbsp;Node&lt;T&gt;&nbsp;dest,&nbsp;int&nbsp;distance)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Source&nbsp;=&nbsp;src;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dest&nbsp;=&nbsp;dest;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Distance&nbsp;=&nbsp;distance;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;开始节点\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Node&lt;T&gt;&nbsp;Source&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;结束节点\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Node&lt;T&gt;&nbsp;Dest&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;距离\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;Distance&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;节点\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;typeparam&nbsp;name=&quot;T&quot;&gt;&lt;/typeparam&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;Node&lt;T&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Node(string&nbsp;name)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;=&nbsp;name;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prevs&nbsp;=&nbsp;new&nbsp;Dictionary&lt;Node&lt;T&gt;,&nbsp;int&gt;();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;节点名\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;前面的节点以及到前一个节点需要的距离\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Dictionary&lt;Node&lt;T&gt;,&nbsp;int&gt;&nbsp;Prevs&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Program\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;void&nbsp;Main(string[]&nbsp;args)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&lt;string&gt;&nbsp;a&nbsp;=&nbsp;new&nbsp;Node&lt;string&gt;(&quot;A&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&lt;string&gt;&nbsp;b&nbsp;=&nbsp;new&nbsp;Node&lt;string&gt;(&quot;B&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&lt;string&gt;&nbsp;c&nbsp;=&nbsp;new&nbsp;Node&lt;string&gt;(&quot;C&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&lt;string&gt;&nbsp;d&nbsp;=&nbsp;new&nbsp;Node&lt;string&gt;(&quot;D&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&lt;string&gt;&nbsp;e&nbsp;=&nbsp;new&nbsp;Node&lt;string&gt;(&quot;E&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetRoutePath(a,&nbsp;b,&nbsp;1);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetRoutePath(b,&nbsp;c,&nbsp;2);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetRoutePath(a,&nbsp;c,&nbsp;2);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetRoutePath(b,&nbsp;d,&nbsp;3);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetRoutePath(c,&nbsp;d,&nbsp;5);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetRoutePath(b,&nbsp;e,&nbsp;9);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetRoutePath(d,&nbsp;e,&nbsp;4);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;Node&lt;string&gt;&gt;&nbsp;nodes&nbsp;=&nbsp;new&nbsp;List&lt;Node&lt;string&gt;&gt;()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;engine&nbsp;=&nbsp;new&nbsp;RouteEngine&lt;string&gt;(nodes);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;(routes,&nbsp;routeNodes)&nbsp;=&nbsp;engine.GetRoutes(a,&nbsp;e,&nbsp;false);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(var&nbsp;x&nbsp;in&nbsp;routes)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(x.Source.Name&nbsp;+&nbsp;&quot;-&gt;&quot;&nbsp;+&nbsp;x.Dest.Name&nbsp;+&nbsp;&quot;:&quot;&nbsp;+&nbsp;x.Distance);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;最长路径：&quot;&nbsp;+&nbsp;string.Join(&quot;-&gt;&quot;,&nbsp;routeNodes.Select(x&nbsp;=&gt;&nbsp;x.Name))&nbsp;+&nbsp;&quot;:&quot;&nbsp;+&nbsp;routes.Sum(r&nbsp;=&gt;&nbsp;r.Distance));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(routes,&nbsp;routeNodes)&nbsp;=&nbsp;engine.GetRoutes(a,&nbsp;e,&nbsp;true);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(var&nbsp;x&nbsp;in&nbsp;routes)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(x.Source.Name&nbsp;+&nbsp;&quot;-&gt;&quot;&nbsp;+&nbsp;x.Dest.Name&nbsp;+&nbsp;&quot;:&quot;&nbsp;+&nbsp;x.Distance);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;最短路径：&quot;&nbsp;+&nbsp;string.Join(&quot;-&gt;&quot;,&nbsp;routeNodes.Select(x&nbsp;=&gt;&nbsp;x.Name))&nbsp;+&nbsp;&quot;:&quot;&nbsp;+&nbsp;routes.Sum(r&nbsp;=&gt;&nbsp;r.Distance));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;void&nbsp;SetRoutePath(Node&lt;string&gt;&nbsp;start,&nbsp;Node&lt;string&gt;&nbsp;end,&nbsp;int&nbsp;distance)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end.Prevs.Add(start,&nbsp;distance);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}",
    "postDate": "2019-01-30T23:40:45.3395967+08:00",
    "email": "admin@masuit.com",
    "label": "数据结构,.NET",
    "keyword": "数据结构,无向图,C#",
    "id": 1388,
    "indexId": "Post:1388"
  },
  {
    "title": "现代企业级互联网应用的架构演变（一步一步打造出高性能的web应用）",
    "author": "懒得勤快",
    "content": "1. 不同系统不同语言之间的交互现在我们常见的不同系统不同语言之间的交互使用RestAPI，Http请求。RestAPI，即“面向资源的WebAPI服务”。从字面上理解，它其实就是“基于Web的服务”。而服务却是双方的，有服务需求方，就有服务提供方。服务提供方对外发布服务，服务需求方调用服务提供方所发布的服务。如果说得再专业一点，RestAPI其实就是建立在HTTP 协议上实现异构系统通讯的工具。没错！RestAPI说白了还是基于 HTTP 协议的，也就是说，数据是通过 HTTP进行传输的。最早我们是用WCF开发SOAP服务实现WebAPI，后面我们是用REST服务实现WebAPI(这个目前使用比较多，也最我用得最多的这一种)。基于WCF也可以开发REST服务，不过我们一般直接使用MVC或者其他MVC框架实现REST服务。但是在很多人的印象中RestAPI的话一般指十来年的基于ajax的各种交互技术，现在除了一些公司在用之外用得人也很少了。广义的话Webservice就是Web服务了，一切皆服务。2. 不同系统相同语言之间的交互常见的不同系统相同语言之间的交互用RPC(远程过程调用)，或者RMI(远程方法调用)实现，不用对外部提供服务，当然上面说的也可以使用在相同语言之间的交互,只是我常用的是RPC。3. 单个产品的架构演进一般我们只是一个单产品的情况下的架构演进过程，如果需要对外提供Web服务，通常使用REST服务实现。1. 分布式架构的初始阶段架构初始阶段的小型系统应用程序、数据库、文件等所有的资源都在一台服务器上。特征：应用程序、数据库、文件等所有的资源都在一台服务器上。描述：通常是服务器操作系统同时部署网站程序、数据库等，汇集各种软件以及一台廉价服务器就可以开始系统的发展之路了。2. 应用服务和数据服务分离的系统架构但是好景不长，我们发现随着系统访问量的再度增加，Web服务器的压力在高峰期会上升到比较高，这个时候开始考虑增加一台Web服务器来做负载均衡。特征：应用程序、数据库、文件分别部署在独立的机器上。描述：数据量增加，单台服务器性能及存储空间不足，需要将应用和数据分离，并发处理能力和数据存储空间得到了很大改善。3. 使用缓存改善性能的系统架构特征：数据库中访问较集中的一小部分数据存储在缓存服务器中，减少数据库的读写次数，降低数据库的访问压力。描述：系统访问特点遵循二八定律，即80%的业务访问集中在20%的数据上。缓存分为本地缓存和远程分布式缓存，本地缓存访问速度更快但缓存数据量有限，同时存在与应用程序争用内存的情况。4. 使用应用服务器集群的系统架构在做完分库分表这些工作后，数据库上的压力已经降到比较低了，又开始过着每天看着访问量暴增的幸福生活了，突然有一天，发现系统的访问又开始有变慢的趋势了，这个时候首先查看数据库，压力一切正常，之后查看Web服务器，发现Web服务器阻塞了很多的请求，而应用服务器对每个请求也是比较快的，看来是请求数太高导致需要排队等待，响应速度变慢。特征：多台服务器通过负载均衡同时向外部提供服务，解决单台服务器处理能力和存储空间上限的问题。描述：使用集群是系统解决高并发、海量数据问题的常用手段。通过向集群中追加资源，提升系统的并发处理能力，使得服务器的负载压力不再成为整个系统的瓶颈。5. 数据库读写分离的系统架构享受了一段时间的系统访问量高速增长的幸福后，发现系统又开始变慢了，这次又是什么状况呢，经过查找，发现数据库写入、更新的这些操作的部分数据库连接的资源竞争非常激烈，导致了系统变慢。特征：多台服务器通过负载均衡同时向外部提供服务，解决单台服务器处理能力和存储空间上限的问题。描述：使用集群是系统解决高并发、海量数据问题的常用手段。通过向集群中追加资源，使得服务器的负载压力不在成为整个系统的瓶颈。6. 反向代理和CDN加速的系统架构特征：采用CDN和反向代理加快系统的访问速度。描述：为了应付复杂的网络环境和不同地区用户的访问，通过CDN和反向代理加快用户访问的速度，同时减轻后端服务器的负载压力。CDN与反向代理的基本原理都是缓存。7. 分布式文件系统和分布式数据库的系统架构随着系统的不断运行，数据量开始大幅度增长，这个时候发现分库后查询仍然会有些慢，于是按照分库的思想开始做分表的工作特征：数据库采用分布式数据库，文件系统采用分布式文件系统。描述：任何强大的单一服务器都满足不了大型系统持续增长的业务需求，数据库读写分离随着业务的发展最终也将无法满足需求，需要使用分布式数据库及分布式文件系统来支撑。分布式数据库是系统数据库拆分的最后方法，只有在单表数据规模非常庞大的时候才使用，更常用的数据库拆分手段是业务分库，将不同的业务数据库部署在不同的物理服务器上。8. 使用NoSQL和搜索引擎的系统架构特征：系统引入NoSQL数据库及搜索引擎。描述：随着业务越来越复杂，对数据存储和检索的需求也越来越复杂，系统需要采用一些非关系型数据库如NoSQL和分数据库查询技术如搜索引擎。应用服务器通过统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。9. 业务拆分的系统架构特征：系统上按照业务进行拆分改造，应用服务器按照业务区分进行分别部署。描述：为了应对日益复杂的业务场景，通常使用分而治之的手段将整个系统业务分成不同的产品线，应用之间通过超链接建立关系，也可以通过消息队列进行数据分发，当然更多的还是通过访问同一个数据存储系统来构成一个关联的完整系统。纵向拆分：将一个大应用拆分为多个小应用，如果新业务较为独立，那么就直接将其设计部署为一个独立的Web应用系统纵向拆分相对较为简单，通过梳理业务，将较少相关的业务剥离即可。\n横向拆分：将复用的业务拆分出来，独立部署为分布式服务，新增业务只需要调用这些分布式服务横向拆分需要识别可复用的业务，设计服务接口，规范服务依赖关系。10. 分布式服务的系统架构特征：公共的应用模块被提取出来，部署在分布式服务器上供应用服务器调用。描述：随着业务越拆越小，应用系统整体复杂程度呈指数级上升，由于所有应用要和所有数据库系统连接，最终导致数据库连接资源不足，拒绝服务。Q：分布式服务应用会面临哪些问题？(1) 当服务越来越多时，服务URL配置管理变得非常困难，F5硬件负载均衡器的单点压力也越来越大。(2) 当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。(3) 接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？(4) 服务多了，沟通成本也开始上升，调某个服务失败该找谁？服务的参数都有什么约定？(5) 一个服务有多个业务消费者，如何确保服务质量？(6) 随着服务的不停升级，总有些意想不到的事发生，比如cache写错了导致内存溢出，故障不可避免，每次核心服务一挂，影响一大片，人心慌慌，如何控制故障的影响面？服务是否可以功能降级？或者资源劣化？11. 产品线的架构还有一种就是上面也有提到的业务拆分。现在我们需要做一个产品线，我们只需要一个数据层，一个通用业务逻辑层，前面还有各种应用和界面层,不需要对外部系统(外部公司的系统)提供服务的情况以前我们一般会选择用EJB等来构建分布式应用，但是现在我们可以使用dobbo、thrift、avro、hessian这类RPC框架来构建分布式应用实现不同应用和数据来源的交互。这种结构模式下我们需要对其他公司提供服务，可以专门写一个应用对外部系统提供rest服务。一般大多数互联网服务背后都要访问十几个甚至几百个内部服务，它们之间的通信方式一般都是RPC：就像访问一个远程方法那样，输入参数后等待返回结果。这对于构建复杂系统是最容易理解的方式。如下图的模型，文件系统，缓存那些没有画出来，大家理解就行。结语：不管哪种架构我们都需要做好模块化(尽量做到模块复用)。不要为了架构而架构导致过度设计。不管何种架构都是为了更好满足业务需求，架构应该跟随业务的发展而发展。当前的架构如果可以满足当前的业务发展，就可以考虑下一步的扩展了，不用一下子考虑3步4步甚至更多。",
    "postDate": "2019-01-30T23:40:45.3396605+08:00",
    "email": "admin@masuit.com",
    "label": "高并发,分布式,云计算,项目管理,互联网",
    "keyword": null,
    "id": 144,
    "indexId": "Post:144"
  },
  {
    "title": "C#经典面试题——深入理解IEnumerable和IQueryable两接口的区别",
    "author": "懒得勤快",
    "content": "不管是现在正在从事.NET相关开发工作，还是现在正在学习.NET的小伙伴，对这两个接口类一定不陌生，也许也能很熟练的运用这两个接口对数据库或者集合进行各种复杂的操作，但是你们可能真的理解这两个类的用途或区别的我想，可能是少数了吧，毕竟面试时也是很多公司技术面试会考到的一个问题。说到用法，可能大家都感觉这两个类似乎用法都一样啊，好像没什么区别，而由这个问题引出的各种系统优化问题，以及很多人吐槽EntityFramework效率低下的问题，那么，今天呢，就来专门针对这些问题做个深入研究咯。无论是使用EntityFramework还是单纯的对List集合进行筛选排序分组聚合等操作，我们经常就是直接Where()、OrderBy()、GroupBy()、Sum()方法调用起走，管他返回是Enumerable还是Queryable，最后总是会得到我想要的结果，那么，它们究竟是如何定义的，都分别用来干什么的？又尤其是IQueryable，它和EntityFramework的延迟加载技术又有什么联系呢？它们是什么？牵出来遛一遛先来看一下这两个类的定义：（1）Enumerable类，继承自IEnumerable&lt;T&gt;接口的集合进行扩展；（2）Queryable类，继承自IQueryable&lt;T&gt;接口的集合进行扩展。它们都在System.Linq命名空间下。再继续深入学习之前，我们先来看一下EntityFramework的实体集DbSet&lt;T&gt;的实现：通过定义我们看到DbSet&lt;T&gt;同时实现了IEnumerable&lt;T&gt;和IQueryable&lt;T&gt;。所以结合起来就是DbSet&lt;T&gt;通过实现IEnumerable&lt;T&gt;和IQueryable&lt;T&gt;在此基础上再有Enumerable和Queryable这两个静态类进行了很多方法的扩展。不过，这么多的扩展方法并不是我们都常用的，在EntityFramework中最常用的也就Where()、OrderBy()、GroupBy()、Sum()这些方法了。同时我们观察其中的Where方法，可以看到第一个参数是实现了IEnumable接口的类，第二个参数是一个Func&lt;T&gt;委托类型。我们继续拿出Queryable的方法定义来看看：观察Where方法，可以看到第一个参数是实现了IQueryable接口的类，第二个参数是一个Expression&lt;Func&lt;T&gt;&gt;的表达式树类型（不知道什么是表达式树的，可以参阅下这篇文章）。Queryable和Enumerable里面的Where既然参数是不一样的，那么它们的用途肯定就是不一样的了，究竟有什么不一样？这种不一样又会造成什么结果？为什么IQueryable的方法都要把Func包在Expression里面？其实我们反编译仔细观察IQueryable的话，实际上也继承了IEnumerable，所以这两个接口的方法，在很大程度上是一样的，那么，微软为什么要设计出两套扩展方法呢？好，下面继续深入研究一下。为了方便大家更直观的理解，接下来就用代码驱动了，透过现象看本质。代码走起我们先建一个控制台程序，然后把EntityFramework包引入，并自动生成一些实体和数据库上下文：static&nbsp;void&nbsp;Main(string[]&nbsp;args)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;using&nbsp;(DataContext&nbsp;db&nbsp;=&nbsp;new&nbsp;DataContext())\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;posts&nbsp;=&nbsp;db.Post.Where(p&nbsp;=&gt;&nbsp;p.Title.Contains(&quot;web前端&quot;));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(Post&nbsp;p&nbsp;in&nbsp;posts)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(p.Title);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}好，我们开始打断点调试程序，注意观察VS的诊断工具或者是你也可以使用SQL Server的Profile工具来跟踪SQL语句的执行；断点命中，但是诊断工具的时间里面什么也没有，我们F10走一步，好，出现了几个ADO.NET的事件，说明有SQL语句执行了，但是，为什么有6个ADO.NET事件，难道执行了6次，我们查看详细信息会发现，这些都是EF在做数据迁移的检查(CodeFirst)，因为SQL语句里面From跟的是_Migration表，这是CodeFirst自动生成帮助EF做迁移用的，这里不做过多的解释，有兴趣的下来可以自己去详细研究下这张表里存的是些什么东西。我们继续F10走一步，依然没执行SQL语句，(眼睛尖的孩子肯定已经看到我第三方调试器已经提示出SQL语句了)，再走一步到in，依然没执行，诶，是不是出什么问题了呢？为什么没有查询语句执行呢？难道是VS诊断工具出问题了吗？那就再走一步看看，好，终于有ADO.NET事件了恩，select…From Post。这就是EF帮我们生成的SQL语句了，很奇怪吧，这就是EF的延迟加载技术，这里面很重要的一部分就是通过IQueryable接口实现的。讲过了Queryable类的Where方法，接下来我们再来看一下Enumable类的Where方法。修改上面的代码如下所示：static&nbsp;void&nbsp;Main(string[]&nbsp;args)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;using&nbsp;(DataContext&nbsp;db&nbsp;=&nbsp;new&nbsp;DataContext())\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;posts&nbsp;=&nbsp;db.Post.AsEnumerable().Where(p&nbsp;=&gt;&nbsp;p.Title.Contains(&quot;web前端&quot;));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(Post&nbsp;p&nbsp;in&nbsp;posts)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(p.Title);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}同样打断点开始跟踪，我们发现用IEnumerable进行筛选的时候，所生成的SQL语句是这样的：对比之前的发现，居然没有where条件语句了！结论所以通过上面的两个测试得出结论：（1）所有对于IEnumerable的过滤、排序、分组、聚合等操作，都是在内存中进行的。也就是说把所有的数据不管用不用得到，都从数据库倒入内存中，只是在内存中进行过滤和排序操作，但性能很高，空间换时间，用于操作本地数据源。（2）所有对于IQueryable的过滤、排序、分组、聚合等操作，只有在数据真正用到的时候才会到数据库中查询，以及只把需要的数据筛选到内存中。Linq&nbsp;to&nbsp;SQL引擎会把表达式树转化成相应的SQL在数据库中执行，这也是Linq的延迟加载核心思想所在，在很复杂的操作下可能比较慢了，时间换空间。（3）操作本地数据源用IEnumerable，操作远程数据源用那么最后的一个问题，IQueryable接口的特殊之处？我们继续观察它的定义:它继承自Ienumerable，但很遗憾，这里面只有几个属性，这IQueryable和IEnumerable到底有什么不同？通过刚才的实例和Queryable的定义我们也看出了区别，所以答案就是：Expression会把查询表达式生成表达式树缓存起来，只有当真正需要用到的时候，才会由IQueryProvider解析表达式树，翻译成sql语句执行数据库查询操作。而Func是个委托，必须要先执行完才能进行下一个方法的调用。更直白点的说，就是：IQueryable是负责生成SQL语句的，但并不马上执行；而IEnumerable是对任意类型的集合都能操作的，不限于是数据库还是一般的Array还是List。所以，这两个类在使用上也不是想用那个就用哪个，所以那些说EntityFramework不行的，你真的理解这两个类么？！只有真正的了解其原理，才能谈性能优化！关于List&lt;T&gt;最后，我们来看看List&lt;T&gt;这个类：List&lt;T&gt;也继承自IEnumerable，所以Where、OrderBy这些方法也能用咯，上代码：static&nbsp;void&nbsp;Main(string[]&nbsp;args)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;List&lt;string&gt;&nbsp;list&nbsp;=&nbsp;new&nbsp;List&lt;string&gt;()&nbsp;{&nbsp;&quot;aaaab&quot;,&nbsp;&quot;caabb&quot;,&nbsp;&quot;abcde&quot;,&nbsp;&quot;uvwxyz&quot;,&nbsp;&quot;qwertyuiop&quot;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;IEnumerable&lt;string&gt;&nbsp;where&nbsp;=&nbsp;list.Where(s&nbsp;=&gt;&nbsp;s.Contains(&quot;x&quot;));\n&nbsp;&nbsp;&nbsp;&nbsp;IOrderedEnumerable&lt;string&gt;&nbsp;orderby&nbsp;=&nbsp;list.OrderBy(s&nbsp;=&gt;&nbsp;s);\n&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;s&nbsp;in&nbsp;@where)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(s);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}同时，List&lt;T&gt;它也是继承了IEnumerable接口，所以，它也不是延迟加载的，但支持延迟查询。static&nbsp;void&nbsp;Main(string[]&nbsp;args)\n{\n&nbsp;&nbsp;&nbsp;List&lt;string&gt;&nbsp;list&nbsp;=&nbsp;new&nbsp;List&lt;string&gt;()&nbsp;{&nbsp;&quot;aaaab&quot;,&nbsp;&quot;caabb&quot;,&nbsp;&quot;abcde&quot;,&nbsp;&quot;uvwxyz&quot;,&nbsp;&quot;qwertyuiop&quot;&nbsp;};\n&nbsp;&nbsp;&nbsp;IEnumerable&lt;string&gt;&nbsp;result1&nbsp;=&nbsp;list.Where(s&nbsp;=&gt;&nbsp;s.Contains(&quot;x&quot;));\n&nbsp;&nbsp;&nbsp;var&nbsp;result2&nbsp;=&nbsp;list.Where(s&nbsp;=&gt;&nbsp;s.Contains(&quot;x&quot;)).ToList();\n&nbsp;&nbsp;&nbsp;list[0]&nbsp;=&nbsp;&quot;xxaab&quot;;\n&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;result1:&quot;);\n&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;s&nbsp;in&nbsp;result1)\n&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.Write(s&nbsp;+&nbsp;&quot;\\t&quot;);\n&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;\\nresult2:&quot;);\n&nbsp;&nbsp;&nbsp;foreach&nbsp;(var&nbsp;s&nbsp;in&nbsp;result2)\n&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.Write(s&nbsp;+&nbsp;&quot;\\t&quot;);\n&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;Console.ReadKey();\n}",
    "postDate": "2019-01-30T23:40:45.3397263+08:00",
    "email": "admin@masuit.com",
    "label": "面试,.NET,C#",
    "keyword": null,
    "id": 171,
    "indexId": "Post:171"
  },
  {
    "title": "会声会影2018旗舰版v21.4.0.165 汉化直装破解版+官方手动破解版",
    "author": "懒得勤快",
    "content": "会声会影 Corel VideoStudio 2018 版本于2018年2月2号推出，会声会影2018版本增加了诸多全新功能，例如：镜头校正/鱼眼校正功能、分割视频画面模块、360度视频编辑、轨透明度等等，另外新增2,000多种独一无二的视频特效、滤镜、渐变效果，同时版本的命名有所变动，新版改为年份来命名，版本不再带X系列，例如上个大的版本为“会声会影X10”，现在则变为“会声会影2018”。视频编辑爱好者们都更新没？会声会影是加拿大Corel公司制作的一款功能强大的视频编辑软件、大型视频制作软件、专业视频剪辑软件。会声会影一直以它的界面美观、素材丰富、操作简洁而受到用户的喜爱，在中国已经超过10多年的历史。修改介绍* 免序列号，一键安装即为简体中文旗舰版激活版* 无需额外执行操作，卸载会随官方卸载程序删除* 本次汉化全部使用重新下载的官方最新旗舰版文件独立汉化制作，未参考和借鉴他人和网上的任何一个第三方文件。* 本次汉化仅设置默认启动页为“编辑”页、优化字号为最佳大小，其他均保持原汁原味的官方原始功能和设置，若要进行“加速”和“优化”，请使用本人的“会声会影2018全能优化大师”进行设置。* 采用语言包方式汉化，增强程序稳定性。增加简体中文语言切换功能，可自由切换英、简、繁三种语言（不建议切换），删除英、简、繁外的多余语言包，以减小程序体积。* 细心汉化每个细节，保证每次点击出来的内容都是简体中文。如：安装、卸载过程全面优化为简体中文界面、修改安装过程轮播内容和图片为2018版新功能、图片中的文字也修改为简体中文、增加桌面快捷图标汉化、「帮助」菜单下：帮助主题、用户指南、新功能、恢复购买、检查更新、消息、消息参数选择等项目均为简体中文。* 精心调整每一处字号都为最佳大小。细心调整每一处位置错乱，如：定格动画、参数选择、影音快手模板设计器等多处文字和功能图标位置错乱都做了修正。* 功能齐全，一步到位，如：添加蓝光光盘刻录组件、增加H.264和XVID编码器汉化版用于会声会影输出自定义尺寸视频、QuickTime解码器插件用于识别MOV格式文件、增加NewBlueFX全部官方转场和滤镜及汉化、32位版本添加20个神奇转场和时间码、分屏滤镜等等。* 优化一系列官方缺陷，如：修正部分转场和滤镜不能自定义的问题、修正滤镜项目名称上鼠标悬停时显示的名称与实际名称不符的问题、修正初始化后新建项目默认比例为6:19（竖屏）的问题、修正输出MPEG-4格式文件默认比例为6:19（竖屏）的问题、修正输出MPEG-4格式文件选择高场优先时渲染完程序崩溃的问题、修正分屏模板创建器心形和月亮形不能放到顶层的问题、修正转场和滤镜不能拖动位置的问题（第二次启动的第二次拖动才有效）等等。软件介绍* 调整大小和裁剪视频工具2018拥有更直观的用户界面，用户可以更快、更轻松的编辑视频。通过预览窗口可以直接的裁剪视频、调整素材大小，给您快速的使用效果。* 分屏视频新增的分屏视频模板可以同时显示多个视频流，用户只需要轻松拖放就可以创作出令人印象深刻的宣传或旅游视频，分享视频中的亮点。同时，您也可以在会声会影中使用模板创建器来创奇自定义分屏界面。* 镜头校正工具全新直观的控制功能可以快速消除广角相机或动作相机中的失真，让你轻松的将视频中的有趣部分剪辑出来。* 平移和缩放平移和缩放功能可以放大动作、平移场景，使用易于使用的软件，通过自定义运动路径将视频平移和缩放效果应用于视频。* XAVCS 到 SD会声会影2018新增XAVC-S格式支持，以便您可以将制作好的视频导出到SD卡上，并直接在相机上播放。* 增强了 360 度视频编辑软件新增对流行的360度相机的扩展支持，我们只需要导入360度镜头就可以开始编辑视频，同时还可以将360视频直接导出到YouTube，VR耳机等。* 增强了定格动画现在支持所有流行的佳能和尼康相机和增强型控制功能，插入相机并逐帧捕捉动画，帮助您完美捕捉您的定格动画。* 增强平滑和更快的渲染会声会影为来自英特尔和 nVidia 的最新视频硬件加速技术进行了优化，可提高渲染效率并将视频渲染成流行的文件格式。官方版破解方式完整旗舰版安装方法首先下载解压完整旗舰版安装包；VideoStudio Ultimate 2018 Retail Setup (32-bit)\\32bit\\Ultimate1）解压Patch.zip，把 patch.exe 放到上面的路径下双击运行下即可；2）双击 Setup.exe 安装，打开Serial.txt复制序列号粘贴到安装界面；3）安装完后即为已授权的旗舰版完整版；这时可以找汉化包去汉化；会声会影2018 SP4 v21.4.0.165 更新补丁官方下载链接http://dwnld.videostudiopro.com/VideoStudio2018/WebInstaller/21.4.0.165/Patch/VS21.4.0.165.exe会声会影2018升级SP3后无法正常启动的解决办法2018年3月26号，Corel公司为会声会影2018版本推送了SP2更新补丁，但是不少朋友都发现更新之后软件无法正常打开，启动有个乱码提示，其实这个乱码提示只有简体中文版(就是汉化版)上才会是乱码，英文版上显示的是\\&quot;You do not appear to be aregister user.Please re-install the application or call customer support with error 1011”（翻译过来就是你似乎不是已注册用户，请重装软件或者联系客服）。问题解决办法：点击下载会声会影2018官方下载器，依次点击下一步，到达下载路径界面 (如下图），关闭下载器，现在启动会声会影没有乱码了，成功解决！为什么会这样？这是Corel加公司为了强防盗版的一措施目的是让大家都从下官方载器安装会声会影，会而声会影主程序会验证你是否打开过下载器，没如果有用过下载器就会提示乱码，而大部分人用的都是破解版的替换了dll的离线安装版），所以才会示乱码（盗版提示）。下载说明官方旗舰版原版是英文，完整旗舰版镜像大小：x86(4.95GB) + x64(5.38GB)&nbsp;直装破解版安装后为简体中文。Patch是跳过下载器检验补丁，如不通过官方下载器安装，程序无法启动；此补丁实际上就是模拟下载器已写入缓存文件，跳过下载器正常安装启动.激活可以用注册机生成序列号&nbsp;Corel Products KeyGen 2018 – XFORCE.下载地址附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!软件安装包为会声会影官网安装包，并非来自国内某丁公司，并且版本号为v21，并非v1版本。支持正版请到：https://www.videostudiopro.com，所谓的中文官网均为盗版。github下载地址：https://github.com/ldqk/Corel-VideoStudio磁力下载：magnet:?xt=urn:btih:863197813D84D2433CB7DC51E2D0A239ADDDF4BF全套插件介绍：https://masuit.com/182解压密码：masuit.com需要百度云链接的小伙伴请看下面：感谢 @暗δ 月考不比zc高不改名&nbsp;和 @咸鱼 分享为了节省你的时间，请您多花2分钟仔细阅读以下内容，否则因理解失误造成的时间浪费请自行解决！百度云的下载链接容易被狗咬，为了确保你不是某丁来故意骚扰捣乱的，大家也看到了最近博主Q号连续被封，所以，需要该资源的小伙伴们请将以下任意一个链接公开分享到你的任意社交平台上(如:QQ空间、微信朋友圈、微博)。达标后联系博主进行邮箱登记后，便可访问本站所有加密资源，一次分享，永久有效哦！https://masuit.com/1248https://masuit.com/1231https://masuit.com/1246https://masuit.com/1215https://masuit.com/1233https://masuit.com/1223https://masuit.com/1241https://masuit.com/1252https://masuit.com/1247https://masuit.com/1296博主QQ：3444764617分享要求：1.保持24小时以上凭截图QQ私信博主免费获取文章密码，网页右边有分享按钮。这也是没有办法的事情，文件太大了，没办法传到github和本站服务器上，只能通过百度云链接私信发了。2.分享时需保留文章原标题和原链接，必须完全公开分享，且不能包含有任何暗示性的求赞或求评论等语言文字，否则视为无效，分享后需集齐30赞，或10有效评论。3.未以上标准的就想来获取下载链接的，分享要求将重新定义为：保持3天以上，并且需集齐至少40赞或15有效评论！！！不要跟我承诺说我分享后绝对不删除之类的，在要求没满足之前我只认上述条件！！！4.如果你有其他更有力的证明你不是某丁的水军，可免分享获得本站所有加密文章的通行权(推荐做法)。",
    "postDate": "2019-01-30T23:40:45.3397932+08:00",
    "email": "admin@masuit.com",
    "label": "会声会影,绘声绘影",
    "keyword": "会声会影,会声会影2018旗舰版,会声会影破解版,会声会影2018旗舰破解版,绘声绘影,绘声绘影2018,绘声绘影破解版",
    "id": 181,
    "indexId": "Post:181"
  },
  {
    "title": "CorelCAD 2018.5中文破解版下载 32/64位",
    "author": "懒得勤快",
    "content": "corelcad 2018.5是corelcad2018的半年升级版本，提供的卓越2D草图和3D设计工具带来的精准度，增强视觉传达效果，是绘制技术设计所需详细元素的智能实惠的解决方案。此次为大家提供的是最新的corelcad 2018.5破解版，相比之前的版本，新增加了支持图形Web格式(DWF)，兼容.DWG、.STL、.PDF 和 .CDR行业标准文件，能够以.DWG格式打开、编辑和保存文件，轻松实现与同事和供应商的协作。其次corelcad 2018.5还新增加了以递增的方式移动对象，使用复制命令加速您的工作流程，以便快速将所选对象复制到活动图层，而不是源图层。新增螺旋工具能够创建 2D螺纹和3D螺纹，为设计师带来不一样的创作理念。需要的用户来本站下载吧。corelcad 2018.5新功能和增强功能：1、增强功能：本地 .DWG 文件以 .DWG 格式打开、编辑和保存文件，轻松实现与同事和供应商的协作。使用最新版 AutoCAD R2018 .DWG 文件格式提升与内部团队和外部供应商进行项目共享的效率，确保与业务合作伙伴实现顺畅无忧的合作。2、增强功能：符合行业标准的 CAD 功能corelcad 2018.5与所有主要 CAD 程序兼容，因此经验丰富的用户可以得心应手地使用熟悉的命令栏、命令别名、菜单项以及工具栏项。3、增强功能：3D 实体编辑和建模工具借助更快速的屏幕编辑工具，节省宝贵的设计时间。通过增强对象夹点和“特性”面板，可实现 3D 编辑并可在 3D 中提供直观的操作功能。向设计添加 3D 实体图元，并使用布尔运算来组合、交叉和减去物体。使用高级编辑工具，如 3D 实体的圆角边缘和 3D 实体各个面的着色、移动、旋转和偏移。4、增强功能：表格支持使用新增的 ExportTable 命令将表格导出为逗号分隔的格式 (CSV)，并在 Microsoft Excel 或数据库应用程序中导入 CSV 文件。在表格中，您可以向单元格添加公式，还可以对单元格进行插入、删除、合并等操作，还可以调整现有表格中单元格、行和列的大小。5、增强功能：对象对齐和对象夹点使用 CorelCAD 智能工具，如对象对齐、夹点和极轴引导，快速将对象重新定位、对齐、复制或调整尺寸。增强对象夹点可提供 3D 编辑和直观操作功能。当您将鼠标悬停在任何对象夹点上方时，只需使用上下文快捷菜单，便可在适当位置立即编辑对象的几何形状。6、新增功能：螺旋工具使用全新螺旋工具提升造型功能，以创建 2D 螺纹和 3D 螺纹，以便在圆柱图形周围提供带有单层三维图形的任意对象，如弹簧或螺旋楼梯。7、增强功能：MultiLeader 和智能标注工具绘制、编辑并配置带有多重引线的标注。该工具使用方便，允许您对 MultiLeader 工具中的引线进行增删，以便根据绘图的变化进行调整和编辑。使用可精确测量的标注工具和智能标注工具将自动提示最合适和最精确的标注类型。8、新增功能：以递增的方式移动对象使用复制命令加速您的工作流程，以便快速将所选对象复制到活动图层，而不是源图层。使用增强粘贴命令将剪贴板中的内容复制到活动图层，而不是源图层，或者选择 Shift + 箭头键的方式以特定的增量移动选定的对象。9、增强功能：管理 BlockAttribute 属性和设置使用图块支持功能对图块（符号）定义中的 BlockAttribute 属性和设置进行编辑。通过几个按键，您就可以改变插入图块时出现的 BlockAttribute 属性值提示信息的顺序，您可以根据图块属性管理器中的设置对图块的所有实例进行同步，还可以从图块中删除 BlockAttributes。10、增强功能：增强的性能从已针对最新操作系统（包括 Windows 10 和 macOS High Sierra）进行了优化且具有用户界面直观更新的新版本中，获得实现所需功能需要的计算机辅助设计软件的优势。11、增强功能：CorelCAD Mobile借助 CorelCAD Mobile — CorelCAD 的最新平板电脑版（iOS 和 Android 版，完善了现有的 PC 和 Mac 平台），随时随地进行设计和标注。CorelCAD Mobile 可作为一个具有基础功能的免费配套应用程序，也可以作为一个具有完整功能和编辑能力的订购产品。软件特色1、直观探索全新增强型二维绘图和三维建模工具，为任何计算机辅助设计项目带来完美准确度。快速输入、注释缩放、平视显示等快速响应性工具所带来的设计优势，使功能进一步增强，以保持高精确度。2、强大通过复杂的 CAD 引擎（由 ARES 提供技术支持）与屡获殊荣的 CorelDRAW 技术的强强联合，将关键图形与工作流程相整合，带来高水平的 CAD 性能体验。提高任何 CAD 项目的效率，并借助额外的 CorelCAD 插件扩大 CAD 优势。3、用途广泛使用 Windows Ribbon 或经典的 UI 工作区传达您的日常 CAD 设计要求，以取得图形优势。凭借为您的需求量身定制的高水平制图和设计工具，让您每次都能收获丰富的视觉效果和骄人的成绩。4、价格低廉获得符合您的 CAD 设计要求及公司预算的行业标准工具。使用全新的 CorelCAD Mobile，在您选择的平台上（Windows、Mac 或 Android）轻松设计。以大部分 CAD 软件选项的一小部分成本，获得一个完整的解决方案，满足您的一切所需。5、效率和生产率利用CorelCAD 2018提供的高级绘图和设计工具的精确性扩展您的视觉交流专业知识。通过增强的用户界面和新的节省时间的特性，您可以增加工作流程并交付令人印象深刻的、视觉丰富的CAD设计。6、二维绘图获得你需要的设计能力和大量的专业绘图工具，为任何项目提供你所需要的控制和细节。CorelCAD 2018提供了新的螺旋工具，用于二维螺旋，高级的表格工具，以及一个多领导工具，以配置和调整呼叫，随着您的图纸的发展。7、三维设计体验CorelCAD 2018 3D功能熟练精准的效果，将您的图纸从2D绘图过渡到先进的3D设计。通过一系列专家和直观的3D工具，包括增强的实体握把和属性面板，您可以很好地从项目草图到3D输出和打印。8、兼容性和优化简化与内部团队和外部供应商的项目共享。CorelCAD 2018与最新版本AutoCAD R2018 . dwg文件格式完全兼容，以确保与业务合作伙伴的协作无虞，并包含创新的定制和自动化支持选项，以配合任何工作环境。破解教程：1、下载解压，得到corelcad 2018.5 32/64位中文版原程序和破解文件；2、双击文件“CorelCAD2018_x64.exe”开始安装；3、软件默认安装目录为【C:\\Program Files\\Corel\\CorelCAD 2018\\】可以自行更改，同时在桌面上创建快捷方式；4、等待软件安装完成；5、成功安装后，先不要运行软件，将破解文件“CorelCAD.exe”复制到软件目录【C:\\Program Files\\Corel\\CorelCAD 2018\\BIN】替换即可破解；6、至此，corelcad 2018.5中文破解版成功激活，用户可以无限制免费使用。下载地址为了节省你的时间，请您多花2分钟仔细阅读以下内容，否则因理解失误造成的时间浪费请自行解决！百度云的下载链接容易被狗咬，为了确保你不是某丁来故意骚扰捣乱的，大家也看到了最近博主Q号连续被封，所以，需要该资源的小伙伴们请将以下任意一个链接公开分享到你的任意社交平台上(如:QQ空间、微信朋友圈、微博)。达标后联系博主进行邮箱登记后，便可访问本站所有加密资源，一次分享，永久有效哦！https://masuit.com/1248https://masuit.com/1231https://masuit.com/1246https://masuit.com/1215https://masuit.com/1233https://masuit.com/1223https://masuit.com/1241https://masuit.com/1252https://masuit.com/1247https://masuit.com/1296博主QQ：3444764617分享要求：1.保持24小时以上凭截图QQ私信博主免费获取文章密码，网页右边有分享按钮。这也是没有办法的事情，文件太大了，没办法传到github和本站服务器上，只能通过百度云链接私信发了。2.分享时需保留文章原标题和原链接，必须完全公开分享，且不能包含有任何暗示性的求赞或求评论等语言文字，否则视为无效，分享后需集齐30赞，或10有效评论。3.未以上标准的就想来获取下载链接的，分享要求将重新定义为：保持3天以上，并且需集齐至少40赞或15有效评论！！！不要跟我承诺说我分享后绝对不删除之类的，在要求没满足之前我只认上述条件！！！4.如果你有其他更有力的证明你不是某丁的水军，可免分享获得本站所有加密文章的通行权(推荐做法)。附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!",
    "postDate": "2019-01-30T23:40:45.339859+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "corel,CAD",
    "id": 1309,
    "indexId": "Post:1309"
  },
  {
    "title": "CorelDraw 2018中文破解版下载 32位/64位完整版 v20.1.0.707",
    "author": "懒得勤快",
    "content": "corel draw 2018中文破解版是目前行业软件中最优秀的一款技术插图和制图软件，拥有全面的专业应用程序套件，包括Corel DESIGNER 2018、Corel DRAW 2018、Corel PHOTO-PAINT 2018、XVL Studio Corel Edition、Corel CONNECT 2018和Corel CAPTURE 2018六大套件，可以制作详细的装配说明书、复杂的用户手册、多用途文档材料等，是专用插图和设计工具。corel draw 2018具备全面、精准、高效能、创新、直观五大特色，用户利用功能多样的设计工具，可以设计视觉效果精确符合规格的详细装配说明书、复杂的用户手册、多用途文档材料和技术营销材料。同时创新的工具可以探索突破性草图和插图工具，呈现专业技术制作，让广大受众获得美好体验。更支持从打开 2D、3D、图片、文件和数据等来源文件到支持打印、在线和移动输出，体验无缝工作流程。corel draw 2018中文破解版还新增SharePoint CMS 集成功能，Corel DESIGNER 和 CorelDRAW 与 Microsoft SharePoint 站点连接实现的额外协作和共享优势，通过视觉沟通制作应用程序直接访问您的组织的文档管理系统 (DMS)。同时软件与最新的文件格式兼容，可以从100多种最新矢量图形、位图图像、文档及导入和导出功能支持的其他数据文件格式中选择。扩展的文件格式支持，包括 SVG、CGM、DWG 和 DXF、PDF、TIFF 和 Adobe CS/CC（AI、PSD）。支持AutoCAD DWG/DXF，提升和更新后的 .DWG 文件（AutoCAD、CorelCAD™ 和其他文件）和 .DXF 文件支持可确保方便无错误的数据转换。导入和导出时具有增强版 .DWG/.DXF 文件可编辑维度支持功能。软件功能：一、 全面1、高效的三维模型和可视化使用技术图解中的三维视图和模型为技术项目添加上下文。您可以利用 XVL Studio Corel Edition 集成 CorelDRAW Technical Suite 2018，在从 DWG、3DS 或 IGES 3D 模型文件导入的三维视图中创建高品质渲染效果。您可以使用增强型“发送至 Corel DESIGNER”功能将这些三维视图轻松转换为矢量图。2、与最新的文件格式兼容全方位支持技术发布标准、最新版 .DWG CAD 文件导入和 100 多种其他数据文件格式，进而利用您需要的所有功能，以便发布、共享和输出重要的技术文档。使用各种不同的跨媒体发布和分发功能，包括 CGM、WebCGM（包括 S1000D 4.2）、SVG 和 PDF 格式，您可以确保所有重要技术文档将采用可读的格式发送。3、Corel DESIGNER 为您提供精准技术插图基于矢量的图形应用程序能够提供多种相关图形设计功能以及创建详细工程图纸所需的工具，为您提供更准确的技术插图。Corel DESIGNER 2018 被誉为完整的技术设计和沟通解决方案的核心应用程序。4、CorelDRAW 可以提供创新设计技术使用 CorelDraw 2018 中的多种图形设计工具，让任何插图式或营销类沟通项目更加创新，工作效率更高，更加具有创意。采用量身定制的界面和无与伦比的定制功能，畅享无缝设计经验，以提升工作效率并输出可交付成果。5、Corel PHOTO-PAINT 可以提供渐进式图像编辑能力使用全新的交互式图像矫正和直观的透视角度调整等 Corel PHOTO-PAINT 2018 特有的照片编辑功能将高品质照片用于您的绘图项目。使用专业级的工具，可以确保无论使用任何分辨率，视觉沟通材料中使用的照片都可以保证准确、清晰。6、三维 PDF 发布发布为三维 PDF，交互式查看三维内容以及其他视觉或文本元素。从 Corel DESIGNER 导出为三维 PDF，在一个文档中生成包含所有相关数据和图形的输出内容，用于跨媒体发布。可使用几乎所有台式机或笔记本电脑上安装的免费 PDF 阅读器应用程序查看三维 PDF 文件。7、Corel Font Manager通过直观易用的 Corel Font Manager 组织并管理您的字体库，无需安装即可直接使用常用字体，并使用网络存储功能更快地使用字体。快速查找并安装适合您技术插图项目的字体、整理字体方便使用、或管理不需要的字体。此外，您可以浏览并搜索在线字体和本地字体，浏览字体轮廓沟槽集，创建字体集等。8、高级自动化功能使用集成的 Microsoft Visual Studio Tools for Applications (VSTA) 和 Visual Basic for Applications (VBA)，创建宏和插件。通过增强的自动化界面，开发人员可以创建能够与绘图页面交互的实用程序和宏。通过最新的课程和方法，现在您能够在 CorelDRAW Technical Suite 中创建更强大的实用程序和宏，以增强应用程序。二、精准1、设计工具通过全新的高水平特色功能实现无可比拟的工作效率，以便提升工作流效率。通过可以确保等角绘图、详细标注和扩展性尺寸标记功能准确性和精确度的一系列专用绘图工具提升技术沟通材料的水平。2、等距绘图工具通过在投影的平面上动态绘图，为装配和维护说明书创建等距或其他平行投影技术插图。将现有的平面对象投影到所需平面，而不是手动计算斜移角度和旋转。使用 Corel DESIGNER 中的 UI 控件获得更为精准到位的设计效果，用户还可以使用等角和其他投影绘图工具中的准确测量结果绘制图形并对其进行编辑。3、对齐与分布节点使用选择边界框、页边或中心、最近的网格线或指定点对齐并分发节点。分布节点同样简单，在水平或垂直方向添加相同的间距。4、高级度量工具得益于高级度量工具，消除在多步骤中绘制和投影度量对象的需求。在建筑平面图等文件中显示精确的测量值，包括半径和直径标注。此外，通过投影的度量选项，可以使用精确的动态尺度线和文本快速记录您投影的绘图。5、精确的图解工具使用投影的形状工具（包括线程、方格、柱面和棱柱工具），为您的技术图解添加更高层次的细节。在投影的空间内，快速轻松绘制线程和方格形状，用于创建螺栓、螺母等。6、精确的布局和绘图工具轮廓位置选项可识别对象尺度的线宽测量值，通过此选项，精确捕获您想要的绘图形状。使用动态辅助线，使技术插图的所有元素直观、精确地置于目标位置。使用 Corel DESIGNER 中的平行绘图模式，加速创建管道和电线等各类技术图形。7、简化的标注创建通过动态标注工具，追踪重要的设计细节和关键信息。四处移动或修改源对象时，粘贴标注将连接或&quot;粘&quot;在源对象上。您还可以将标注文本链接至源形状元数据。基于对象元数据的标注是动态的，可帮助您高效、一致地实施更新和更改。8、绘图比例控制使用绘图比例控制，按照准确比例创建图解和图表。随时查看有效绘图比例，切换至其他预设或设置自定义比例。此外，从三维模型视图中导入矢量图解时，Corel DESIGNER 保持绘图比例，以便按照精确比例放置已导入视图。三、高效能1、SharePoint CMS 集成CorelDRAW Technical Suite 2018 企业级许可证客户专享 Corel DESIGNER 和 CorelDRAW 与 Microsoft SharePoint 站点连接实现的额外协作和共享优势，让您能够立即通过视觉沟通制作应用程序直接访问您的组织的文档管理系统 (DMS)。2、AfterShot 3 HDR从已安装套件应用程序内部下载 Corel AfterShot 3 HDR，以便进行专业级纠正，并对 RAW 或 JPEG 照片进行强化。使用 AfterShot 3 HDR 内含的 HDR 模块创建高动态范围 (HDR) 图像 。3、翻译记忆系统 (TMS) 工作流制作包含说明性文本的插图，然后将译文直接输出到翻译记忆库系统 (TMS)，并通过 Corel DESIGNER 对翻译结果进行处理，进而实现技术材料的全球多语种发布。现在，您可以将跨多个列的文本格式化，并使用 Corel DESIGNER 制作完整的用户手册或文档。然后，发送源语言文本进行翻译并接收译文，以便一键创建本地化文档。4、可选：三维 CAD 再利用功能选择 XVL Studio 3D CAD 插件选项获得动画工具并处理三维 CAD 工程文档。XVL Studio 3D CAD Corel Edition 新增本地三维 CAD 文件格式支持功能，以确保支持三维 CAD 系统中的组件和部件，包括 CATIA、Inventor、PTC Creo、SolidWorks、NX 与三维 CAD 交换文件格式（如 STEP、JT 等）。5、可选：自动三维 CAD 到插图更新功能和三维发布使用 XVL Studio 3D CAD 高级插件，您可以利用简化的自动检测和更新功能，在工程数据更改时对 3D-CAD 源插图进行更新。此外，能够以三维 PDF 或 XVL 文件格式发布动画三维可视化，通过在线和移动实现即时共享和发布。6、热点功能使用 Corel DESIGNER 中的标注绘图工具，为技术出版物中的标注形状增添交互功能。借助“对象数据管理器”泊坞窗，您可以为任何图形或标注形状列出元数据字段，如 WebCGM 元数据。对象数据项目可进行编辑，因而，形状可作为 WebCGM 输出的热点，进行手动编辑。7、对象样式借助对象样式、颜色样式和颜色和谐，在整个设计项目中保证始终如一的外观、样式和布局。借助 Corel DESIGNER 中的增强型对象样式，您可以管理对象样式，如轮廓颜色、线条样式、线宽、光环、填充类型和颜色及文本样式。然后，您可以创建可在项目中访问并使用的符号库。重用您之前创建的样式定义，并应用于自定义符号中的单独组件。8、方程式编辑器使用集成的方程式编辑器，在技术图解中将数学方程式作为可编辑元素进行管理。可在绘图中插入并显示数学和科学方程式，然后在需要时进行修改。可打开或导入较早之前的 CorelDRAW 文档中的现有方程式，以用于 Corel DESIGNER 方程式。9、二维码生成器使用 Corel DESIGNER，创建省时的二维码，并将可扩展二维码添加到绘图*，从而使该领域的技术人员能够通过移动设备从印刷文档或机器标签链接到在线技术文档。10、提高性能和技术支持利用多监视器和超高清显示器支持功能。您可以立即打开并编辑更多较大文件，并且可以在本机 64 位更快速地处理较大文件和图像，同时支持多核最新硬件。四、创新1、发布至 WordPress将您的作品直接从应用程序中发送至 WordPress 媒体库。通过此新增功能，您可将选定对象或整个项目转换为 JPEG、GIF 或 PNG 文件，然后上传到 WordPress 帐户。2、添加透视效果在绘图窗口直接将透视效果应用至位图、矢量图对象或同时应用至两种对象，快速打造距离和景深特效。一款可以在真实场景中呈现技术插图的巧妙工具。3、为位图应用封套将位图放入封套并拖动其节点，以交互方式调整位图形状。使用封套预置参数值或从头创建自定义封套，快速无缝地将位图混合到插图中。4、节省时间的 LiveSketch工具在移动中绘制草图和设计！LiveSketch 是一个具有革命性的绘图工具，这款软件的开发和设计完全基于人工智能和机器学习的最新发展。形式自由的草图可转换为精准的矢量曲线。5、Microsoft Surface Dial 支持可以更好的支持 Microsoft Surface Dial 等旋钮设备。通过仅使用触控和旋钮设备的创作模式体验更直观的备选 CorelDraw 或 Corel DESIGNER 工作方式。丢掉键盘，尝试全新的上下文触屏 UI。6、功能强大的触控笔功能除了 Wacom 手写板和设备，通过兼容 Windows 实时笔的手写板（如 Microsoft Surface）可以更加自如地控制，快速高效地工作。使用压力改变橡皮擦笔尖的大小，并通过倾斜和方位调整控制其平滑度和旋转方式。翻转触控笔或画笔即可激活橡皮擦工具，无需使用工具箱即可快速进行擦除操作。7、GPU 加速位图预览无需占用系统资源即可重新定位并编辑复杂的矢量图形。使用图形处理单元 (GPU) 可以加速在某些机器上的 Corel DESIGNER、CorelDRAW 和 Corel PHOTO-PAINT 中对图片进行显示、编辑和操作的过程。五、直观1、对称绘图模式实时创建对称设计图，从简单的对象到复杂多变的特效，并为平时耗时的工作流程实现自动化，提升生产效率。2、通过交互方式矫正图片通过将修齐条与照片中的元素相互对齐或指定旋转角度的方式旋转扭曲图像。所有控件可在屏幕或属性栏中轻松访问，可在几分钟内实现完美效果。3、交互式调整照片透视使用交互式透视校正工具调整照片中建筑物、地标或物体的透视角度。只需将四个边角点排列成矩形形状，即可调整整张照片。4、轻松访问设计资源使用内置的内容助手 Corel® CONNECT，立即在本地网络上查找图像，并搜索在线门户和网站，轻松访问内容。可以在由 Corel DESIGNER、CorelDRAW、Corel PHOTO-PAINT 和 Corel CONNECT 共享的托盘中，按类型或按项目组织资源，最大限度地提高效率。通过 Microsoft OneDrive，利用内容中心和托盘同步选项。5、触摸友好的用户界面通过触摸屏幕或使用触控笔快速调整。通过仅显示最常使用的工具和命令，触摸工作区会最大化绘图窗口大小，这样您可以使用单个手势进行摇动和缩放。6、完全控制填充和透明度与 Corel DESIGNER、CorelDRAW 和 Corel PHOTO-PAINT 搭配使用或在其中对填充物和透明度进行管理时，尊享全新设计的填充物和透明度选择器，它有助于提高生产效率，提供更好的性能。系统要求1、Windows 10、8.1 或 Windows 7（32 位或 64 位），全部安装最新更新和 Service Pack2、Intel Core i3/5/7 或 AMD Athlon 643、2 GB RAM4、1 GB 硬盘空间5、多点触摸屏、鼠标或平板电脑6、1280 x 720 屏幕分辨率，比例为 100% (96 dpi)7、Microsoft Internet Explorer 11 或更高版本8、Microsoft .Net Framework 4.69、可选 DVD 驱动（用于箱安装）10、Internet 连接下载地址：磁力下载：magnet:?xt=urn:btih:A08CE2B513949AF96E44D72469723C3C0B83EBF9解压密码：masuit.com百度云下载为了节省你的时间，请您多花2分钟仔细阅读以下内容，否则因理解失误造成的时间浪费请自行解决！百度云的下载链接容易被狗咬，为了确保你不是某丁来故意骚扰捣乱的，大家也看到了最近博主Q号连续被封，所以，需要该资源的小伙伴们请将以下任意一个链接公开分享到你的任意社交平台上(如:QQ空间、微信朋友圈、微博)。达标后联系博主进行邮箱登记后，便可访问本站所有加密资源，一次分享，永久有效哦！https://masuit.com/1248https://masuit.com/1231 https://masuit.com/1246 https://masuit.com/1215 https://masuit.com/1233 https://masuit.com/1223 https://masuit.com/1241 https://masuit.com/1252 https://masuit.com/1247 https://masuit.com/1296博主QQ：3444764617分享要求：1.保持24小时以上凭截图QQ私信博主免费获取文章密码，网页右边有分享按钮。这也是没有办法的事情，文件太大了，没办法传到github和本站服务器上，只能通过百度云链接私信发了。2.分享时需保留文章原标题和原链接，必须完全公开分享，且不能包含有任何暗示性的求赞或求评论等语言文字，否则视为无效，分享后需集齐30赞，或10有效评论。3.未以上标准的就想来获取下载链接的，分享要求将重新定义为：保持3天以上，并且需集齐至少40赞或15有效评论！！！不要跟我承诺说我分享后绝对不删除之类的，在要求没满足之前我只认上述条件！！！4.如果你有其他更有力的证明你不是某丁的水军，可免分享获得本站所有加密文章的通行权(推荐做法)。附: 二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!",
    "postDate": "2019-01-30T23:40:45.3399226+08:00",
    "email": "admin@masuit.com",
    "label": null,
    "keyword": "CorelDraw,corel,破解版,Corel Draw",
    "id": 1270,
    "indexId": "Post:1270"
  },
  {
    "title": "谈一谈.NET中的并行编程(TPL)——多线程、异步、任务和并行计算",
    "author": "懒得勤快",
    "content": "写在前面：在做了几个月的高并发项目的过程中，其实发现自己真的提升了不少，所以也想把这段时间的收获分享给大家，然后写这篇文章发现，写下来是一发不可收拾，所以这篇文章的内容可能会很长，当然也希望能够给大家带来收获。在开发过程中，有很多工作我们都需要去开线程来解决，但是多线程往往会带来更多棘手的问题，但又不得不使用多线程，由多线程带来的传值、取值、资源同步、线程取消或暂停、异常的捕获等都会困扰着我们每一个编写这类代码的开发者。微软也在这方面做了巨大的努力，以至于到现在的.Net Framework和.NetCore都有非常丰富的多线程API可以选择，方便去编写多线程代码，同时又带来了一个问题：线程、异步、任务、并行计算等太多了，我该选择哪个？接下来就让我们一起来由浅入深的去熟悉线程、异步、任务，从是什么到为什么，追溯事物的本质，以及任务为什么还衍生出了并行计算(Parallel)，同时还告诉大家如何优雅的去控制线程，以及处理异步、任务和并行计算中的异常。多线程编程(TPL)是我们所有开发人员职业生涯中曾经或是现在的一道坎，所以，我们必须战胜它！不过，在阅读本文章之前，你还是必须得有基本的TPL编程基础，最起码，线程、异步、任务的基本使用还是要会的。多线程和异步相信很多初学者学过多线程和异步之后，都会把异步和多线程混为一谈，如果对它们之间的区别不是很清楚的话，就很容易写出下面的代码：private&nbsp;void&nbsp;button1_Click(object&nbsp;sender,&nbsp;EventArgs&nbsp;e)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(()&nbsp;=&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;client&nbsp;=&nbsp;new&nbsp;WebClient();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;s&nbsp;=&nbsp;client.DownloadString(&quot;https://www.google.com&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageBox.Show(s);\n&nbsp;&nbsp;&nbsp;&nbsp;}).Start();\n}以上代码模拟在一个WinForm程序中，单击按钮获取某个网页的html代码并弹窗显示出来，可以预见，如果网页的内容特别多，或者因为特殊的网络原因，获取网页内容时间比较长，所以我们开线程去完成这项工作，防止阻塞UI线程。确实，这样解决了UI线程被阻塞的问题吗，但是，它高效么？答案是否定的，要理解这一点，需要从计算机组成原理说起，其实我们的电脑主机的硬件里面，有很多零件是具备“IO操作的DMA(Direct Memory Access)模式”，DMA即直接内存访问，顾名思义，就是一种不经过CPU就可以直接访问内存数据的一种数据交换模式。通过DMA模式的数据交互几乎不耗CPU资源，比如我们电脑机箱里面的硬盘、声显网卡等都具有DMA功能，而我们.NET中CLR所提供的异步编程模型就是让我们充分利用硬件DMA功能来转移CPU的压力。知道了这一点，我们再来分析下上面的这个例子，我们可以画图来阐述下：为了下载网页内容，CPU新起了一个线程，然后在下载网页的整个过程中，该线程会始终占用着CPU资源，直到网页被下载完成。这就意味着CPU的资源一直被消耗，浪费，等待着。如果我们改用异步去实现，代码如下：private&nbsp;void&nbsp;button1_Click(object&nbsp;sender,&nbsp;EventArgs&nbsp;e)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;client&nbsp;=&nbsp;new&nbsp;WebClient();\n&nbsp;&nbsp;&nbsp;&nbsp;client.DownloadStringCompleted+=(ssender,&nbsp;ee)&nbsp;=&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageBox.Show(ee.Result);\n&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;client.DownloadStringAsync(new&nbsp;Uri(&quot;https://www.google.com&quot;));\n}上面的代码工作机制就可以这样描述了：经过改造后的代码采用了异步模式，它的底层使用线程池进行管理，异步操作启动时，CLR会将下载网页操作这部分工作丢给线程池中的某个线程去执行。当开始IO操作时，异步会把工作线程还给线程池，这时候就相当于下载网页的这个工作不会再占用CPU资源了。直到异步完成，即网页的html下载完成，WebClient会通知下载完成事件，让CLR响应异步操作完成，由此可见，异步模式借助线程池，极大的节约了CPU资源。所以，异步和多线程的执行流程图可以这样表示：明白了多线程和异步的区别后，我们来确定下二者的具体使用场景：CPU密集型采用多线程；I/O密集型采用异步。如果你区分不来什么是CPU密集型还是I/O密集型的，你就记住一点：涉及到任何读写操作和数据传输有关的，就属于I/O密集型，否则就是CPU密集型，也叫计算密集型。关于线程同步所谓线程同步，就是多线程访问共享资源时的一种等待（也可以理解为锁定某个对象），直到该共享资源被解除锁定，面向对象语言中的数据类型都分为值类型和引用类型。所以多线程在这两种数据类型上的等待是不一样的，有编程基础的都知道值类型不能被锁定，即不能在值类型上做等待操作。而在引用类型上的等待机制，又分为了锁定和同步。在C#里面，锁定我们使用微软提供的关键字语法糖lock或者使用Monitor对象，其实前者就是后者的语法糖，两者没有什么实质差别，这就是我们最常用的锁技术。不过，我们主要来讨论信号同步，而信号同步机制中涉及的类型都继承自抽象类WaitHandle，这些类型有Semaphore、Mutex以及EventWaitHandle，而EventWaitHandle又分为AutoResetEvent和ManualResetEvent，关系图如下：所以它们的底层原理都是一样的，维护的都是一个系统内核句柄。不过还是要简单的区别三者的关系。EventWaitHandle维护的是一个由系统内核产生的布尔值类型（称之为“阻塞状态”），如果为false，则表示线程被阻塞，可以通过调用Set方法将其置为true而解除线程阻塞。而它的子类AutoResetEvent和ManualResetEvent区别也不大，接下来会针对二者讲述下如何正确地使用信号量。Semaphore维护的是一个由系统内核产生的整型变量，如果其值为0，则表示等待，如果大于0，则解除阻塞，同时，每解除一个线程阻塞，其值就减1。初始化时就限制了最多能等待几个线程。上面两个提供的都是单应用程序域的线程同步，而Mutex则解决的是跨应用程序域线程阻塞和解锁的能力。使用线程同步的一个简单例子：public&nbsp;AutoResetEvent&nbsp;AutoResetEvent&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}&nbsp;=&nbsp;new&nbsp;AutoResetEvent(false);\nprivate&nbsp;void&nbsp;button2_Click(object&nbsp;sender,&nbsp;EventArgs&nbsp;e)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(()&nbsp;=&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label1.Text&nbsp;=&nbsp;&quot;线程开启，等待信号...&quot;;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AutoResetEvent.WaitOne();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//todo:处理一些复杂工作\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label1.Text&nbsp;=&nbsp;&quot;继续工作...&quot;;\n&nbsp;&nbsp;&nbsp;&nbsp;}).Start();\n}\nprivate&nbsp;void&nbsp;button3_Click(object&nbsp;sender,&nbsp;EventArgs&nbsp;e)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;AutoResetEvent.Set();\n}同样在一个WinForm程序里面，一个按钮开启线程，另一个按钮给这个线程发送信号，这期间发生了什么？首先创建了一个AutoResetEvent同步类型对象，初始状态为阻塞状态false，这意味着所有的在它上面的的等待都会被阻塞，即线程中应用：AutoResetEvent.WaitOne();这说明线程到这里就被阻塞，直到有人给它发信号才会继续执行，否则就一直等，而UI线程中的：AutoResetEvent.Set();相对于其他线程来说，就是“另一个线程”，UI线程通过Set方法将阻塞状态置为true，等待的线程才继续执行，虽然例子很简单，但已经完全的解释了信号机制的工作原理。而AutoResetEvent和ManualResetEvent的区别在于，前者在发送完信号后会立即置为false，而后者需要手动指定，我们来看下面的例子：public&nbsp;AutoResetEvent&nbsp;AutoResetEvent&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}&nbsp;=&nbsp;new&nbsp;AutoResetEvent(false);\nprivate&nbsp;void&nbsp;button2_Click(object&nbsp;sender,&nbsp;EventArgs&nbsp;e)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(()&nbsp;=&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label1.Text&nbsp;=&nbsp;&quot;线程1开启，等待信号...&quot;;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AutoResetEvent.WaitOne();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//todo:处理一些复杂工作\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label1.Text&nbsp;=&nbsp;&quot;继续1工作...&quot;;\n&nbsp;&nbsp;&nbsp;&nbsp;}).Start();\n&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(()&nbsp;=&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label2.Text&nbsp;=&nbsp;&quot;线程2开启，等待信号...&quot;;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AutoResetEvent.WaitOne();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//todo:处理一些复杂工作\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label2.Text&nbsp;=&nbsp;&quot;继续2工作...&quot;;\n&nbsp;&nbsp;&nbsp;&nbsp;}).Start();\n}\nprivate&nbsp;void&nbsp;button3_Click(object&nbsp;sender,&nbsp;EventArgs&nbsp;e)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;AutoResetEvent.Set();\n}按钮2同时开启2个线程，按钮3发送信号，运行时我们发现，在线程都被阻塞的时候，点按钮3之后，只有一个线程被唤醒了，另一个线程仍然还在等待，根本没收到信号，要再唤醒另一个线程，那就再点一下按钮3再发一个信号，所以AutoResetEvent在发送完信号后立马把阻塞状态置为了false，要想多个线程同时被唤醒，那就是ManualResetEvent了。只要是引用类型，就可以随便加锁吗？加锁我相信大家都很熟悉了，这也是让线程同步的一种方式，其原理就是锁住一个共享资源，使得程序在多线程访问这个共享资源的时候只能有一个线程占用，通俗的讲就是让多线程变成单线程，但是，只要是对象，就可以加锁吗？既然加锁的是个对象，那我们不妨思考一下，到底要什么样的对象才能被锁，我在这儿整理了一下，选择锁对象的时候我们应该注意什么：锁对象应该是在多个线程中可见的同一对象；在非静态方法中，静态变量不应该作为锁对象；值类型不能作为锁对象；避免将字符串作为锁对象；降低锁对象的可见性。下面就分别详细的解释下这几点。首先第一个，锁对象必须在多线程中是可见的，且必须是同一对象。前半句很好理解，如果不可见那肯定也不能锁啊，至于“同一对象”，也很好理解，如果锁的不是同一对象，那加锁还有什么意义呢，但是，这却是我们经常会犯的一个错误，为了好理解，举个我们一定会遇到的场景：在遍历集合的时候，同时另一个线程又在修改这个集合，就像下面的代码，如果没有lock，会抛异常InvalidOperationException：集合已被修改，可能无法执行枚举。static&nbsp;void&nbsp;Main(string[]&nbsp;args)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;lockObj&nbsp;=&nbsp;new&nbsp;object();\n&nbsp;&nbsp;&nbsp;&nbsp;AutoResetEvent&nbsp;are&nbsp;=&nbsp;new&nbsp;AutoResetEvent(false);\n&nbsp;&nbsp;&nbsp;&nbsp;List&lt;string&gt;&nbsp;list&nbsp;=&nbsp;new&nbsp;List&lt;string&gt;()&nbsp;{&nbsp;&quot;1&quot;,&nbsp;&quot;2&quot;,&nbsp;&quot;3&quot;,&nbsp;&quot;4&quot;,&nbsp;&quot;5&quot;,&nbsp;&quot;6&quot;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(()&nbsp;=&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;are.WaitOne();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(lockObj)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(var&nbsp;i&nbsp;in&nbsp;list)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.Sleep(100);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}).Start();\n&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(()&nbsp;=&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;are.Set();//保证这个线程已经开始了才能执行上面的线程\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.Sleep(200);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(lockObj)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.RemoveAt(0);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}).Start();\n}上面的代码锁定的是同一对象，肯定没有问题，如果将代码改造成这样：class&nbsp;Program\n{\n&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;void&nbsp;Main(string[]&nbsp;args)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;m1&nbsp;=&nbsp;new&nbsp;MyClass();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;m2&nbsp;=&nbsp;new&nbsp;MyClass();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m1.T1();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m2.T2();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\npublic&nbsp;class&nbsp;MyClass\n{\n&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;lockObj&nbsp;=&nbsp;new&nbsp;object();\n&nbsp;&nbsp;&nbsp;&nbsp;AutoResetEvent&nbsp;are&nbsp;=&nbsp;new&nbsp;AutoResetEvent(false);\n&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;List&lt;string&gt;&nbsp;list&nbsp;=&nbsp;new&nbsp;List&lt;string&gt;()&nbsp;{&nbsp;&quot;1&quot;,&nbsp;&quot;2&quot;,&nbsp;&quot;3&quot;,&nbsp;&quot;4&quot;,&nbsp;&quot;5&quot;,&nbsp;&quot;6&quot;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;T1()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(()&nbsp;=&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;are.WaitOne();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(lockObj)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(var&nbsp;i&nbsp;in&nbsp;list)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.Sleep(100);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}).Start();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;T2()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(()&nbsp;=&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;are.Set();//保证这个线程已经开始了才能执行上面的线程\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.Sleep(200);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(lockObj)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.RemoveAt(0);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}).Start();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}很显然，MyClass被实例化了两次，也就是锁对象lockObj也被实例化了两次，而多线程操作的却是MyClass的静态字段，运行则会抛InvalidOperationException：集合已被修改，可能无法执行枚举。也就是说，上面的代码锁定的是两个不同的对象，如果要改掉这个bug，那么把lockObj也改成静态的就OK了，另外，也思考下能不能lock(this)，试想刚才我们用lockObj，同理lock(this)在多实例的时候也不是锁的同一对象，也不能达到锁同步的目的。那刚才的把lockObj改成了静态的之后，确实达到了锁的目的，但是，有读者可能发现了，非静态方法中使用了静态变量作为锁对象，这不矛盾了么，那好，接下来就说第二点了。针对第二点，事实上，刚才的代码也是出于演示的目的，其次，实际项目中强烈建议不要这么写，如果要，必须遵守这个原则：类型的静态方法应当保证线程安全，非静态方法不需要保证线程安全。.NetFramework和.NetCore底层绝大部分类都遵循了这个原则，上一个示例中，如果将lockObj改为静态的，Name就相当于让非静态方法具备了线程安全性，带来的问题就是：如果应用程序中该类型存在多实例，在遇到这个锁的时候，就会产生同步，试想，如果高并发使用这个类的时候，你愿意看到你的应用程序或者网站被卡死在这里吗？！第三点，值类型不能作为锁对象，这很好理解，值类型肯定不能作为锁对象啊，学基础的时候也是三令五申过的，但是为什么值类型不能作为锁对象你真的能解释清楚么？因为值类型都是在栈内存，当值类型被传递到另一个线程时，会创建一个副本，相当于每个线程锁定的都是不同的对象，因此值类型不能作为锁对象。第四点，不能锁字符串，其实基础够扎实的也应该知道，字符串在所有的面向对象语言中都是一种特殊的引用类型，如果把字符串作为锁对象，是相当危险的。这似乎看上去和值类型正好相反，但字符串在内存中作为常量存在，如果有两个变量被赋值了相同的字符串，它们引用的将是同一块内存空间，所以，如果把字符串作为锁对象，那就相当于锁定了一个全局的对象，这可能造成整个应用程序被阻塞掉。如果非有一定要用字符串作为锁对象的，也不是不可以，但是，这样做之前，一定得考虑清楚。最后一点，降低锁对象的可见性。其实上面的第四点提到的锁字符串，字符串就相当于是一种可见范围最广的锁对象，其次还有typeof(class)，typeof返回的结果是class的所有实例共有的，也就是说：所有实例的Type都指向typeof返回的结果。这样一来，如果我们也lock了typeof(class)，其结果也可能就像刚才第四点一样了。这样的编码没有必要存在。一般来说，锁对象也不应该是一个公共变量或属性。在.NET的早期版本中，一些常用的集合类型提供了公有属性SyncRoot，让我们可以实现线程安全的集合操作，所以你可能会认为我们刚才的结论可能不对，然而，集合操作的大部分应用场景都不是多线程的，更多的是单线程操作，而且线程同步本身是一种耗时的操作，如果集合的所有的非静态方法都需要考虑线程安全，那么完全没有必要整个公开的SyncRoot，私有即可啊，而现在把它公开是为了让调用者去决定它操作时是否需要线程安全。除非你有这样的需求，否则就应该考虑锁对象的可见性，况且现在.NET较高版本的都已经提供了线程安全的集合了，如：ConcurrentBag、ConcurrentDictionary等。线程的IsBackground的坑在.NET中线程分为前台线程和后台线程，每个线程都有IsBackground属性，如果通过该属性将线程标记为后台线程，那么应用程序在退出的时候就会连线程一并退出；如果为前台线程，那么就只有等到所有线程都结束了，应用程序才算是真正的退出了。WinForm中有如下代码：private&nbsp;void&nbsp;button4_Click(object&nbsp;sender,&nbsp;EventArgs&nbsp;e)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;t&nbsp;=&nbsp;new&nbsp;Thread(()&nbsp;=&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(true)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.Sleep(1000);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;});\n&nbsp;&nbsp;&nbsp;&nbsp;t.IsBackground=false;\n&nbsp;&nbsp;&nbsp;&nbsp;t.Start();\n}，在VS中启动调试，在单击按钮开启这个前台线程，VS进入调试模式，这时如果叉掉应用程序，你会发现VS仍然还在调试，如果你在上面的while循环里打个断点，你仍然可以看到它命中断点，这就意味着应用程序并没有退出。所以如果我们使用线程的话，我们要注意应该更多地将线程标记为后台线程，如果是需要执行事务或者占有某些非托管资源需要释放时，才使用前台线程。线程并不会立即开始市面上绝大部分的操作系统都不是一个实时操作系统，Windows也是如此，所以我们期望不了线程开启后能立刻执行，Windows系统有它自己调度线程的算法，什么时候该执行哪个线程，从操作系统的角度讲，就是每个线程都被分配了一定的CPU时间，可以执行一小段的工作，由于被分配的时间都非常短，所以即使你的系统现在有几千个线程再运行，你感觉到的也是他们都同时在运行，系统会在适当的时机根据自己的算法决定下一个时间点去调度哪个线程。线程本身就不是编程语言自身就有的东西，它的调度也是一个非常复杂的过程，但我们需要理解的就是：线程之间的切换一定需要花时间和空间，而且，它不实时。不妨我们用代码检验一下：for(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i++)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(()&nbsp;=&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(i);\n&nbsp;&nbsp;&nbsp;&nbsp;}).Start();\n}我们期望的结果是0-9依次输出，但是结果却是如此：这就印证了刚才所说的线程不是立即启动的，也许后开的线程会先于先开的线程，而for循环传入线程的值，比如当前循环到5，可能线程真正执行的时候，早已到8了。要让刚才的代码按我们预想的结果输出，我们把开启线程的代码提取到方法：static&nbsp;void&nbsp;Main(string[]&nbsp;args)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i++)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NewMethod(i);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();\n}\nprivate&nbsp;static&nbsp;void&nbsp;NewMethod(int&nbsp;i)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(()&nbsp;=&gt;&nbsp;{&nbsp;Console.WriteLine(i);&nbsp;}).Start();\n}由于在for循环外部启动线程，这就是我们预想的结果了：关于线程的优先级线程在C#中有5个优先级：Lowest,BelowNormal,Normal,AboveNormal,Highest，优先级就涉及到操作系统对线程的调度，Windows系统是一个基于线程优先级的抢占式调度模式，线程优先级高的总是比优先级低的获取得更多的CPU时间，如果有一个优先级高的线程，并且已经就绪，系统总是会优先执行。我们启动的所有线程，包括ThreadPool和Task，线程的优先级默认都是Normal级别，虽然可以去修改线程的优先级，但是我们不建议这么做，如果是一些非常关键的线程，我们还是可以考虑提升线程优先级的。这些高优先级的线程应该具备运行时间短，能立刻进入等待状态的特征。取消线程的正确姿势有时候我们总是想更大程度的去控制线程，比如，我想在线程还在执行的某个时候，把它取消了，最典型的场景就是，开线程发起http请求，有时网络很差就会导致线程执行时间过长，所以我们就想等待一定时间，回不来就取消了吧，然而，这并不是我们想怎样就怎样的，这涉及到两个问题：1.正如线程不能立即启动，当然线程也不能立即停止，不是你想停就能停的。无论采用哪种方式通知线程停止，线程都会忙完最紧要的事情之后在它觉得合适的时候退出。以传统的Thread.Abort，如果线程执行的是一段非托管代码，就不会抛线程取消异常，只有当代码回到CLR中，才会引发线程取消异常，当然，异常也不是立即引发的。2.取消线程不在于采用何种手段，更多的是依赖于线程能否主动响应发起者的停止请求。也就是说：如果线程需要被停止，那么线程需要给调用者开放Canceled的接口，线程在工作的同时还要去检测Canceled的状态，如被检测到Canceled，线程才会负责退出。.NET给我们提供了标准的取消模式：协作式取消（Cooperative Cancellation）。机制就是上面提到的这种机制。直接上代码：var&nbsp;cts&nbsp;=&nbsp;new&nbsp;CancellationTokenSource();\nvar&nbsp;t&nbsp;=&nbsp;new&nbsp;Thread(()&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;while(true)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(cts.IsCancellationRequested)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;线程被取消&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.Sleep(100);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n});\nt.Start();\nConsole.ReadKey();\ncts.Cancel();主线程通过CancellationTokenSource的Cancel方法通知工作线程退出，工作线程以100ms的频率一边工作一边检测外界是否有Cancel的信号传入，若有，则退出，可以看出正确停止工作线程的机制中，真正起到主要作用的是线程自身，虽然上面的代码简单，但也阐述清楚了问题。更复杂的计算式工作，也应该是这样的方式，去妥善正确的退出线程。其实CancellationTokenSource还有一个方法值得注意，就是Register方法，它负责传递一个Action委托，线程被停止时会执行回调：cts.Token.Register(()&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;线程已经停止&quot;);\n});虽然是用Thread在演示，但如果是ThreadPool，也是一样的模式，后面还会讲到Task的取消，它依赖于CancellationTokenSource和CancellationToken完成取消控制。控制好线程数量！这是一个很严肃的事情，如果线程过多，这意味着我们项目的架构设计存在缺陷。那到底一个应用程序应该使用多少个线程合适，我们打开计算机的任务管理器，切到性能界面，我们来算一下：现在小编的电脑运行着98个进程，1436个线程，使用1.9GB内存，除一下，一个应用程序平均也就14个线程左右，每个线程大约占1.5MB内存，所以每个应用程序的线程不会太多。错误创建过多线程的一个场景：就是我们当初学习编程的时候，网络编程我们都写socket聊天室，相信绝大部分朋友都写过，那时我们会为每个socket开一个线程去监听请求，假设这个聊天室我们要对外开放用户，那就意味着随着用户数的增多，线程就会变多，如果达到一定数量，就意味着计算机管理不过来了，而开线程也需要内存来支持的，CLR默认会给每个线程分配差不多1MB的内存空间，如果你的电脑又恰好是32位的，那就意味着当你电脑里面线程数达到4096的时候，内存就被耗尽了，这都是理想情况，而且32位系统往往只能支持2.xGB-3.xGB的内存，再加之每种型号的CPU其实都有线程数在多少合适这种说法的，比如i5处理器在1000个线程左右是最高效的，i7处理器在2000线程左右。过多的线程会造成CPU在线程之间的切换到开销过大，相当的损耗CPU时间，像Socket这类I/O密集型应该使用异步去完成。其实过多的线程带来的问题不仅仅如此，还会有另外的问题，就是：新开的线程可能需要等待相当长的时间才会开始执行，我们很无奈，我相信这也是你们无法忍受的结果，我们可以来实测一下，下面的代码，第501个线程会等待好几分钟才会开始执行：for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;500;&nbsp;i++)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(()&nbsp;=&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;j&nbsp;=&nbsp;0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(true)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j++;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.Sleep(1);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}).Start();\n}\nThread.Sleep(5000);\nnew&nbsp;Thread(()&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(true)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;第501个线程正在运行...&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.Sleep(1000);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}).Start();其实除了启动问题外，还有线程切换的问题，也就是说上面的第501个线程被切换走了之后，也需要相当长的时间才会再次切换回来。所以，不要滥用线程，不要滥用过多的线程，当有工作需要新开线程去解决的时候，要仔细考虑这项工作是否真的需要开线程去解决，即使需要使用线程，也推荐大家使用线程池技术，比如之前的连接socket那样的I/O密集型场景，使用异步去管理，异步其实底层也是使用的线程池技术，成百上千个线程使用异步或者线程池技术后，实际上在工作的只有几个线程。继续讨论线程池使用线程池能极大地提升我们的打码体验和用户体验，但是我们作为开发者也应该要注意，线程是要产生开销的。线程的空间开销主要来自：1）线程内核对象（Thread Kernel Object）。每个线程都会创建一个这样的对象，它主要包含线程上下文信息，占用的内存在700字节左右。2）线程环境块（Thread Environment Block）。占用4KB内存。3）用户模式栈（User Mode Stack），即线程栈。线程栈用于保存方法的参数、局部变量和返回值。每个线程栈占用1MB的内存。要用完这些内存很简单，写一个不能结束的递归方法，让方法参数和返回值不停地消耗内存，很快就会发生OutOfMemoryException。4）内核模式栈（Kernel Mode Stack）。当调用操作系统的内核模式函数时，系统会将函数参数从用户模式栈复制到内核模式栈。会占用12KB内存。线程的时间开销来自：1）线程创建的时候，系统相继初始化以上这些内存空间。2）接着CLR会调用所有加载DLL的DLLMain方法，并传递连接标志（线程终止的时候，也会调用DLL的DLLMain方法，并传递分离标志）。3）线程上下文切换。一个系统中会加载很多的进程，而一个进程又包含若干个线程。但是一个CPU在任何时候都只能有一个线程在执行。为了让每个线程看上去都在运行，系统会不断地切换“线程上下文”：每个线程大概得到几十毫秒的执行时间片，然后就会切换到下一个线程了。这个过程大概又分为以下5个步骤：步骤1　进入内核模式。步骤2　将上下文信息（主要是一些CPU 寄存器信息）保存到正在执行的线程内核对象上。步骤3　系统获取一个 Spinlock，并确定下一个要执行的线程，然后释放 Spinlock。如果下一个线程不在同一个进程内，则需要进行虚拟地址交换。步骤4　从将被执行的线程内核对象上载入上下文信息。步骤5　离开内核模式。所以线程的创建和销毁是需要付出时间和空间的代价的，而微软为了防止我们开发者无节制的使用线程，就封装了线程池这种技术，简单说就是帮助我们开发者来管理线程，随着工作的完成，线程不会被销毁，而是回到线程池中，看别的工作会不会继续使用线程，而具体何时被销毁或者创建，由CLR自己的算法来决定，所以真实项目中，我们更多的应该考虑使用线程池来替代Thread，线程池主要有ThreadPool和BackgroundWorker这两个类，使用也蛮简单的：ThreadPool.QueueUserWorkItem(state&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;//todo\n});\nvar&nbsp;bw&nbsp;=&nbsp;new&nbsp;BackgroundWorker();\nbw.DoWork&nbsp;+=&nbsp;(sender,&nbsp;e)&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;//todo\n};\nbw.RunWorkerAsync();而ThreadPool和BackgroundWorker的区别在于：BackgroundWorker在WinForm和WPF中还提供了和UI线程交互的能力，而ThreadPool没有这种能力，BackgroundWorker的能力还包括：通知进度、完成回调、取消任务、暂停任务等功能。久等了的Task终于登场前面做了这么多的铺垫，其实就是为了给Task登场做准备的，Task是.NET4.5之后提供的线程的更高级的一种技术，虽然前面刚说了ThreadPool和BackgroundWorker比Thread更有优势，那么Task更是超越ThreadPool和BackgroundWorker更强大的概念。为线程池提供了更多的API可以调用，管理一个线程简直颠覆传统了：Task.Run(()&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;我是异步线程...&quot;);\n}).ContinueWith(t&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(t.IsCanceled)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;线程被取消了&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(t.IsFaulted)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;发生异常而被取消了&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(t.IsCompleted)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;线程成功执行完成了&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n});我们可以看出，Task具有以下属性：IsCanceled：线程被取消而完成；IsFailed：线程因发生未捕获的异常而完成；IsCompleted：成功完成。需要注意的是：Task并没有提供成功回调的事件功能，它是启动一个新的task来实现BackgroundWorker类似的事件回调功能，而ContinueWith正是这样的功能，这种方式天然就支持了任务的状态检查，而且还能在新任务中获得原任务返回的值。下面来个稍微复杂的例子，同时支持任务完成的通知，数据返回，任务被取消，异常的发生等情况：using&nbsp;(HttpClient&nbsp;client&nbsp;=&nbsp;new&nbsp;HttpClient()&nbsp;{&nbsp;BaseAddress&nbsp;=&nbsp;new&nbsp;Uri(&quot;https://www.baidu.com&quot;)&nbsp;})\n{\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;result&nbsp;=&nbsp;client.GetStringAsync(&quot;/&quot;).ContinueWith(t&nbsp;=&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(t.IsCanceled)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;线程被取消了&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(t.IsFaulted)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;发生异常而被取消了&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(t.IsCompleted)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;t.Result;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;\n&nbsp;&nbsp;&nbsp;&nbsp;}).Result;\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(result);\n}Task的Result属性可以拿到线程执行完返回的值，同时阻塞线程直到拿到返回的结果，上面的代码调用HttpClient的GetStringAsync方法，即创建了一个Task来等待http响应，当IsCompleted属性为true，就可以拿到http请求返回的html代码，最后存到上一层的Task的Result属性中。如果我们把http请求的地址改成Google，在我们现在这样的网络环境下，HttpClient请求不了，那肯定就只有抛异常咯，所以当HttpClient请求的地址是Google的时候，Task的IsFailed则为true。如果要模拟线程被取消，上面的代码把最后的Result去掉，就让Task不阻塞，这段代码很快就结束，而HttpClient内部却认为请求被取消了，所以会触发Task的取消行为。如果要真实模拟Task的取消，可以这样做：var&nbsp;cts&nbsp;=&nbsp;new&nbsp;CancellationTokenSource();\nTask.Run(()&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;我是异步线程...&quot;);\n},&nbsp;cts.Token).ContinueWith(t&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(t.IsCanceled)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;线程被取消了&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(t.IsFaulted)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;发生异常而被取消了&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(t.IsCompleted)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;线程成功执行完成了&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n});\ncts.Cancel();我们声明一个CancellationTokenSource传入Task，在调用CancellationTokenSource的Cancel方法即可提前终止掉线程。Task还支持工厂的概念，且支持多个任务之间共享相同的状态，也就是说，如果刚才的想取消任务，可以同时取消一组任务：var&nbsp;cts&nbsp;=&nbsp;new&nbsp;CancellationTokenSource(1000);\nTask[]&nbsp;tasks&nbsp;=&nbsp;{Task.Factory.StartNew(()&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;我是异步线程...&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;Thread.Sleep(1000);\n},&nbsp;cts.Token),Task.Factory.StartNew(()&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;我是异步线程...&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;Thread.Sleep(1000);\n},&nbsp;cts.Token),Task.Factory.StartNew(()&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;我是异步线程...&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;Thread.Sleep(1000);\n},&nbsp;cts.Token)};\ncts.Cancel();\nTask.Factory.ContinueWhenAll(tasks,&nbsp;ts&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine($&quot;线程被取消{ts.Count(t&nbsp;=&gt;&nbsp;t.IsCanceled)&nbsp;}次&quot;);\n});Task的工厂方法进一步优化了线程池的调度，所以我们更应该用Task来开启线程。如果想让Task异步变为同步，只需要接着调用Task的Wait方法即可。async和await关键字这是.NET4.5和C#6为我们提供的Task的两个关键字，它们几乎是成对存在的，使用这两个关键字，能够将我们定义的方法变成异步方法去执行。如下代码：static&nbsp;void&nbsp;Main(string[]&nbsp;args)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;MyMethod();\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;world&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();\n}\npublic&nbsp;static&nbsp;void&nbsp;MyMethod()\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;hello&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;Thread.Sleep(5000);\n}我们看到的结果是先输出hello，等待5秒后才输出world，那么我不想改代码，又不想等待呢？这时我们把MyMethod改造成异步方法即可：static&nbsp;void&nbsp;Main(string[]&nbsp;args)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;MyMethod();\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;world&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();\n}\npublic&nbsp;static&nbsp;async&nbsp;void&nbsp;MyMethod()\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;hello&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;await&nbsp;Task.Delay(5000);\n}运行之后就会看到先输出hello然后立马数出了world，并没有等待5秒了，来看一下我们做了哪些改动，首先方法签名加了async进行修饰，Thread.Sleep换成了Task.Delay，并且在前面加了await关键字，这表示异步等待，而我们常用的Thread.Sleep是同步等待，当然这里也只是为了模拟一个耗时操作。现在来说下异步方法的声明，异步方法必须被async关键字修饰，且方法体里有存在await关键字才能算是异步方法，否则仅被async修饰的方法也是同步方法，其次，方法的返回值只能是void、Task或者Task&lt;&gt;，三者的区别在于：void：执行一个任务，不需要返回值，不需要与任务进行任何的交互；Task：执行一个任务，不需要返回值，但需要与任务进行交互，比如取消、执行状态的检测等；Task&lt;&gt;：同上，但需要返回值，返回值被包含在Task的Result属性里。改造刚才的代码，我们对MyMethod方法不需要返回值，但需要与Task进行交互，直接将void改成Task即可，不需要在方法体里加return，因为await已经代替我们return了：static&nbsp;void&nbsp;Main(string[]&nbsp;args)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;task&nbsp;=&nbsp;MyMethod();\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;world&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(task.IsCompleted);\n&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();\n}\npublic&nbsp;static&nbsp;async&nbsp;Task&nbsp;MyMethod()\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;hello&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;await&nbsp;Task.Delay(5000);\n}输出结果：为什么是false？因为输出world之后还没有5秒钟，而MyMethod需要执行5秒钟才完成，所以在此刻的执行完成状态是false。接下来我们再以有返回值的异步方法检验一下：static&nbsp;void&nbsp;Main(string[]&nbsp;args)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;task&nbsp;=&nbsp;MyMethod();\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;world&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(task.Result);\n&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();\n}\npublic&nbsp;static&nbsp;async&nbsp;Task&lt;string&gt;&nbsp;MyMethod()\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;hello&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;await&nbsp;Task.Delay(5000);\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;aaa&quot;;\n}输出结果：需要等到5秒之后才会输出aaa。使用异步方法需要注意的是：await后面跟的的必须是一个返回值为Task的方法；main方法不能被修饰为异步方法；方法体里有lock关键字不能作为异步方法；方法参数不能带ref和out关键字；异步方法不是在同一个线程中执行的。异步方法的执行过程如下：同步等待和异步等待下面的代码，不考虑Console输出的CPU时间消耗，输出的结果多少？大家用自己的大脑运行一下这段代码：static&nbsp;void&nbsp;Main(string[]&nbsp;args)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;sw&nbsp;=&nbsp;Stopwatch.StartNew();\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;task&nbsp;=&nbsp;MyMethod();\n&nbsp;&nbsp;&nbsp;&nbsp;Thread.Sleep(4000);\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;result&nbsp;=&nbsp;task.Result;\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(sw.ElapsedMilliseconds);\n}\npublic&nbsp;static&nbsp;async&nbsp;Task&lt;string&gt;&nbsp;MyMethod()\n{\n&nbsp;&nbsp;&nbsp;&nbsp;await&nbsp;Task.Delay(5000);\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;aaa&quot;;\n}其实是一道面试题，有的人回答4000，有人回答9000，有人回答5000，还有的人肯定说不出个答案，那么正确答案到底是多少？我们我们理一下代码的执行过程：首先调用了MyMethod异步方法，即开启了一个线程，而这个线程里面，异步等待了5000ms，然后主线程中同步等待了4000ms，在主线程等待4000ms之后，又有个变量在等着异步线程返回一个值，到这里之前，也就是主线程和一个工作线程都在同时进行等待，而主线程等待了4000ms，那么另一个工作线程也已经等待了4000ms，那么在等待MyMethod返回“aaa”给result的时候，就还需要1000ms的等待，最后，MyMethod返回后，输出了程序执行的时间：5000。我们来运行代码检验一下：5054，跟我们预想的5000很接近，我们的想法是正确的，多出来的54ms自然就是Console输出的CPU消耗咯。那么，如果MyMethod返回void或者Task，结果又是多少？static&nbsp;void&nbsp;Main(string[]&nbsp;args)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;sw&nbsp;=&nbsp;Stopwatch.StartNew();\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;task&nbsp;=&nbsp;MyMethod();\n&nbsp;&nbsp;&nbsp;&nbsp;Thread.Sleep(4000);\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(sw.ElapsedMilliseconds);\n}\npublic&nbsp;static&nbsp;async&nbsp;Task&nbsp;MyMethod()\n{\n&nbsp;&nbsp;&nbsp;&nbsp;await&nbsp;Task.Delay(5000);\n}我想大家已经知道答案了：4000。没错，就是4000，因为现在MyMethod没有与主线程进行交互了，即使刚才的MyMethod如果没有与主线程进行交互，那么结果仍然是4000，因为线程开启了就再也跟主线程没有关系了。刚才的代码也是模拟我们在同步线程和异步线程同时都在执行耗时操作，并且需要线程间进行通信的一个场景，最典型的一个场景就是我们在代码里面使用HttpClient发送http请求，有时我们需要在前一个请求完成后才能进行发下一个请求，并且保证两次请求都成功这样的一个场景。所以，如果异步线程执行之后，如果和主线程没有交互，是不会阻塞主线程执行的，只有当主线程需要等异步方法返回结果，而异步线程还没执行完的情况下，会造成主线程阻塞。并行计算Parallel在和Task的同命名空间下，有一个叫Parallel的静态类简化了Task在同步状态下的操作，主要提供了Invoke、For和ForEach三个方法的多个重载。Invoke传入可变长度参数的Action委托，For主要用于做类似于传统for循环时对数组元素的并行操作，ForEach主要用于做类似于传统foreach循环时对集合迭代的并行操作。Parallel.Invoke(()&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;线程1&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;Thread.Sleep(1000);\n},&nbsp;()&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;线程2&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;Thread.Sleep(1000);\n},&nbsp;()&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;线程3&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;Thread.Sleep(1000);\n});\nConsole.WriteLine(&quot;-------------&quot;);\nParallel.For(0,&nbsp;4,&nbsp;i&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(i);\n});\nConsole.WriteLine(&quot;-------------&quot;);\nvar&nbsp;list&nbsp;=&nbsp;new&nbsp;List&lt;int&gt;()&nbsp;{&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5&nbsp;};\nParallel.ForEach(list,&nbsp;item&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(item);\n});我们看出，不管哪种方式，其调用顺序是无序的，这说明如果我们对集合元素顺序输出的情况下，并行计算显然不合适了。而且，Parallel启动后是阻塞状态的，所以Parallel它是同步的。也就是说：Parallel简化了Task的同步操作，但不等同于Task的默认行为不知道大家刚才注意仔细阅读没有，上文中提到的Parallel简化Task的使用，特别的加个了“同步”来做定语修饰。所以说Parallel调用的线程是被阻塞的，虽然说Parallel把任务交给了Task去处理，但会等到所有的Task把任务执行完成了才会继续后面的操作，而且Parallel只提供了Invoke方法，并没有提供一个叫BeginInvoke的方法，这也说明了一定的问题。使用Task的时候，我们习惯于直接调Run方法开启一个任务，这个任务是异步的，如果要同步，则继续调用Wait方法，而Parallel所包装的，也就是这么一个过程。既然叫并行计算，也就意味着运行时在后台将任务尽可能地分配在CPU上，虽然是基于Task实现的，但这并不表示它等同于异步！Parallel踩坑之旅Parallel的循环操作还支持一些复杂的操作，比如它可以在每个任务启动时做一些初始化操作，结束时做一些扫尾操作。还允许监控任务状态，请注意，刚才这个说法是错误的，应该把“任务”改成“线程”，这就是坑所在。所以我们必须深刻地去理解Parallel的操作和应用，不然你跳到坑里去了还没人能把你拉出来，体会一下这段代码输出什么：var&nbsp;list&nbsp;=&nbsp;new&nbsp;List&lt;int&gt;()&nbsp;{&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5&nbsp;,6&nbsp;};\nint&nbsp;sum=0;\nParallel.For(0,list.Count,()&nbsp;=&gt;&nbsp;1,(i,&nbsp;state,&nbsp;total)&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;total+=i;\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;total;\n},i&nbsp;=&gt;&nbsp;Interlocked.Add(ref&nbsp;sum,i));\nConsole.WriteLine(sum);代码可能输出16，也可能输出17，理论上也可能是18、19，但概率比较小了，为什么？要究其原因，我们看看Parallel的for方法的声明：对于前两个参数很容易理解，分别是开始和结束的索引。body参数也很容易理解，即循环体。而localinit和localFinally就比较难理解了，并且坑就在这里，要理解这两个参数，就必须先理解Parallel.For的运作模式，该方法采用并发的方式启动for循环的循环体，就意味着循环的循环体是交给线程池去处理的，而上面的代码循环了6次，实际调度的线程可能没有6个，这就是并发的优势，也是线程池的优势，Parallel通过内部的调度算法，节约了线程的开销，localinit的作用就是如果Parallel新开线程，那么就会在localinit里面对线程开启进行一些初始化操作，比如上面的代码就是为新线程启动时为sum返回为1。LocalFinally的作用就是线程结束的时候做一些扫尾操作，比如刚才的代码：i&nbsp;=&gt;&nbsp;Interlocked.Add(ref&nbsp;sum,i)代表的就是线程结束的时候为sum进行原子性的加i操作，相当于：sum=sum+i，而原子操作就是为了避免并发带来的问题。所以现在我们能很好理解上面的代码为什么输出会不确定，Parallel启动了6个任务，但是不确定启动了多少个线程，这是由运行时根据自己算法来决定的，如果只有一个线程，那么结果是16，如果两个线程，那就是17了，三个就是18……，如果我们把初始值localinit返回0的话，你可能永远也不知道你在坑里面。为了更清晰的理解这个坑，我们不妨再来一段代码试下：var&nbsp;list&nbsp;=&nbsp;new&nbsp;List&lt;string&gt;()&nbsp;{&nbsp;&quot;aa&quot;,&nbsp;&quot;bb&quot;,&nbsp;&quot;cc&quot;,&nbsp;&quot;dd&quot;,&nbsp;&quot;ee&quot;,&nbsp;&quot;ff&quot;,&nbsp;&quot;gg&quot;&nbsp;};\nstring&nbsp;str&nbsp;=&nbsp;String.Empty;\nParallel.For(0,&nbsp;list.Count,&nbsp;()&nbsp;=&gt;&nbsp;&quot;-&quot;,&nbsp;(i,&nbsp;state,&nbsp;total)&nbsp;=&gt;&nbsp;total&nbsp;+=&nbsp;list[i],&nbsp;s&nbsp;=&gt;\n{\nstr&nbsp;+=&nbsp;s;\nConsole.WriteLine(“end:”+s);\n});\nConsole.WriteLine(str);可能的输出结果：并行计算一定比串行快？现在我们都知道了并行计算其实也是基于线程的，也知道线程的创建和销毁都需要时间和空间的开销，那么你还会想并行它就一定比串行代码更快？如果循环的循环体很小，那么并行的速度也许比串行更慢，下面这个例子，我们测试一下在并行和串行的情况下的时间消耗：var&nbsp;sw&nbsp;=&nbsp;Stopwatch.StartNew();\nfor&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;2000;&nbsp;i++)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;10;&nbsp;j++)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;sum&nbsp;=&nbsp;i&nbsp;+&nbsp;j;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\nConsole.WriteLine(&quot;串行循环耗时：&quot;&nbsp;+&nbsp;sw.ElapsedMilliseconds);\nsw.Restart();\nParallel.For(0,&nbsp;2000,&nbsp;i&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;10;&nbsp;j++)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;sum&nbsp;=&nbsp;i&nbsp;+&nbsp;j;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n});\nConsole.WriteLine(&quot;并行循环耗时：&quot;&nbsp;+&nbsp;sw.ElapsedMilliseconds);输出结果如下：我们发现，当循环体很小的时候，串行循环几乎不耗时，而并行循环耗时123毫秒，并行循环所消耗的性能是串行循环的好几倍。如果我们把循环体里面的10改到更大的时候：var&nbsp;sw&nbsp;=&nbsp;Stopwatch.StartNew();\nfor&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;2000;&nbsp;i++)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;100000;&nbsp;j++)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;sum&nbsp;=&nbsp;i&nbsp;+&nbsp;j;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\nConsole.WriteLine(&quot;串行循环耗时：&quot;&nbsp;+&nbsp;sw.ElapsedMilliseconds);\nsw.Restart();\nParallel.For(0,&nbsp;2000,&nbsp;i&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;100000;&nbsp;j++)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;sum&nbsp;=&nbsp;i&nbsp;+&nbsp;j;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n});\nConsole.WriteLine(&quot;并行循环耗时：&quot;&nbsp;+&nbsp;sw.ElapsedMilliseconds);输出结果显然并行循环优于串行循环了：所以只有当我们要在循环体里做更多的工作的时候，才能考虑使用并行计算。并行加锁需谨慎！既然是多线程，那么我们有时候不得不考虑加锁来解决共享资源的原子性操作，以保证数据的一致性。但在并行里面加锁是需要谨慎的，这包括：操作本身就需要使用同步代码去完成；或者需要长时间占用共享资源的场景。在对整数变量进行原子操作的时候，.NET提供了Interlocked的Add方法，这就极大的避免了我们需要对整数进行原子操作时所带来的同步性能损耗，回想我们刚才的Parallel踩坑之旅：var&nbsp;list&nbsp;=&nbsp;new&nbsp;List&lt;int&gt;()&nbsp;{&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5&nbsp;,6&nbsp;};\nint&nbsp;sum=0;\nParallel.For(0,list.Count,()&nbsp;=&gt;&nbsp;1,(i,&nbsp;state,&nbsp;total)&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;total+=i;\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;total;\n},i&nbsp;=&gt;&nbsp;Interlocked.Add(ref&nbsp;sum,i));\nConsole.WriteLine(sum);如果扫尾的时候我们不进行原子操作，那么最后导致的结果可能就是汇编语言在最后mov操作时内存地址的对齐问题，而Interlocked解决了这样的问题，同时.NET还提供了volatile关键字来解决变量的原子性操作问题，当然这也不是我们要深入研究的重点，.NET提供的原生的对变量进行原子性操作，带来了性能上的提升，但有些场景，我们不得不加锁来实现同步：var&nbsp;mc&nbsp;=&nbsp;new&nbsp;MyClass();\nParallel.For(0,100000,i&nbsp;=&gt;&nbsp;mc.AddCount());\nConsole.WriteLine(mc.Count);\n\npublic&nbsp;class&nbsp;MyClass\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;Count&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;AddCount()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Count++;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}输出的结果如下：显然和我们预想的100000还有一定的差距，为了保证输出的正确性，我们就必须在并行里面加锁了(假设MyClass的AddCount是第三方提供的API，不允许修改源码)：var&nbsp;mc&nbsp;=&nbsp;new&nbsp;MyClass();\nParallel.For(0,&nbsp;100000,&nbsp;i&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(mc)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mc.AddCount();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n});\nConsole.WriteLine(mc.Count);这样就能得到我们预想的结果：但是，带来了另外的问题，由于同步锁的存在，系统的开销也增加了，线程在上下文的切换也增加了，牺牲了更多的CPU时间和内存，也就是说，这段代码因为同步锁，其实已经是串行代码了，并且还不如串行代码的性能，所以，如果我们要考虑数据的一致性，选择并行还需谨慎，如果循环体里面的全部代码都需要加锁，那么完全不能考虑使用并行。又一个好东西：并行linq(plinq)这可是所有编程语言中C#的一大神器，linq可谓是无所不能，对我们的编程体验确实很爽。Linq最基本的功能就是对集合的各种复杂操作，其实仔细想想你会发现，并行编程简直就是专门为这一类应用而准备的。所以，微软不仅有linq，还有plinq，也就是微软专门为linq扩展了一个叫ParallelEnumerable的类，该类也在System.Linq命名空间下，所提供的功能就是让linq支持并行计算，这就是plinq。我们传统的linq是单线程的，而plinq是并发的、多线程的，通过下面的例子我们可以看出区别：var&nbsp;list&nbsp;=&nbsp;new&nbsp;List&lt;int&gt;()&nbsp;{&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6&nbsp;};\nvar&nbsp;query&nbsp;=&nbsp;from&nbsp;i&nbsp;in&nbsp;list&nbsp;select&nbsp;i;\nforeach(var&nbsp;i&nbsp;in&nbsp;query)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(i);\n}\nConsole.WriteLine(&quot;----------&quot;);\nvar&nbsp;query2&nbsp;=&nbsp;from&nbsp;i&nbsp;in&nbsp;list.AsParallel()&nbsp;select&nbsp;i;\nforeach(var&nbsp;i&nbsp;in&nbsp;query2)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(i);\n}输出结果如下：可以看出我们传统的linq是顺序输出的，而plinq是无序的。其实并行输出还有另一种方式可以，那就是ForAll：query2.ForAll(Console.WriteLine);但是如果以这种方式进行循环输出的话，ForAll会忽略掉查询的AsOrdered请求：var&nbsp;query2&nbsp;=&nbsp;from&nbsp;i&nbsp;in&nbsp;list.AsParallel().AsOrdered()&nbsp;select&nbsp;i;\nquery2.ForAll(Console.WriteLine);AsOrdered可以对并行之后的结果进行重新排序，以保证数据的顺序，而在ForAll方法中，仍然是无序的，如果要保证排序，我们还是只有老老实实的用普通的for循环了，即：var&nbsp;query2&nbsp;=&nbsp;from&nbsp;i&nbsp;in&nbsp;list.AsParallel().AsOrdered()&nbsp;select&nbsp;i;\nforeach&nbsp;(var&nbsp;i&nbsp;in&nbsp;query2)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(i);\n}然而在并行之后再排序，会牺牲掉一定性能的，排序操作包括：OrderBy(Descding)、ThenBy(Descding)，所以如果我们要考虑使用并行linq，我们必须考虑集合元素的顺序性是否是重要的，以便程序按照我们预想的结果运行。还有一些其他的操作，比如Take，如果我们有类似于“随机推荐”的功能，我们可以这么干：foreach(var&nbsp;i&nbsp;in&nbsp;list.AsParallel().Take(5))\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(i);\n}如果是顺序的，那就会取出前5个元素，而这儿因为Parallel是无序的，所以取前5个相对于源数据也是随机的5个。虽然使用plinq来迭代集合元素比linq更高效，但一定要注意，不是所有的并行都比串行更快，linq的某些方法串行比并行快，比如ElementAt等。所以实际开发中我们应该根据我们的使用场景去衡量和决定使用串行linq还是并行linq。找到最佳的解决方案。并行编程的异常处理关于异常处理，这是并行编程中最头疼的一个问题，异常的处理也是非常重要的一个环节，而且，由于并行的存在，使得我们在并行编程的时候，调试起来也是比较难的，程序出问题了找到问题所在也是非常苦恼的一件事情，所以，在并行编程的时候，我们就必须攻下它们。从一道面试题说起这是小编我们公司的一道面试题，也是各大公司喜欢考察的一道面试题，其实很简单，但可能很多人会迷糊，下面这个方法，调用会不会抛异常？public&nbsp;static&nbsp;async&nbsp;void&nbsp;MyMethod()\n{\n&nbsp;&nbsp;&nbsp;&nbsp;await&nbsp;Task.CompletedTask;\n&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;Exception();\n}很多人只有猜会或者不会，但说不出理由，答案肯定是不会抛异常，那为什么不会抛异常？因为这是个异步方法，发生异常是在另一个线程里面发生的，并没有抛给调用者，因为它没有与调用线程进行交互，调用者只是调用了它，但有没有发生异常调用者不知道。好了，其实上面这段代码就反映了在我们实际项目中，有些异步方法发生了异常，但并没有被调用者捕获，导致项目出现一些bug，这样的bug其实很难找出来，所以在异步线程中必须正确地去处理异常。Task中的异常处理如果我们的Task是可以进行交互的，比如可以调用Task的Wait、WaitAny、WaitAll等阻塞方法，或者拿Task的Result属性，发生异常是可以被调用者捕获的，能捕获到AggregateException异常，而AggregateException可以看作是并行编程中的最顶层的异常，所以当异步线程中发生异常时，我们都应该把异常包装到AggregateException中，一个异步线程异常的简单处理如下：var&nbsp;t&nbsp;=&nbsp;Task.Run(()&nbsp;=&gt;&nbsp;throw&nbsp;new&nbsp;Exception(&quot;我在异步线程中抛出的异常&quot;));\ntry\n{\n&nbsp;&nbsp;&nbsp;&nbsp;t.Wait();\n}\ncatch&nbsp;(AggregateException&nbsp;e)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(var&nbsp;ex&nbsp;in&nbsp;e.InnerExceptions)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine($&quot;异常类型：{ex.GetType()}，异常源：{ex.Source}，异常信息：{ex.Message}&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}输出结果：上面的代码以及运行效果大家可以看出，虽然调用Wait等方法以及获取Result属性能得到任务的异常信息，但是会阻塞调用线程，这不是我们想要的结果，凭什么就为了去捕获一个异常而去阻塞调用者线程，所以Task的ContinueWith也解决了这个问题，新开一个后续Task去捕获异常：Task.Run(()&nbsp;=&gt;&nbsp;throw&nbsp;new&nbsp;Exception(&quot;我在异步线程中抛出的异常&quot;)).ContinueWith(t&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(t.IsFaulted)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(var&nbsp;ex&nbsp;in&nbsp;t.Exception?.InnerExceptions)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine($&quot;异常类型：{ex.GetType()}，异常源：{ex.Source}，异常信息：{ex.Message}&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n});输出结果同上。这样的方式解决了调用者线程等待任务阻塞的问题，但仔细研究我们会发现，异常的处理没有往外抛，它还是在线程池里面，在某些场景下，比如在业务逻辑上特定的异常处理，我们就需要才去这种方式，而且也鼓励使用这种做法，但很明显，我们更多的时候需要更进一步的将异常封装。而Task没有提供将任务中的异常抛到主线程。不过有一个可行的办法，仍然使用Wait方法来达到此目的，不过刚才我们说过这样的方式不可取，因为会阻塞，降低我们的编码体验，后来建议使用ContinueWith新开一个后续Task来处理异常，这样很好，所以，我们可以不妨将前两者结合一下得到下面这种方式将异步任务中的异常抛到主线程：var&nbsp;task&nbsp;=&nbsp;Task.Run(()&nbsp;=&gt;&nbsp;throw&nbsp;new&nbsp;Exception(&quot;我在异步线程中抛出的异常&quot;)).ContinueWith(t&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(t.IsFaulted)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;t.Exception;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n});\ntry\n{\n&nbsp;&nbsp;&nbsp;&nbsp;task.Wait();\n}\ncatch&nbsp;(AggregateException&nbsp;e)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(var&nbsp;ex&nbsp;in&nbsp;e.InnerExceptions)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine($&quot;异常类型：{ex.GetType()}，异常源：{ex.Source}，异常信息：{ex.Message}&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}但到这里一切还没有结束，因为调用Wait会阻塞，而且CLR在后台会新开线程池线程来完成额外的工作，如果要把任务的异常抛给主线程，不妨试试时间通知的方式：static&nbsp;event&nbsp;EventHandler&lt;AggregateExceptionArgs&gt;&nbsp;CatchedAggregateExceptionEventHandler;\npublic&nbsp;class&nbsp;AggregateExceptionArgs&nbsp;:&nbsp;EventArgs\n{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;AggregateException&nbsp;AggregateException&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}\n}\nstatic&nbsp;void&nbsp;Main(string[]&nbsp;args)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;CatchedAggregateExceptionEventHandler&nbsp;+=&nbsp;(sender,&nbsp;e)&nbsp;=&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(var&nbsp;ex&nbsp;in&nbsp;e.AggregateException.InnerExceptions)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine($&quot;异常类型：{ex.GetType()}，异常源：{ex.Source}，异常信息：{ex.Message}&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;task&nbsp;=&nbsp;Task.Run(()&nbsp;=&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;Exception(&quot;我在异步线程中抛出的异常&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(Exception&nbsp;e)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CatchedAggregateExceptionEventHandler(null,&nbsp;new&nbsp;AggregateExceptionArgs()&nbsp;{&nbsp;AggregateException&nbsp;=&nbsp;new&nbsp;AggregateException(e)&nbsp;});\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;});\n&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();\n}这样的方式，我们先定义了一个事件CatchedAggregateExceptionEventHandler，它接收标准事件的两个参数，而AggregateExceptionArgs则是包装异常的一个包装类型，所以当异常发生的时候，我们就将异常交给了CatchedAggregateExceptionEventHandler这个事件处理器去处理。事件的调用完全没有阻塞主线程，如果是在Windows窗体程序里面，也可以将异常信息交给窗体程序的线程模型去处理，所以最终建议大家使用这种方式去处理异步任务的异常，这种方式不管任务能否与调用者进行交互，都能捕获到异常。另外一个冷知识：虽然TaskScheduler静态类有一个类似的功能，但一般不建议这样做，因为它的事件回调只有在进行垃圾回收的时候才会被触发，如下：TaskScheduler.UnobservedTaskException&nbsp;+=&nbsp;(sender,&nbsp;e)&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine($&quot;异常类型：{e.Exception.GetType()}，异常源：{e.Exception.Source}，异常信息：{e.Exception.Message}&quot;);\n};\nvar&nbsp;task&nbsp;=&nbsp;Task.Run(()&nbsp;=&gt;\n{\n&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;Exception(&quot;我在异步线程中抛出的异常&quot;);\n});\nConsole.ReadKey();\ntask.Dispose();\ntask&nbsp;=&nbsp;null;\nGC.Collect(0);上面的代码，如果把GC.Collect去掉，那么异常信息就不会被输出，所以这种方式看似更简单，其实存在着局限性。Parallel中的异常处理相对于Task，Parallel的异常处理要简单很多，因为Parallel是会阻塞主线程的，它会等到所有的task执行完成了才会继续接下来的其他工作，而Task要采用非阻塞的方式去捕获异常，所以下面这样的代码就能把Parallel的异常抛给主线程：var&nbsp;exs&nbsp;=&nbsp;new&nbsp;ConcurrentQueue&lt;Exception&gt;();\ntry\n{\n&nbsp;&nbsp;&nbsp;&nbsp;Parallel.For(0,&nbsp;2,&nbsp;i&nbsp;=&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;ArgumentException();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(Exception&nbsp;e)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exs.Enqueue(e);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(exs.Any())\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;AggregateException(exs);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;});\n}\ncatch&nbsp;(AggregateException&nbsp;e)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(var&nbsp;ex&nbsp;in&nbsp;e.InnerExceptions)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine($&quot;异常类型：{ex.GetType()}，异常源：{ex.Source}，异常信息：{ex.Message}&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}输出结果为：我们专门声明了一个线程安全的集合ConcurrentQueue队列来存储异常信息，最终将这个异常集合包装给AggregateException再往外抛。总结其实并行编程没什么难的，主要是并行编程会给我们带来各种各样的坑，有时候我们踩坑了，可能永远不知道程序为什么出bug，可能为了一个bug，加了好几天班熬了好几天夜也不能解决。只要我们在并行编程的时候避掉这些坑，我们都是大神！其实大家眼中的大神跟自己差不多，也就是人家踩的坑多一点，而你踩的坑少一点而已，最后，祝大家踩坑快乐！",
    "postDate": "2019-01-30T23:40:45.33999+08:00",
    "email": "admin@masuit.com",
    "label": ".NET,多线程,异步,高并发",
    "keyword": null,
    "id": 1201,
    "indexId": "Post:1201"
  }
]